import {
  getRootDir,
  getStencilConfigFile,
  parseTagConfig,
  transformCompiledCode
} from "./chunk-G732UR3F.js";
import {
  BuildQueue
} from "./chunk-VVPPLAEV.js";
import {
  STENCIL_IMPORT
} from "./chunk-XZGMDIOC.js";

// src/index.ts
import path from "node:path";
import process from "node:process";
import { createCompiler } from "@stencil/core/compiler";
import nodeApi from "@stencil/core/sys/node";
import { findStaticImports, parseStaticImport } from "mlly";
import { createUnplugin } from "unplugin";
var DCE_OUTPUT_TARGET_NAME = "dist-custom-elements";
var compiler;
var buildQueue;
async function cleanup() {
  await compiler?.destroy();
  compiler = void 0;
  process.exit(1);
}
process.on("SIGTERM", cleanup);
process.on("SIGINT", cleanup);
var unpluginFactory = (options = {}) => {
  const nodeLogger = nodeApi.createNodeLogger();
  let distCustomElementsOptions;
  return {
    name: "unplugin-stencil",
    enforce: "pre",
    /**
     * This hook is called when the build starts. It is a good place to initialize
     */
    async buildStart() {
      const configPath = await getStencilConfigFile(options);
      const nodeSys = nodeApi.createNodeSys({ process, logger: nodeLogger });
      nodeApi.setupNodeProcess({ process, logger: nodeLogger });
      const coreCompiler = await nodeSys.dynamicImport(nodeSys.getCompilerExecutingPath());
      const validated = await coreCompiler.loadConfig({
        config: {
          rootDir: getRootDir(options),
          tsCompilerOptions: {
            skipLibCheck: true
          },
          flags: {
            task: "build",
            args: [],
            knownArgs: [],
            unknownArgs: []
          }
        },
        configPath,
        logger: nodeLogger,
        sys: nodeSys
      });
      distCustomElementsOptions = validated.config.outputTargets.find((o) => o.type === DCE_OUTPUT_TARGET_NAME);
      if (!distCustomElementsOptions)
        throw new Error(`Could not find "${DCE_OUTPUT_TARGET_NAME}" output target`);
      compiler = await createCompiler(validated.config);
      buildQueue = new BuildQueue(compiler);
    },
    async buildEnd() {
      process.exit(0);
    },
    /**
     * `transformInclude` is called for every file that is being transformed.
     * If it returns `true`, the file will be transformed.
     * @param id path of the file
     * @returns whether the file should be transformed
     */
    transformInclude(id) {
      return id.endsWith(".tsx");
    },
    /**
     * try to resolve any dynamic imported file through the compiler output directory
     * @param id the id to resolve
     * @returns the resolved id or null if not found
     */
    resolveId(id) {
      if (id.startsWith(".") && compiler && distCustomElementsOptions?.dir) {
        const compiledPath = path.resolve(distCustomElementsOptions.dir, id);
        try {
          const exists = compiler.sys.accessSync(compiledPath);
          if (exists) {
            return compiledPath;
          }
        } catch {
          return null;
        }
      }
      return null;
    },
    /**
     * This hook is called when a file is being transformed.
     * @param code the source code of the file
     * @param id path of the file
     * @returns the transformed code
     */
    async transform(code, id) {
      const staticImports = findStaticImports(code);
      const imports = staticImports.filter((imp) => imp.specifier === STENCIL_IMPORT).map((imp) => parseStaticImport(imp));
      const isStencilComponent = imports.some((imp) => "Component" in (imp.namedImports || {}));
      if (
        /**
         * something with the setup failed and some of the primitives we need
         * to compile the file are missing
         */
        !compiler || !buildQueue || !distCustomElementsOptions || !distCustomElementsOptions.dir || !isStencilComponent && !id.endsWith(".css")
      ) {
        return;
      }
      const componentTag = parseTagConfig(code);
      const compilerFilePath = path.resolve(distCustomElementsOptions.dir, `${componentTag}.js`);
      const raw = await buildQueue.getLatestBuild(id, compilerFilePath);
      const exists = await compiler.sys.access(compilerFilePath);
      if (!exists)
        throw new Error("Could not find the output file");
      const transformedCode = await transformCompiledCode(
        raw,
        compilerFilePath
      );
      return {
        code: transformedCode,
        inputFilePath: id
      };
    }
  };
};
var unplugin = /* @__PURE__ */ createUnplugin(unpluginFactory);
var index_default = unplugin;

export {
  unpluginFactory,
  unplugin,
  index_default
};
