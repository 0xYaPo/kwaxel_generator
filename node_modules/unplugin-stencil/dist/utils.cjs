"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  getCompilerOptions: () => getCompilerOptions,
  getRootDir: () => getRootDir,
  getStencilConfigFile: () => getStencilConfigFile,
  injectStencilImports: () => injectStencilImports,
  parseTagConfig: () => parseTagConfig,
  transformCompiledCode: () => transformCompiledCode
});
module.exports = __toCommonJS(utils_exports);
var import_promises = __toESM(require("fs/promises"), 1);
var import_node_path = __toESM(require("path"), 1);
var import_node_process = __toESM(require("process"), 1);
var import_mlly = require("mlly");

// src/constants.ts
var STENCIL_BUILD_DIR = ".stencil";
var DEFAULT_STENCIL_CONFIG = {
  watch: false,
  outputTargets: [
    {
      type: "dist-custom-elements",
      externalRuntime: true,
      customElementsExportBehavior: "auto-define-custom-elements"
    }
  ]
};
var COMPONENT_CLASS_DEFINITION = "/*@__PURE__*/ proxyCustomElement(class ";

// src/utils.ts
function injectStencilImports(code, imports) {
  const hasRenderFunctionImport = imports.some((imp) => "h" in (imp.namedImports || {}));
  if (!hasRenderFunctionImport)
    code = `import { h } from '@stencil/core/internal/client';
${code}`;
  const hasFragmentImport = imports.some((imp) => "Fragment" in (imp.namedImports || {}));
  if (!hasFragmentImport)
    code = `import { Fragment } from '@stencil/core/internal/client';
${code}`;
  return code;
}
var _tsCompilerOptions = null;
function getCompilerOptions(ts, rootDir) {
  if (_tsCompilerOptions)
    return _tsCompilerOptions;
  if (typeof rootDir !== "string")
    return null;
  const tsconfigFilePath = ts.findConfigFile(rootDir, ts.sys.fileExists);
  if (!tsconfigFilePath)
    return null;
  const tsconfigResults = ts.readConfigFile(tsconfigFilePath, ts.sys.readFile);
  if (tsconfigResults.error)
    throw new Error(tsconfigResults.error);
  const parseResult = ts.parseJsonConfigFileContent(
    tsconfigResults.config,
    ts.sys,
    rootDir,
    void 0,
    tsconfigFilePath
  );
  _tsCompilerOptions = parseResult.options;
  return _tsCompilerOptions;
}
function getRootDir(options) {
  return options.rootPath || import_node_process.default.cwd();
}
async function getStencilConfigFile(options) {
  if (options.rootPath) {
    const configFilePath2 = import_node_path.default.resolve(options.rootPath, "stencil.config.ts");
    if (await import_promises.default.stat(configFilePath2).catch(() => false))
      return configFilePath2;
  }
  const rootPath = getRootDir(options);
  const namespace = import_node_path.default.basename(rootPath);
  const stencilDir = import_node_path.default.resolve(rootPath, STENCIL_BUILD_DIR);
  await import_promises.default.mkdir(stencilDir, { recursive: true });
  const configFilePath = import_node_path.default.resolve(stencilDir, `${namespace}.stencil.config.ts`);
  const config = {
    ...DEFAULT_STENCIL_CONFIG,
    namespace,
    ...options.stencilConfig
  };
  const configCode = [
    `import type { Config } from '@stencil/core'
`,
    `export const config: Config = ${JSON.stringify(config, null, 2)}`
  ].join("\n");
  await import_promises.default.writeFile(configFilePath, configCode);
  return configFilePath;
}
function parseTagConfig(code) {
  const componentRegex = /@Component\(\s*(\{[\s\S]*?\})\s*\)/;
  const match = code.match(componentRegex);
  const configStr = match?.[1];
  if (!configStr) {
    return;
  }
  const tagMatch = configStr.match(/tag\s*:\s*['"`]([^'"`]+)['"`]/);
  if (!tagMatch?.[1]) {
    return;
  }
  return tagMatch[1];
}
function transformCompiledCode(code, outputPath) {
  const staticImports = (0, import_mlly.findStaticImports)(code);
  const imports = staticImports.map((imp) => (0, import_mlly.parseStaticImport)(imp));
  const outputDir = import_node_path.default.dirname(outputPath);
  const relativeImports = (0, import_mlly.findStaticImports)(code).filter((imp) => imp.specifier.startsWith("./"));
  for (const imp of relativeImports) {
    const localizedOutputPath = import_node_path.default.resolve(outputDir, imp.specifier);
    const newImport = imp.code.replace(imp.specifier, localizedOutputPath.split(import_node_path.default.sep).join(import_node_path.default.posix.sep));
    code = code.replace(imp.code, newImport);
  }
  if (code.includes(COMPONENT_CLASS_DEFINITION)) {
    code = code.split("\n").map((l) => l.includes(COMPONENT_CLASS_DEFINITION) ? `export ${l}` : l).join("\n");
  } else {
    const componentImport = imports.find((imp) => Object.values(imp.namedImports || {}).find((i) => i.startsWith("defineCustomElement")));
    const namedImport = Object.entries(componentImport?.namedImports || {})[0];
    if (namedImport && componentImport) {
      const localizedOutputPath = import_node_path.default.resolve(outputDir, componentImport.specifier);
      code += `
export { ${namedImport.join(" as ")} } from '${localizedOutputPath.split(import_node_path.default.sep).join(import_node_path.default.posix.sep)}';
`;
    }
  }
  return code;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getCompilerOptions,
  getRootDir,
  getStencilConfigFile,
  injectStencilImports,
  parseTagConfig,
  transformCompiledCode
});
exports.default = module.exports;