"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// src/astro.ts
var astro_exports = {};
__export(astro_exports, {
  default: () => astro_default
});
module.exports = __toCommonJS(astro_exports);

// src/index.ts
var import_node_path2 = __toESM(require("path"), 1);
var import_node_process2 = __toESM(require("process"), 1);
var import_compiler = require("@stencil/core/compiler");
var import_node = __toESM(require("@stencil/core/sys/node"), 1);
var import_mlly2 = require("mlly");
var import_unplugin = require("unplugin");

// src/build-queue.ts
var import_node_events = require("events");
var _compiler, _isBuilding, _pending, _BuildQueue_instances, queueBuild_fn, runBuild_fn;
var BuildQueue = class extends import_node_events.EventEmitter {
  constructor(compiler2) {
    super();
    __privateAdd(this, _BuildQueue_instances);
    __privateAdd(this, _compiler);
    __privateAdd(this, _isBuilding, false);
    __privateAdd(this, _pending, false);
    __privateSet(this, _compiler, compiler2);
  }
  async getLatestBuild(srcPath, distPath) {
    try {
      const [srcStats, distStats] = await Promise.all([
        __privateGet(this, _compiler).sys.stat(srcPath),
        __privateGet(this, _compiler).sys.stat(distPath)
      ]);
      if (distStats?.mtimeMs && srcStats?.mtimeMs && distStats.mtimeMs >= srcStats.mtimeMs) {
        return __privateGet(this, _compiler).sys.readFile(distPath);
      }
    } catch {
    }
    __privateMethod(this, _BuildQueue_instances, queueBuild_fn).call(this);
    await new Promise((resolve) => this.once("buildFinished", resolve));
    return __privateGet(this, _compiler).sys.readFile(distPath);
  }
};
_compiler = new WeakMap();
_isBuilding = new WeakMap();
_pending = new WeakMap();
_BuildQueue_instances = new WeakSet();
/**
 * Queues a build process. If a build is already in progress, set a pending flag and skip the build. Other vice initiates another build afterward
 */
queueBuild_fn = function() {
  if (__privateGet(this, _isBuilding)) {
    __privateSet(this, _pending, true);
    return;
  }
  __privateMethod(this, _BuildQueue_instances, runBuild_fn).call(this);
};
runBuild_fn = async function() {
  __privateSet(this, _isBuilding, true);
  this.emit("buildStart");
  try {
    await __privateGet(this, _compiler).build();
  } catch (err) {
    this.emit("buildError", err);
    throw err;
  } finally {
    __privateSet(this, _isBuilding, false);
    if (__privateGet(this, _pending)) {
      __privateSet(this, _pending, false);
      await __privateMethod(this, _BuildQueue_instances, runBuild_fn).call(this);
    } else {
      this.emit("buildFinished");
    }
  }
};

// src/constants.ts
var STENCIL_BUILD_DIR = ".stencil";
var STENCIL_IMPORT = "@stencil/core";
var DEFAULT_STENCIL_CONFIG = {
  watch: false,
  outputTargets: [
    {
      type: "dist-custom-elements",
      externalRuntime: true,
      customElementsExportBehavior: "auto-define-custom-elements"
    }
  ]
};
var COMPONENT_CLASS_DEFINITION = "/*@__PURE__*/ proxyCustomElement(class ";

// src/utils.ts
var import_promises = __toESM(require("fs/promises"), 1);
var import_node_path = __toESM(require("path"), 1);
var import_node_process = __toESM(require("process"), 1);
var import_mlly = require("mlly");
function getRootDir(options) {
  return options.rootPath || import_node_process.default.cwd();
}
async function getStencilConfigFile(options) {
  if (options.rootPath) {
    const configFilePath2 = import_node_path.default.resolve(options.rootPath, "stencil.config.ts");
    if (await import_promises.default.stat(configFilePath2).catch(() => false))
      return configFilePath2;
  }
  const rootPath = getRootDir(options);
  const namespace = import_node_path.default.basename(rootPath);
  const stencilDir = import_node_path.default.resolve(rootPath, STENCIL_BUILD_DIR);
  await import_promises.default.mkdir(stencilDir, { recursive: true });
  const configFilePath = import_node_path.default.resolve(stencilDir, `${namespace}.stencil.config.ts`);
  const config = {
    ...DEFAULT_STENCIL_CONFIG,
    namespace,
    ...options.stencilConfig
  };
  const configCode = [
    `import type { Config } from '@stencil/core'
`,
    `export const config: Config = ${JSON.stringify(config, null, 2)}`
  ].join("\n");
  await import_promises.default.writeFile(configFilePath, configCode);
  return configFilePath;
}
function parseTagConfig(code) {
  const componentRegex = /@Component\(\s*(\{[\s\S]*?\})\s*\)/;
  const match = code.match(componentRegex);
  const configStr = match?.[1];
  if (!configStr) {
    return;
  }
  const tagMatch = configStr.match(/tag\s*:\s*['"`]([^'"`]+)['"`]/);
  if (!tagMatch?.[1]) {
    return;
  }
  return tagMatch[1];
}
function transformCompiledCode(code, outputPath) {
  const staticImports = (0, import_mlly.findStaticImports)(code);
  const imports = staticImports.map((imp) => (0, import_mlly.parseStaticImport)(imp));
  const outputDir = import_node_path.default.dirname(outputPath);
  const relativeImports = (0, import_mlly.findStaticImports)(code).filter((imp) => imp.specifier.startsWith("./"));
  for (const imp of relativeImports) {
    const localizedOutputPath = import_node_path.default.resolve(outputDir, imp.specifier);
    const newImport = imp.code.replace(imp.specifier, localizedOutputPath.split(import_node_path.default.sep).join(import_node_path.default.posix.sep));
    code = code.replace(imp.code, newImport);
  }
  if (code.includes(COMPONENT_CLASS_DEFINITION)) {
    code = code.split("\n").map((l) => l.includes(COMPONENT_CLASS_DEFINITION) ? `export ${l}` : l).join("\n");
  } else {
    const componentImport = imports.find((imp) => Object.values(imp.namedImports || {}).find((i) => i.startsWith("defineCustomElement")));
    const namedImport = Object.entries(componentImport?.namedImports || {})[0];
    if (namedImport && componentImport) {
      const localizedOutputPath = import_node_path.default.resolve(outputDir, componentImport.specifier);
      code += `
export { ${namedImport.join(" as ")} } from '${localizedOutputPath.split(import_node_path.default.sep).join(import_node_path.default.posix.sep)}';
`;
    }
  }
  return code;
}

// src/index.ts
var DCE_OUTPUT_TARGET_NAME = "dist-custom-elements";
var compiler;
var buildQueue;
async function cleanup() {
  await compiler?.destroy();
  compiler = void 0;
  import_node_process2.default.exit(1);
}
import_node_process2.default.on("SIGTERM", cleanup);
import_node_process2.default.on("SIGINT", cleanup);
var unpluginFactory = (options = {}) => {
  const nodeLogger = import_node.default.createNodeLogger();
  let distCustomElementsOptions;
  return {
    name: "unplugin-stencil",
    enforce: "pre",
    /**
     * This hook is called when the build starts. It is a good place to initialize
     */
    async buildStart() {
      const configPath = await getStencilConfigFile(options);
      const nodeSys = import_node.default.createNodeSys({ process: import_node_process2.default, logger: nodeLogger });
      import_node.default.setupNodeProcess({ process: import_node_process2.default, logger: nodeLogger });
      const coreCompiler = await nodeSys.dynamicImport(nodeSys.getCompilerExecutingPath());
      const validated = await coreCompiler.loadConfig({
        config: {
          rootDir: getRootDir(options),
          tsCompilerOptions: {
            skipLibCheck: true
          },
          flags: {
            task: "build",
            args: [],
            knownArgs: [],
            unknownArgs: []
          }
        },
        configPath,
        logger: nodeLogger,
        sys: nodeSys
      });
      distCustomElementsOptions = validated.config.outputTargets.find((o) => o.type === DCE_OUTPUT_TARGET_NAME);
      if (!distCustomElementsOptions)
        throw new Error(`Could not find "${DCE_OUTPUT_TARGET_NAME}" output target`);
      compiler = await (0, import_compiler.createCompiler)(validated.config);
      buildQueue = new BuildQueue(compiler);
    },
    async buildEnd() {
      import_node_process2.default.exit(0);
    },
    /**
     * `transformInclude` is called for every file that is being transformed.
     * If it returns `true`, the file will be transformed.
     * @param id path of the file
     * @returns whether the file should be transformed
     */
    transformInclude(id) {
      return id.endsWith(".tsx");
    },
    /**
     * try to resolve any dynamic imported file through the compiler output directory
     * @param id the id to resolve
     * @returns the resolved id or null if not found
     */
    resolveId(id) {
      if (id.startsWith(".") && compiler && distCustomElementsOptions?.dir) {
        const compiledPath = import_node_path2.default.resolve(distCustomElementsOptions.dir, id);
        try {
          const exists = compiler.sys.accessSync(compiledPath);
          if (exists) {
            return compiledPath;
          }
        } catch {
          return null;
        }
      }
      return null;
    },
    /**
     * This hook is called when a file is being transformed.
     * @param code the source code of the file
     * @param id path of the file
     * @returns the transformed code
     */
    async transform(code, id) {
      const staticImports = (0, import_mlly2.findStaticImports)(code);
      const imports = staticImports.filter((imp) => imp.specifier === STENCIL_IMPORT).map((imp) => (0, import_mlly2.parseStaticImport)(imp));
      const isStencilComponent = imports.some((imp) => "Component" in (imp.namedImports || {}));
      if (
        /**
         * something with the setup failed and some of the primitives we need
         * to compile the file are missing
         */
        !compiler || !buildQueue || !distCustomElementsOptions || !distCustomElementsOptions.dir || !isStencilComponent && !id.endsWith(".css")
      ) {
        return;
      }
      const componentTag = parseTagConfig(code);
      const compilerFilePath = import_node_path2.default.resolve(distCustomElementsOptions.dir, `${componentTag}.js`);
      const raw = await buildQueue.getLatestBuild(id, compilerFilePath);
      const exists = await compiler.sys.access(compilerFilePath);
      if (!exists)
        throw new Error("Could not find the output file");
      const transformedCode = await transformCompiledCode(
        raw,
        compilerFilePath
      );
      return {
        code: transformedCode,
        inputFilePath: id
      };
    }
  };
};
var unplugin = /* @__PURE__ */ (0, import_unplugin.createUnplugin)(unpluginFactory);
var index_default = unplugin;

// src/astro.ts
var astro_default = (options) => ({
  name: "unplugin-starter",
  hooks: {
    "astro:config:setup": async (astro) => {
      var _a;
      (_a = astro.config.vite).plugins || (_a.plugins = []);
      astro.config.vite.plugins.push(index_default.vite(options));
    }
  }
});
exports.default = module.exports;