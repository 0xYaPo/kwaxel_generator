import {
  COMPONENT_CLASS_DEFINITION,
  DEFAULT_STENCIL_CONFIG,
  STENCIL_BUILD_DIR
} from "./chunk-XZGMDIOC.js";

// src/utils.ts
import fs from "node:fs/promises";
import path from "node:path";
import process from "node:process";
import { findStaticImports, parseStaticImport } from "mlly";
function injectStencilImports(code, imports) {
  const hasRenderFunctionImport = imports.some((imp) => "h" in (imp.namedImports || {}));
  if (!hasRenderFunctionImport)
    code = `import { h } from '@stencil/core/internal/client';
${code}`;
  const hasFragmentImport = imports.some((imp) => "Fragment" in (imp.namedImports || {}));
  if (!hasFragmentImport)
    code = `import { Fragment } from '@stencil/core/internal/client';
${code}`;
  return code;
}
var _tsCompilerOptions = null;
function getCompilerOptions(ts, rootDir) {
  if (_tsCompilerOptions)
    return _tsCompilerOptions;
  if (typeof rootDir !== "string")
    return null;
  const tsconfigFilePath = ts.findConfigFile(rootDir, ts.sys.fileExists);
  if (!tsconfigFilePath)
    return null;
  const tsconfigResults = ts.readConfigFile(tsconfigFilePath, ts.sys.readFile);
  if (tsconfigResults.error)
    throw new Error(tsconfigResults.error);
  const parseResult = ts.parseJsonConfigFileContent(
    tsconfigResults.config,
    ts.sys,
    rootDir,
    void 0,
    tsconfigFilePath
  );
  _tsCompilerOptions = parseResult.options;
  return _tsCompilerOptions;
}
function getRootDir(options) {
  return options.rootPath || process.cwd();
}
async function getStencilConfigFile(options) {
  if (options.rootPath) {
    const configFilePath2 = path.resolve(options.rootPath, "stencil.config.ts");
    if (await fs.stat(configFilePath2).catch(() => false))
      return configFilePath2;
  }
  const rootPath = getRootDir(options);
  const namespace = path.basename(rootPath);
  const stencilDir = path.resolve(rootPath, STENCIL_BUILD_DIR);
  await fs.mkdir(stencilDir, { recursive: true });
  const configFilePath = path.resolve(stencilDir, `${namespace}.stencil.config.ts`);
  const config = {
    ...DEFAULT_STENCIL_CONFIG,
    namespace,
    ...options.stencilConfig
  };
  const configCode = [
    `import type { Config } from '@stencil/core'
`,
    `export const config: Config = ${JSON.stringify(config, null, 2)}`
  ].join("\n");
  await fs.writeFile(configFilePath, configCode);
  return configFilePath;
}
function parseTagConfig(code) {
  const componentRegex = /@Component\(\s*(\{[\s\S]*?\})\s*\)/;
  const match = code.match(componentRegex);
  const configStr = match?.[1];
  if (!configStr) {
    return;
  }
  const tagMatch = configStr.match(/tag\s*:\s*['"`]([^'"`]+)['"`]/);
  if (!tagMatch?.[1]) {
    return;
  }
  return tagMatch[1];
}
function transformCompiledCode(code, outputPath) {
  const staticImports = findStaticImports(code);
  const imports = staticImports.map((imp) => parseStaticImport(imp));
  const outputDir = path.dirname(outputPath);
  const relativeImports = findStaticImports(code).filter((imp) => imp.specifier.startsWith("./"));
  for (const imp of relativeImports) {
    const localizedOutputPath = path.resolve(outputDir, imp.specifier);
    const newImport = imp.code.replace(imp.specifier, localizedOutputPath.split(path.sep).join(path.posix.sep));
    code = code.replace(imp.code, newImport);
  }
  if (code.includes(COMPONENT_CLASS_DEFINITION)) {
    code = code.split("\n").map((l) => l.includes(COMPONENT_CLASS_DEFINITION) ? `export ${l}` : l).join("\n");
  } else {
    const componentImport = imports.find((imp) => Object.values(imp.namedImports || {}).find((i) => i.startsWith("defineCustomElement")));
    const namedImport = Object.entries(componentImport?.namedImports || {})[0];
    if (namedImport && componentImport) {
      const localizedOutputPath = path.resolve(outputDir, componentImport.specifier);
      code += `
export { ${namedImport.join(" as ")} } from '${localizedOutputPath.split(path.sep).join(path.posix.sep)}';
`;
    }
  }
  return code;
}

export {
  injectStencilImports,
  getCompilerOptions,
  getRootDir,
  getStencilConfigFile,
  parseTagConfig,
  transformCompiledCode
};
