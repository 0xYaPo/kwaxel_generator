import axios from "axios";
import { NativeAuthClientConfig } from "./entities/native.auth.client.config";
class NativeAuthClient {
  config;
  constructor(config) {
    this.config = Object.assign(new NativeAuthClientConfig(), config);
  }
  getToken(address, token, signature) {
    const encodedAddress = this.encodeValue(address);
    const encodedToken = this.encodeValue(token);
    const accessToken = `${encodedAddress}.${encodedToken}.${signature}`;
    return accessToken;
  }
  async initialize(extraInfo = {}) {
    const blockHash = await this.getCurrentBlockHash();
    const encodedExtraInfo = this.encodeValue(JSON.stringify(extraInfo));
    const origin = this.encodeValue(this.config.origin);
    return `${origin}.${blockHash}.${this.config.expirySeconds}.${encodedExtraInfo}`;
  }
  async getCurrentBlockHash() {
    if (this.config.gatewayUrl) {
      return await this.getCurrentBlockHashWithGateway();
    }
    return await this.getCurrentBlockHashWithApi();
  }
  async getCurrentBlockHashWithGateway() {
    const round = await this.getCurrentRound();
    const url = `${this.config.gatewayUrl}/blocks/by-round/${round}`;
    const response = await this.get(url);
    const blocks = response.data.data.blocks;
    const block = blocks.filter(
      (block2) => block2.shard === this.config.blockHashShard
    )[0];
    return block.hash;
  }
  async getCurrentRound() {
    if (!this.config.gatewayUrl) {
      throw new Error("Gateway URL not set");
    }
    if (!this.config.blockHashShard) {
      throw new Error("Blockhash shard not set");
    }
    const url = `${this.config.gatewayUrl}/network/status/${this.config.blockHashShard}`;
    const response = await this.get(url);
    const status = response.data.data.status;
    return status.erd_current_round;
  }
  async getCurrentBlockHashWithApi() {
    try {
      const url = `${this.config.apiUrl}/blocks/latest?ttl=${this.config.expirySeconds}&fields=hash`;
      const response = await this.get(url);
      if (response.data[0].hash !== void 0) {
        return response.data[0].hash;
      }
    } catch (error) {
    }
    return this.getCurrentBlockHashWithApiFallback();
  }
  async getCurrentBlockHashWithApiFallback() {
    let url = `${this.config.apiUrl}/blocks?size=1&fields=hash`;
    if (this.config.blockHashShard !== void 0) {
      url += `&shard=${this.config.blockHashShard}`;
    }
    const response = await this.get(url);
    return response.data[0].hash;
  }
  encodeValue(str) {
    return this.escape(Buffer.from(str, "utf8").toString("base64"));
  }
  escape(str) {
    return str.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  }
  async get(url) {
    return await axios.get(url, { headers: this.config.extraRequestHeaders });
  }
}
export {
  NativeAuthClient
};
//# sourceMappingURL=native.auth.client.js.map
