"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatAmount = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const constants_1 = require("../constants");
const stringIsInteger_1 = require("./stringIsInteger");
const pipe_1 = require("./pipe");
/**
 * Formats blockchain token amounts from their smallest unit representation
 * to human-readable decimal format with configurable precision and formatting options.
 *
 * This function handles the conversion from raw integer token amounts (as stored on blockchain)
 * to human-readable decimal format with proper formatting, precision control, and edge case handling.
 *
 * @param props - Configuration object with formatting options
 * @returns Formatted string representation of the amount
 *
 * @throws {Error} When input is not a valid integer string
 *
 * @example
 * // Basic usage - 1.5 EGLD
 * formatAmount({ input: "1500000000000000000" })
 * // Returns: "1.5"
 *
 * @example
 * // With precision control
 * formatAmount({
 *   input: "1123456789000000000",
 *   showLastNonZeroDecimal: false,
 *   digits: 4
 * })
 * // Returns: "1.1234"
 *
 * @example
 * // With precision control
 * formatAmount({
 *   input: "1123456789000000000",
 *   showLastNonZeroDecimal: true,
 *   digits: 4
 * })
 * // Returns: "1.123456789"
 *
 * @example
 * // With thousands separators
 * formatAmount({
 *   input: "1000000000000000000000",
 *   addCommas: true
 * })
 * // Returns: "1,000"
 *
 * @example
 * // Custom token with 6 decimals (USDC)
 * formatAmount({
 *   input: "1500000",
 *   decimals: 6
 * })
 * // Returns: "1.5"
 *
 * @example
 * // Very small amounts with less-than label
 * formatAmount({
 *   input: "1",
 *   decimals: 18,
 *   digits: 4,
 *   showIsLessThanDecimalsLabel: true
 * })
 * // Returns: "<0.0001"
 */
function formatAmount({ addCommas = false, decimals = constants_1.DECIMALS, digits = constants_1.DIGITS, input, showIsLessThanDecimalsLabel = false, showLastNonZeroDecimal = true }) {
    if (!(0, stringIsInteger_1.stringIsInteger)(input, false)) {
        throw new Error('Invalid input');
    }
    const LocalBigNumber = bignumber_js_1.default.clone();
    LocalBigNumber.config({ ROUNDING_MODE: bignumber_js_1.default.ROUND_FLOOR });
    const isNegative = LocalBigNumber(input).isNegative();
    let modInput = input;
    if (isNegative) {
        // remove - at start of input
        modInput = input.substring(1);
    }
    return ((0, pipe_1.pipe)(modInput)
        // format
        .then(() => {
        const amountBN = new LocalBigNumber(modInput);
        const divisor = new LocalBigNumber(10).pow(decimals);
        const result = amountBN.dividedBy(divisor);
        return result.toFixed(decimals);
    })
        // format
        .then((current) => {
        const bnBalance = LocalBigNumber(current);
        if (bnBalance.isZero()) {
            return constants_1.ZERO;
        }
        const balance = bnBalance.toString(10);
        const [integerPart, decimalPart] = balance.split('.');
        // Handle case where there's no decimal part (pure integers)
        if (!decimalPart) {
            if (showLastNonZeroDecimal) {
                // For integers with showLastNonZeroDecimal=true, don't show decimals
                return addCommas
                    ? LocalBigNumber(integerPart).toFormat(0)
                    : integerPart;
            }
            else {
                // For showLastNonZeroDecimal=false, don't show decimals for pure integers
                return addCommas
                    ? LocalBigNumber(integerPart).toFormat(0)
                    : integerPart;
            }
        }
        const bNdecimalPart = LocalBigNumber(decimalPart);
        // Handle case where decimal part is all zeros
        if (bNdecimalPart.isZero()) {
            if (showLastNonZeroDecimal) {
                // For integers with showLastNonZeroDecimal=true, don't show decimals
                return addCommas
                    ? LocalBigNumber(integerPart).toFormat(0)
                    : integerPart;
            }
            else {
                // For showLastNonZeroDecimal=false, don't show decimals for effectively integer values
                return addCommas
                    ? LocalBigNumber(integerPart).toFormat(0)
                    : integerPart;
            }
        }
        // Find the last non-zero decimal position
        const lastNonZeroIndex = decimalPart
            .split('')
            .reverse()
            .findIndex((digit) => digit !== '0');
        const actualDecimalPlaces = decimalPart.length - lastNonZeroIndex;
        let finalDecimalPlaces;
        if (showLastNonZeroDecimal) {
            // Show all decimals if more than digits, otherwise show only the actual non-zero decimals
            finalDecimalPlaces = Math.max(actualDecimalPlaces, 0);
        }
        else {
            // Show exactly digits decimal places
            finalDecimalPlaces = digits;
        }
        // Handle special case: very small amounts that would round to zero
        const shownDecimalsAreZero = digits >= 1 &&
            digits <= decimalPart.length &&
            bNdecimalPart.isGreaterThan(0) &&
            LocalBigNumber(decimalPart.substring(0, digits)).isZero();
        if (shownDecimalsAreZero) {
            const integerPartZero = LocalBigNumber(integerPart).isZero();
            const zeroPlaceholders = new Array(digits - 1).fill(0);
            const zeros = [...zeroPlaceholders, 0].join('');
            const minAmount = [...zeroPlaceholders, 1].join(''); // 00..1
            if (!integerPartZero) {
                const intFormat = addCommas
                    ? LocalBigNumber(integerPart).toFormat(0)
                    : integerPart;
                return `${intFormat}.${zeros}`;
            }
            if (showIsLessThanDecimalsLabel) {
                const intFormat = addCommas
                    ? LocalBigNumber(integerPart).toFormat(0)
                    : integerPart;
                return `<${intFormat}.${minAmount}`;
            }
            if (!showLastNonZeroDecimal) {
                return addCommas
                    ? LocalBigNumber(integerPart).toFormat(0)
                    : integerPart;
            }
            // For showLastNonZeroDecimal=true, show the actual decimals
            const formattedValue = bnBalance.toFixed(finalDecimalPlaces);
            const [, formattedDecimalPart] = formattedValue.split('.');
            const intFormat = addCommas
                ? LocalBigNumber(integerPart).toFormat(0)
                : integerPart;
            return `${intFormat}.${formattedDecimalPart}`;
        }
        // Normal case: format with the calculated decimal places
        let formattedValue;
        if (showLastNonZeroDecimal) {
            // Show actual decimal places without padding for showLastNonZeroDecimal=true
            formattedValue = bnBalance.toFixed(actualDecimalPlaces);
        }
        else {
            // Show exactly digits decimal places for showLastNonZeroDecimal=false
            formattedValue = bnBalance.toFixed(digits);
        }
        // Apply comma formatting if requested
        if (addCommas) {
            const [intPart, decPart] = formattedValue.split('.');
            const formattedIntPart = LocalBigNumber(intPart).toFormat(0);
            formattedValue = decPart
                ? `${formattedIntPart}.${decPart}`
                : formattedIntPart;
        }
        return formattedValue;
    })
        .if(isNegative)
        .then((current) => `-${current}`)
        .valueOf());
}
exports.formatAmount = formatAmount;
//# sourceMappingURL=formatAmount.js.map