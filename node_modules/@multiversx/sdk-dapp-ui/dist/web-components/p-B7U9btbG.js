/**
 * Utility to manage a "ready" state with a Promise.
 *
 * Some methods (e.g., getEventBus) should only be usable after
 * initialization. This class provides a promise you can await and
 * a resolver to mark readiness.
 */
class ConnectionMonitor {
    constructor() {
        this.ready = new Promise(resolve => {
            this.resolveFn = resolve;
        });
    }
    /**
     * Wait until the connection is marked as ready.
     *
     * @returns A promise that resolves when `connect()` is called.
     *
     * @example
     * ```ts
     * await connectionMonitor.waitForConnection();
     * ```
     */
    waitForConnection() {
        return this.ready;
    }
    /**
     * Mark the connection as ready, resolving all waiters.
     *
     * Once called, `waitForConnection()` will resolve for any pending
     * and future calls.
     *
     * @example
     * ```ts
     * connectionMonitor.connect();
     * ```
     */
    connect() {
        this.resolveFn();
    }
}

let devTools = null;
if (typeof window !== 'undefined') {
    const reduxDevTools = window.__REDUX_DEVTOOLS_EXTENSION__;
    if (reduxDevTools) {
        devTools = reduxDevTools.connect({ name: 'sdk-dapp-ui' });
        devTools.init({});
    }
}
function sendToDevtools(action, data) {
    if (!devTools) {
        return;
    }
    devTools.send(action, data);
}

class EventBus {
    constructor() {
        this.subscribers = {};
    }
    // Rest of the implementation remains the same
    subscribe(event, callback) {
        if (!this.subscribers[event]) {
            this.subscribers[event] = [];
        }
        sendToDevtools(event, 'SUBSCRIBE');
        this.subscribers[event].push(callback);
        return () => {
            this.unsubscribe(event, callback);
        };
    }
    publish(event, data) {
        if (!this.subscribers[event]) {
            return;
        }
        sendToDevtools(event, data);
        this.subscribers[event].forEach(callback => callback(data));
    }
    unsubscribe(event, callback) {
        if (!this.subscribers[event]) {
            return;
        }
        sendToDevtools(event, 'UNSUBSCRIBE');
        this.subscribers[event] = this.subscribers[event].filter(cb => cb !== callback);
    }
}

export { ConnectionMonitor as C, EventBus as E };
