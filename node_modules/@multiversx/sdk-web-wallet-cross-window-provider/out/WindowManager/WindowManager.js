"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WindowManager = void 0;
const constants_1 = require("../constants");
const constants_2 = require("../CrossWindowProvider/PopupConsent/constants");
const enums_1 = require("../enums");
const errors_1 = require("../errors");
class WindowManager {
    constructor() {
        var _a, _b;
        this._session = '';
        this._walletUrl = '';
        this.initialized = false;
        this.walletWindow = null;
        this.isPopupBlocked = false;
        this._isLoggingOut = false;
        this.activeListeners = new Map();
        (_a = constants_1.safeWindow.addEventListener) === null || _a === void 0 ? void 0 : _a.call(constants_1.safeWindow, 'beforeunload', () => {
            this.closeWalletWindow();
        });
        constants_1.safeWindow.name = (_b = constants_1.safeWindow.location) === null || _b === void 0 ? void 0 : _b.origin;
        this._loadSessionFromStorage();
    }
    get walletUrl() {
        return this._walletUrl;
    }
    setWalletUrl(url) {
        this._walletUrl = url;
        return this;
    }
    _loadSessionFromStorage() {
        var _a;
        try {
            const storedSession = (_a = constants_1.safeWindow.sessionStorage) === null || _a === void 0 ? void 0 : _a.getItem(WindowManager.SESSION_STORAGE_KEY);
            if (storedSession) {
                this._session = storedSession;
            }
        }
        catch (error) {
            console.warn('Failed to load session from sessionStorage:', error);
        }
    }
    _saveSessionToStorage(sessionId) {
        var _a;
        try {
            (_a = constants_1.safeWindow.sessionStorage) === null || _a === void 0 ? void 0 : _a.setItem(WindowManager.SESSION_STORAGE_KEY, sessionId);
        }
        catch (error) {
            console.warn('Failed to save session to sessionStorage:', error);
        }
    }
    _clearSessionFromStorage() {
        var _a;
        try {
            (_a = constants_1.safeWindow.sessionStorage) === null || _a === void 0 ? void 0 : _a.removeItem(WindowManager.SESSION_STORAGE_KEY);
        }
        catch (error) {
            console.warn('Failed to clear session from sessionStorage:', error);
        }
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.initialized = typeof window !== 'undefined';
            return this.initialized;
        });
    }
    onDestroy() {
        this.initialized = false;
        return this.initialized;
    }
    isWalletOpened(type) {
        return (type === enums_1.WindowProviderRequestEnums.cancelAction &&
            Boolean(this.walletWindow));
    }
    openPopupConsent() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof document === 'undefined' ||
                typeof window === 'undefined' ||
                !this.isPopupBlocked) {
                return true;
            }
            const module = yield Promise.resolve().then(() => __importStar(require('../CrossWindowProvider/PopupConsent/PopupConsent')));
            const PopupConsent = module.PopupConsent;
            const customElements = constants_1.safeWindow.customElements;
            if (customElements && !customElements.get(constants_2.confirmationDialogTag)) {
                customElements.define(constants_2.confirmationDialogTag, PopupConsent);
            }
            const popup = document.createElement(constants_2.confirmationDialogTag);
            popup.walletUrl = this.walletUrl;
            document.body.appendChild(popup);
            const popupConsentResponse = yield new Promise((resolve) => {
                popup.onConfirm = () => {
                    resolve(true);
                    document.body.removeChild(popup);
                };
                popup.onCancel = () => {
                    resolve(false);
                    document.body.removeChild(popup);
                };
            });
            return popupConsentResponse;
        });
    }
    handshake(type) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const isOpened = this.isWalletOpened(type);
            if (isOpened) {
                return true;
            }
            this.closeWalletWindow();
            const isWindowInitialized = yield this.setWalletWindow();
            if (!isWindowInitialized) {
                const popupConsentResponse = yield this.openPopupConsent();
                if (!popupConsentResponse) {
                    throw new errors_1.ErrCouldNotLogin();
                }
            }
            const { payload } = yield this.listenOnce(enums_1.WindowProviderResponseEnums.handshakeResponse);
            if (!payload) {
                throw new errors_1.ErrCannotEstablishHandshake();
            }
            const receivedSession = typeof payload === 'string' ? payload : payload.data;
            this._session = this._session || receivedSession || Date.now().toString();
            // Save the current session in sessionStorage to preserve it across page reloads
            this._saveSessionToStorage(this._session);
            (_a = this.walletWindow) === null || _a === void 0 ? void 0 : _a.postMessage({
                type: enums_1.WindowProviderRequestEnums.finalizeHandshakeRequest,
                payload: this._session
            }, this.walletUrl);
            this.addHandshakeChangeListener();
            return true;
        });
    }
    addHandshakeChangeListener() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const walletUrl = this.walletUrl;
            const eventHandler = (event) => {
                var _a, _b;
                try {
                    const { type, payload } = event.data;
                    const isWalletEvent = event.origin === new URL(walletUrl).origin;
                    if (!isWalletEvent) {
                        return;
                    }
                    switch (type) {
                        case enums_1.WindowProviderResponseEnums.handshakeResponse:
                            if (payload === '') {
                                (_a = this.walletWindow) === null || _a === void 0 ? void 0 : _a.close();
                                this.walletWindow = null;
                                (_b = constants_1.safeWindow.removeEventListener) === null || _b === void 0 ? void 0 : _b.call(constants_1.safeWindow, 'message', eventHandler);
                                break;
                            }
                            // Save the current session and send it in later handshake requests
                            if (typeof payload === 'string') {
                                this._session = payload;
                                this._saveSessionToStorage(this._session);
                            }
                            break;
                    }
                }
                catch (e) {
                    console.error('Handshake response error', e);
                }
            };
            (_a = constants_1.safeWindow.addEventListener) === null || _a === void 0 ? void 0 : _a.call(constants_1.safeWindow, 'message', eventHandler);
        });
    }
    listenOnce(action) {
        return __awaiter(this, void 0, void 0, function* () {
            // If the wallet window was previously blocked (e.g., by a popup blocker),
            // reinitialize the connection by opening the wallet window again.
            if (!this.walletWindow) {
                const isWindowInitialized = yield this.setWalletWindow();
                if (!isWindowInitialized) {
                    throw new errors_1.ErrProviderNotInstantiated();
                }
            }
            return new Promise((resolve) => {
                const walletUrl = this.walletUrl;
                // Prevent duplicate listeners for the same action
                if (this.activeListeners.has(action)) {
                    const existingHandler = this.activeListeners.get(action);
                    if (existingHandler) {
                        constants_1.safeWindow.removeEventListener('message', existingHandler);
                    }
                }
                const eventHandler = (event) => {
                    const { type, payload } = event.data;
                    const isWalletEvent = event.origin === new URL(walletUrl).origin;
                    const isCurrentAction = action === type ||
                        type === enums_1.WindowProviderResponseEnums.cancelResponse;
                    if (!isCurrentAction || !isWalletEvent) {
                        return;
                    }
                    constants_1.safeWindow.removeEventListener('message', eventHandler);
                    this.activeListeners.delete(action);
                    resolve({ type, payload });
                };
                constants_1.safeWindow.addEventListener('message', eventHandler);
                this.activeListeners.set(action, eventHandler);
            });
        });
    }
    closeConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isLoggingOut) {
                console.warn('Logout already in progress');
                return false;
            }
            if (!this.initialized) {
                throw new errors_1.ErrProviderNotInitialized();
            }
            this._isLoggingOut = true;
            try {
                yield this.postMessage({
                    type: enums_1.WindowProviderRequestEnums.logoutRequest,
                    payload: undefined
                });
                this._session = Date.now().toString();
                this._clearSessionFromStorage();
                this.initialized = false;
                return true;
            }
            finally {
                this._isLoggingOut = false;
            }
        });
    }
    isInitialized() {
        return this.initialized;
    }
    postMessage({ type, payload }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handshake(type);
            (_a = this.walletWindow) === null || _a === void 0 ? void 0 : _a.postMessage({
                type,
                payload
            }, this.walletUrl);
            const data = yield this.listenOnce(constants_1.responseTypeMap[type]);
            this.closeWalletWindow();
            return data;
        });
    }
    closeWalletWindow() {
        var _a;
        (_a = this.walletWindow) === null || _a === void 0 ? void 0 : _a.close();
    }
    setWalletWindow() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.walletWindow =
                (_b = (_a = constants_1.safeWindow.open) === null || _a === void 0 ? void 0 : _a.call(constants_1.safeWindow, this.walletUrl, this.walletUrl)) !== null && _b !== void 0 ? _b : null;
            const isWindowInitialized = Boolean(this.walletWindow);
            this.isPopupBlocked = !isWindowInitialized;
            return isWindowInitialized;
        });
    }
}
WindowManager.SESSION_STORAGE_KEY = 'mx-wallet-session-id';
exports.WindowManager = WindowManager;
//# sourceMappingURL=WindowManager.js.map