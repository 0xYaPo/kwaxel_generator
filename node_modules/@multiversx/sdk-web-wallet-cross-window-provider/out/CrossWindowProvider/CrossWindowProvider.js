"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CrossWindowProvider = void 0;
const sdk_core_1 = require("@multiversx/sdk-core");
const enums_1 = require("../enums");
const errors_1 = require("../errors");
const WindowManager_1 = require("../WindowManager");
class CrossWindowProvider {
    constructor() {
        this.account = { address: '' };
        this.accessToken = undefined;
        this.initialized = false;
        this.windowManager = new WindowManager_1.WindowManager();
    }
    ensureConnected() {
        if (!this.account.address) {
            throw new errors_1.ErrAccountNotConnected();
        }
    }
    disconnect() {
        this.account = { address: '' };
    }
    static getInstance() {
        if (!CrossWindowProvider._instance) {
            CrossWindowProvider._instance = new CrossWindowProvider();
            return CrossWindowProvider._instance;
        }
        return CrossWindowProvider._instance;
    }
    getWindowManager() {
        return this.windowManager;
    }
    setAddress(address) {
        this.account.address = address;
        return this;
    }
    setWalletUrl(url) {
        this.windowManager.setWalletUrl(url);
        return this;
    }
    setWalletWindow() {
        return this.windowManager.setWalletWindow();
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.initialized = yield this.windowManager.init();
            return this.initialized;
        });
    }
    onDestroy() {
        CrossWindowProvider._instance = null;
        this.initialized = this.windowManager.onDestroy();
        return this.initialized;
    }
    login(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                throw new errors_1.ErrProviderNotInitialized();
            }
            const isRelogin = this.isConnected();
            if (isRelogin) {
                const { address, signature, multisig, impersonate } = this.account;
                return {
                    address,
                    signature,
                    multisig,
                    impersonate
                };
            }
            this.accessToken = options.token;
            const { payload: { data, error } } = yield this.windowManager.postMessage({
                type: enums_1.WindowProviderRequestEnums.loginRequest,
                payload: {
                    token: this.accessToken
                }
            });
            if (error || !data) {
                throw new errors_1.ErrCouldNotLogin();
            }
            this.account.address = data.address;
            this.account.signature = data.signature;
            this.account.multisig = data.multisig;
            this.account.impersonate = data.impersonate;
            return {
                address: this.account.address,
                signature: this.account.signature,
                multisig: this.account.multisig,
                impersonate: this.account.impersonate
            };
        });
    }
    dispose() {
        return __awaiter(this, void 0, void 0, function* () {
            const connectionClosed = yield this.windowManager.closeConnection();
            this.initialized = !connectionClosed;
            CrossWindowProvider._instance = null;
            return connectionClosed;
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                throw new errors_1.ErrProviderNotInitialized();
            }
            this.ensureConnected();
            const connectionClosed = yield this.dispose();
            this.disconnect();
            return connectionClosed;
        });
    }
    getAddress() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                throw new errors_1.ErrProviderNotInitialized();
            }
            return (_b = (_a = this.account) === null || _a === void 0 ? void 0 : _a.address) !== null && _b !== void 0 ? _b : '';
        });
    }
    isInitialized() {
        return this.initialized;
    }
    isConnected() {
        return Boolean(this.account.address);
    }
    getAccount() {
        return this.account;
    }
    setAccount(account) {
        this.account = account;
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            this.ensureConnected();
            const signedTransactions = yield this.signTransactions([transaction]);
            if (signedTransactions.length != 1) {
                throw new errors_1.ErrCannotSignSingleTransaction();
            }
            return signedTransactions[0];
        });
    }
    signTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            this.ensureConnected();
            const { type, payload: { data: signedPlainTransactions, error } } = yield this.windowManager.postMessage({
                type: enums_1.WindowProviderRequestEnums.signTransactionsRequest,
                payload: transactions.map((tx) => tx.toPlainObject())
            });
            if (error || !signedPlainTransactions) {
                throw new errors_1.ErrCouldNotSignTransactions();
            }
            if (type === enums_1.WindowProviderResponseEnums.cancelResponse) {
                throw new errors_1.ErrTransactionCancelled();
            }
            const hasTransactions = (signedPlainTransactions === null || signedPlainTransactions === void 0 ? void 0 : signedPlainTransactions.length) > 0;
            if (!hasTransactions) {
                throw new errors_1.ErrCouldNotSignTransactions();
            }
            return signedPlainTransactions.map((tx) => sdk_core_1.Transaction.newFromPlainObject(tx));
        });
    }
    guardTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            this.ensureConnected();
            const { type, payload: { data: signedPlainTransactions, error } } = yield this.windowManager.postMessage({
                type: enums_1.WindowProviderRequestEnums.guardTransactionsRequest,
                payload: transactions.map((tx) => tx.toPlainObject())
            });
            if (error || !signedPlainTransactions) {
                throw new errors_1.ErrCouldNotSignTransactions();
            }
            if (type === enums_1.WindowProviderResponseEnums.cancelResponse) {
                throw new errors_1.ErrTransactionCancelled();
            }
            const hasTransactions = (signedPlainTransactions === null || signedPlainTransactions === void 0 ? void 0 : signedPlainTransactions.length) > 0;
            if (!hasTransactions) {
                throw new errors_1.ErrCouldNotGuardTransactions();
            }
            return signedPlainTransactions.map((tx) => sdk_core_1.Transaction.newFromPlainObject(tx));
        });
    }
    signMessage(messageToSign) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.ensureConnected();
            const { payload: { data, error } } = yield this.windowManager.postMessage({
                type: enums_1.WindowProviderRequestEnums.signMessageRequest,
                payload: {
                    message: Buffer.from(messageToSign.data).toString()
                }
            });
            if (error || !data) {
                throw new errors_1.ErrCouldNotSignMessage();
            }
            const { status, signature } = data;
            if (status !== enums_1.SignMessageStatusEnum.signed) {
                throw new errors_1.ErrCouldNotSignMessage();
            }
            return new sdk_core_1.Message({
                data: Buffer.from(messageToSign.data),
                address: (_a = messageToSign.address) !== null && _a !== void 0 ? _a : sdk_core_1.Address.newFromBech32(this.account.address),
                signer: messageToSign.signer || 'wallet-cross-window',
                version: messageToSign.version,
                signature: Buffer.from(String(signature), 'hex')
            });
        });
    }
    cancelAction() {
        var _a, _b;
        const isWalletOpened = (_a = this.windowManager) === null || _a === void 0 ? void 0 : _a.isWalletOpened(enums_1.WindowProviderRequestEnums.cancelAction);
        if (!isWalletOpened) {
            return;
        }
        return (_b = this.windowManager) === null || _b === void 0 ? void 0 : _b.postMessage({
            type: enums_1.WindowProviderRequestEnums.cancelAction,
            payload: undefined
        });
    }
}
CrossWindowProvider._instance = null;
exports.CrossWindowProvider = CrossWindowProvider;
//# sourceMappingURL=CrossWindowProvider.js.map