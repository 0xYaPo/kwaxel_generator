"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DelegationTransactionsFactory = void 0;
const abi_1 = require("../abi");
const address_1 = require("../core/address");
const baseFactory_1 = require("../core/baseFactory");
const constants_1 = require("../core/constants");
const errors_1 = require("../core/errors");
const transaction_1 = require("../core/transaction");
/**
 * Use this class to create delegation related transactions like creating a new delegation contract or adding nodes.
 */
class DelegationTransactionsFactory extends baseFactory_1.BaseFactory {
    constructor(options) {
        super({ config: options.config, gasLimitEstimator: options.gasLimitEstimator });
        this.config = options.config;
        this.argSerializer = new abi_1.ArgSerializer();
        this.delegationManagerAddress = address_1.Address.newFromHex(constants_1.DELEGATION_MANAGER_SC_ADDRESS_HEX, this.config.addressHrp);
    }
    async createTransactionForNewDelegationContract(sender, options) {
        const dataParts = [
            "createNewDelegationContract",
            ...this.argSerializer.valuesToStrings([
                new abi_1.BigUIntValue(options.totalDelegationCap),
                new abi_1.BigUIntValue(options.serviceFee),
            ]),
        ];
        const executionGasLimit = this.config.gasLimitCreateDelegationContract + this.config.additionalGasLimitForDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: this.delegationManagerAddress,
            chainID: this.config.chainID,
            gasLimit: 0n,
            value: options.amount,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, executionGasLimit);
        return transaction;
    }
    async createTransactionForAddingNodes(sender, options) {
        if (options.publicKeys.length !== options.signedMessages.length) {
            throw new errors_1.Err("The number of public keys should match the number of signed messages");
        }
        const signedMessagesAsTypedValues = options.signedMessages.map((message) => new abi_1.BytesValue(Buffer.from(message)));
        const messagesAsStrings = this.argSerializer.valuesToStrings(signedMessagesAsTypedValues);
        const numNodes = options.publicKeys.length;
        const dataParts = ["addNodes"];
        for (let i = 0; i < numNodes; i++) {
            dataParts.push(...[options.publicKeys[i].hex(), messagesAsStrings[i]]);
        }
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        const executionGasLimit = this.computeExecutionGasLimitForNodesManagement(numNodes);
        await this.setGasLimit(transaction, undefined, executionGasLimit);
        return transaction;
    }
    async createTransactionForRemovingNodes(sender, options) {
        const dataParts = ["removeNodes"];
        for (const key of options.publicKeys) {
            dataParts.push(key.hex());
        }
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        const numNodes = options.publicKeys.length;
        const executionGasLimit = this.computeExecutionGasLimitForNodesManagement(numNodes);
        await this.setGasLimit(transaction, undefined, executionGasLimit);
        return transaction;
    }
    async createTransactionForStakingNodes(sender, options) {
        let dataParts = ["stakeNodes"];
        for (const key of options.publicKeys) {
            dataParts = dataParts.concat(key.hex());
        }
        const numNodes = options.publicKeys.length;
        const additionalGasForAllNodes = BigInt(numNodes) * this.config.additionalGasLimitPerValidatorNode;
        const executionGasLimit = additionalGasForAllNodes + this.config.gasLimitStake + this.config.gasLimitDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, executionGasLimit);
        return transaction;
    }
    async createTransactionForUnbondingNodes(sender, options) {
        let dataParts = ["unBondNodes"];
        for (const key of options.publicKeys) {
            dataParts = dataParts.concat(key.hex());
        }
        const numNodes = options.publicKeys.length;
        const executionGasLimit = BigInt(numNodes) * this.config.additionalGasLimitPerValidatorNode +
            this.config.gasLimitUnbond +
            this.config.gasLimitDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, executionGasLimit);
        return transaction;
    }
    async createTransactionForUnstakingNodes(sender, options) {
        let dataParts = ["unStakeNodes"];
        for (const key of options.publicKeys) {
            dataParts = dataParts.concat(key.hex());
        }
        const numNodes = options.publicKeys.length;
        const executionGasLimit = BigInt(numNodes) * this.config.additionalGasLimitPerValidatorNode +
            this.config.gasLimitUnstake +
            this.config.gasLimitDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, executionGasLimit);
        return transaction;
    }
    async createTransactionForUnjailingNodes(sender, options) {
        const dataParts = ["unJailNodes"];
        for (const key of options.publicKeys) {
            dataParts.push(key.hex());
        }
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
            value: options.amount,
        });
        this.setTransactionPayload(transaction, dataParts);
        const numNodes = options.publicKeys.length;
        const executionGasLimit = this.computeExecutionGasLimitForNodesManagement(numNodes);
        await this.setGasLimit(transaction, undefined, executionGasLimit);
        return transaction;
    }
    async createTransactionForChangingServiceFee(sender, options) {
        const dataParts = [
            "changeServiceFee",
            this.argSerializer.valuesToStrings([new abi_1.BigUIntValue(options.serviceFee)])[0],
        ];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, gasLimit);
        return transaction;
    }
    async createTransactionForModifyingDelegationCap(sender, options) {
        const dataParts = [
            "modifyTotalDelegationCap",
            this.argSerializer.valuesToStrings([new abi_1.BigUIntValue(options.delegationCap)])[0],
        ];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, gasLimit);
        return transaction;
    }
    async createTransactionForSettingAutomaticActivation(sender, options) {
        const dataParts = ["setAutomaticActivation", this.argSerializer.valuesToStrings([new abi_1.StringValue("true")])[0]];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, gasLimit);
        return transaction;
    }
    async createTransactionForUnsettingAutomaticActivation(sender, options) {
        const dataParts = ["setAutomaticActivation", this.argSerializer.valuesToStrings([new abi_1.StringValue("false")])[0]];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, gasLimit);
        return transaction;
    }
    async createTransactionForSettingCapCheckOnRedelegateRewards(sender, options) {
        const dataParts = [
            "setCheckCapOnReDelegateRewards",
            this.argSerializer.valuesToStrings([new abi_1.StringValue("true")])[0],
        ];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, gasLimit);
        return transaction;
    }
    async createTransactionForUnsettingCapCheckOnRedelegateRewards(sender, options) {
        const dataParts = [
            "setCheckCapOnReDelegateRewards",
            this.argSerializer.valuesToStrings([new abi_1.StringValue("false")])[0],
        ];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, gasLimit);
        return transaction;
    }
    async createTransactionForSettingMetadata(sender, options) {
        const dataParts = [
            "setMetaData",
            ...this.argSerializer.valuesToStrings([
                new abi_1.StringValue(options.name),
                new abi_1.StringValue(options.website),
                new abi_1.StringValue(options.identifier),
            ]),
        ];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, gasLimit);
        return transaction;
    }
    async createTransactionForDelegating(sender, options) {
        const dataParts = ["delegate"];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
            value: options.amount,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, gasLimit);
        return transaction;
    }
    async createTransactionForClaimingRewards(sender, options) {
        const dataParts = ["claimRewards"];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, gasLimit);
        return transaction;
    }
    async createTransactionForRedelegatingRewards(sender, options) {
        const dataParts = ["reDelegateRewards"];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, gasLimit);
        return transaction;
    }
    async createTransactionForUndelegating(sender, options) {
        const dataParts = ["unDelegate", this.argSerializer.valuesToStrings([new abi_1.BigUIntValue(options.amount)])[0]];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, gasLimit);
        return transaction;
    }
    async createTransactionForWithdrawing(sender, options) {
        const dataParts = ["withdraw"];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: options.delegationContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, gasLimit);
        return transaction;
    }
    computeExecutionGasLimitForNodesManagement(numNodes) {
        const additionalGasForAllNodes = this.config.additionalGasLimitPerValidatorNode * BigInt(numNodes);
        return this.config.gasLimitDelegationOperations + additionalGasForAllNodes;
    }
}
exports.DelegationTransactionsFactory = DelegationTransactionsFactory;
//# sourceMappingURL=delegationTransactionsFactory.js.map