import { IGasLimitEstimator } from "../core";
import { Address } from "../core/address";
import { BaseFactory } from "../core/baseFactory";
import { Transaction } from "../core/transaction";
import * as resources from "./resources";
interface IConfig {
    chainID: string;
    addressHrp: string;
    minGasLimit: bigint;
    gasLimitPerByte: bigint;
    gasLimitIssue: bigint;
    gasLimitToggleBurnRoleGlobally: bigint;
    gasLimitEsdtLocalMint: bigint;
    gasLimitEsdtLocalBurn: bigint;
    gasLimitSetSpecialRole: bigint;
    gasLimitPausing: bigint;
    gasLimitFreezing: bigint;
    gasLimitWiping: bigint;
    gasLimitEsdtNftCreate: bigint;
    gasLimitEsdtNftUpdateAttributes: bigint;
    gasLimitEsdtNftAddQuantity: bigint;
    gasLimitEsdtNftBurn: bigint;
    gasLimitStorePerByte: bigint;
    gasLimitEsdtModifyRoyalties: bigint;
    gasLimitEsdtModifyCreator: bigint;
    gasLimitEsdtMetadataUpdate: bigint;
    gasLimitSetNewUris: bigint;
    gasLimitNftMetadataRecreate: bigint;
    gasLimitNftChangeToDynamic: bigint;
    gasLimitUpdateTokenId: bigint;
    gasLimitRegisterDynamic: bigint;
    issueCost: bigint;
}
/**
 * Use this class to create token management transactions like issuing ESDTs, creating NFTs, setting roles, etc.
 */
export declare class TokenManagementTransactionsFactory extends BaseFactory {
    private readonly config;
    private readonly argSerializer;
    private readonly trueAsString;
    private readonly falseAsString;
    private readonly esdtContractAddress;
    constructor(options: {
        config: IConfig;
        gasLimitEstimator?: IGasLimitEstimator;
    });
    createTransactionForIssuingFungible(sender: Address, options: resources.IssueFungibleInput): Promise<Transaction>;
    createTransactionForIssuingSemiFungible(sender: Address, options: resources.IssueSemiFungibleInput): Promise<Transaction>;
    createTransactionForIssuingNonFungible(sender: Address, options: resources.IssueNonFungibleInput): Promise<Transaction>;
    createTransactionForRegisteringMetaESDT(sender: Address, options: resources.RegisterMetaESDTInput): Promise<Transaction>;
    createTransactionForRegisteringAndSettingRoles(sender: Address, options: resources.RegisterRolesInput): Promise<Transaction>;
    createTransactionForSettingBurnRoleGlobally(sender: Address, options: resources.BurnRoleGloballyInput): Promise<Transaction>;
    createTransactionForUnsettingBurnRoleGlobally(sender: Address, options: resources.BurnRoleGloballyInput): Promise<Transaction>;
    createTransactionForSettingSpecialRoleOnFungibleToken(sender: Address, options: resources.FungibleSpecialRoleInput): Promise<Transaction>;
    createTransactionForUnsettingSpecialRoleOnFungibleToken(sender: Address, options: resources.UnsetFungibleSpecialRoleInput): Promise<Transaction>;
    createTransactionForSettingSpecialRoleOnSemiFungibleToken(sender: Address, options: resources.SemiFungibleSpecialRoleInput): Promise<Transaction>;
    createTransactionForUnsettingSpecialRoleOnSemiFungibleToken(sender: Address, options: resources.UnsetSemiFungibleSpecialRoleInput): Promise<Transaction>;
    createTransactionForSettingSpecialRoleOnMetaESDT(sender: Address, options: resources.SemiFungibleSpecialRoleInput): Promise<Transaction>;
    createTransactionForUnsettingSpecialRoleOnMetaESDT(sender: Address, options: resources.UnsetSemiFungibleSpecialRoleInput): Promise<Transaction>;
    createTransactionForSettingSpecialRoleOnNonFungibleToken(sender: Address, options: resources.SpecialRoleInput): Promise<Transaction>;
    createTransactionForUnsettingSpecialRoleOnNonFungibleToken(sender: Address, options: resources.UnsetSpecialRoleInput): Promise<Transaction>;
    createTransactionForCreatingNFT(sender: Address, options: resources.MintInput): Promise<Transaction>;
    createTransactionForPausing(sender: Address, options: resources.PausingInput): Promise<Transaction>;
    createTransactionForUnpausing(sender: Address, options: resources.PausingInput): Promise<Transaction>;
    createTransactionForFreezing(sender: Address, options: resources.ManagementInput): Promise<Transaction>;
    createTransactionForUnfreezing(sender: Address, options: resources.ManagementInput): Promise<Transaction>;
    createTransactionForWiping(sender: Address, options: resources.ManagementInput): Promise<Transaction>;
    createTransactionForLocalMint(sender: Address, options: resources.LocalMintInput): Promise<Transaction>;
    createTransactionForLocalBurning(sender: Address, options: resources.LocalBurnInput): Promise<Transaction>;
    createTransactionForUpdatingAttributes(sender: Address, options: resources.UpdateAttributesInput): Promise<Transaction>;
    createTransactionForAddingQuantity(sender: Address, options: resources.UpdateQuantityInput): Promise<Transaction>;
    createTransactionForBurningQuantity(sender: Address, options: resources.UpdateQuantityInput): Promise<Transaction>;
    createTransactionForModifyingRoyalties(sender: Address, options: resources.ModifyRoyaltiesInput): Promise<Transaction>;
    createTransactionForSettingNewUris(sender: Address, options: resources.SetNewUriInput): Promise<Transaction>;
    createTransactionForModifyingCreator(sender: Address, options: resources.ModifyCreatorInput): Promise<Transaction>;
    createTransactionForUpdatingMetadata(sender: Address, options: resources.ManageMetadataInput): Promise<Transaction>;
    createTransactionForMetadataRecreate(sender: Address, options: resources.ManageMetadataInput): Promise<Transaction>;
    createTransactionForChangingTokenToDynamic(sender: Address, options: resources.ChangeTokenToDynamicInput): Promise<Transaction>;
    createTransactionForUpdatingTokenId(sender: Address, options: resources.UpdateTokenIDInput): Promise<Transaction>;
    createTransactionForRegisteringDynamicToken(sender: Address, options: resources.RegisteringDynamicTokenInput): Promise<Transaction>;
    createTransactionForRegisteringDynamicAndSettingRoles(sender: Address, options: resources.RegisteringDynamicTokenInput): Promise<Transaction>;
    private notifyAboutUnsettingBurnRoleGlobally;
    private boolToString;
}
export {};
