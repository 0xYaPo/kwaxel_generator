"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountTransactionsFactory = void 0;
const baseFactory_1 = require("../core/baseFactory");
const constants_1 = require("../core/constants");
const transaction_1 = require("../core/transaction");
class AccountTransactionsFactory extends baseFactory_1.BaseFactory {
    constructor(options) {
        super({ config: options.config, gasLimitEstimator: options.gasLimitEstimator });
        this.config = options.config;
    }
    async createTransactionForSavingKeyValue(sender, options) {
        const functionName = "SaveKeyValue";
        const keyValueParts = this.computeDataPartsForSavingKeyValue(options.keyValuePairs);
        const dataParts = [functionName, ...keyValueParts];
        const extraGas = this.computeExtraGasForSavingKeyValue(options.keyValuePairs);
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: sender,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, extraGas);
        return transaction;
    }
    computeExtraGasForSavingKeyValue(keyValuePairs) {
        let extraGas = 0n;
        keyValuePairs.forEach((value, key) => {
            extraGas +=
                this.config.gasLimitPersistPerByte * BigInt(key.length + value.length) +
                    this.config.gasLimitStorePerByte * BigInt(value.length);
        });
        return extraGas + this.config.gasLimitSaveKeyValue;
    }
    computeDataPartsForSavingKeyValue(keyValuePairs) {
        const dataParts = [];
        keyValuePairs.forEach((value, key) => {
            dataParts.push(...[Buffer.from(key).toString("hex"), Buffer.from(value).toString("hex")]);
        });
        return dataParts;
    }
    async createTransactionForSettingGuardian(sender, options) {
        const dataParts = [
            "SetGuardian",
            options.guardianAddress.toHex(),
            Buffer.from(options.serviceID).toString("hex"),
        ];
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: sender,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitSetGuardian);
        return transaction;
    }
    async createTransactionForGuardingAccount(sender) {
        const dataParts = ["GuardAccount"];
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: sender,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitGuardAccount);
        return transaction;
    }
    async createTransactionForUnguardingAccount(sender, options) {
        const dataParts = ["UnGuardAccount"];
        const transaction = new transaction_1.Transaction({
            sender,
            receiver: sender,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        if (options.guardian) {
            transaction.guardian = options.guardian;
            transaction.options = constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
        }
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitUnguardAccount);
        return transaction;
    }
}
exports.AccountTransactionsFactory = AccountTransactionsFactory;
//# sourceMappingURL=accountTransactionsFactory.js.map