"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GovernanceTransactionsFactory = void 0;
const abi_1 = require("../abi");
const core_1 = require("../core");
const baseFactory_1 = require("../core/baseFactory");
const constants_1 = require("../core/constants");
const EXTRA_GAS_LIMIT_FOR_VOTING = 100000n;
class GovernanceTransactionsFactory extends baseFactory_1.BaseFactory {
    constructor(options) {
        super({ config: options.config, gasLimitEstimator: options.gasLimitEstimator });
        this.config = options.config;
        this.argSerializer = new abi_1.ArgSerializer();
        this.governanceContract = core_1.Address.newFromHex(constants_1.GOVERNANCE_CONTRACT_ADDRESS_HEX, this.config.addressHrp);
    }
    async createTransactionForNewProposal(sender, options) {
        const args = [
            new abi_1.StringValue(options.commitHash),
            new abi_1.BigUIntValue(options.startVoteEpoch),
            new abi_1.BigUIntValue(options.endVoteEpoch),
        ];
        const dataParts = ["proposal", ...this.argSerializer.valuesToStrings(args)];
        const transaction = new core_1.Transaction({
            sender,
            receiver: this.governanceContract,
            value: options.nativeTokenAmount,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForProposal);
        return transaction;
    }
    async createTransactionForVoting(sender, options) {
        const args = [new abi_1.BigUIntValue(options.proposalNonce), new abi_1.StringValue(options.vote.valueOf())];
        const dataParts = ["vote", ...this.argSerializer.valuesToStrings(args)];
        const transaction = new core_1.Transaction({
            sender,
            receiver: this.governanceContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForVote + EXTRA_GAS_LIMIT_FOR_VOTING);
        return transaction;
    }
    async createTransactionForClosingProposal(sender, options) {
        const args = [new abi_1.BigUIntValue(options.proposalNonce)];
        const dataParts = ["closeProposal", ...this.argSerializer.valuesToStrings(args)];
        const transaction = new core_1.Transaction({
            sender,
            receiver: this.governanceContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForClosingProposal);
        return transaction;
    }
    async createTransactionForClearingEndedProposals(sender, options) {
        const dataParts = ["clearEndedProposals", ...options.proposers.map((address) => address.toHex())];
        const transaction = new core_1.Transaction({
            sender,
            receiver: this.governanceContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        const gasLimit = this.config.gasLimitForClearProposals +
            BigInt(options.proposers.length) * this.config.gasLimitForClearProposals;
        await this.setGasLimit(transaction, undefined, gasLimit);
        return transaction;
    }
    async createTransactionForClaimingAccumulatedFees(sender) {
        const dataParts = ["claimAccumulatedFees"];
        const transaction = new core_1.Transaction({
            sender,
            receiver: this.governanceContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForClaimAccumulatedFees);
        return transaction;
    }
    async createTransactionForChangingConfig(sender, options) {
        const args = [
            new abi_1.StringValue(options.proposalFee.toString()),
            new abi_1.StringValue(options.lastProposalFee.toString()),
            new abi_1.StringValue(options.minQuorum.toString()),
            new abi_1.StringValue(options.minVetoThreshold.toString()),
            new abi_1.StringValue(options.minPassThreshold.toString()),
        ];
        const dataParts = ["changeConfig", ...this.argSerializer.valuesToStrings(args)];
        const transaction = new core_1.Transaction({
            sender,
            receiver: this.governanceContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, undefined, this.config.gasLimitForChangeConfig);
        return transaction;
    }
}
exports.GovernanceTransactionsFactory = GovernanceTransactionsFactory;
//# sourceMappingURL=governanceTransactionsFactory.js.map