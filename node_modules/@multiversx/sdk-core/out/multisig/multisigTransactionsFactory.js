"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigTransactionsFactory = void 0;
const abi_1 = require("../abi");
const core_1 = require("../core");
const baseFactory_1 = require("../core/baseFactory");
const transaction_1 = require("../core/transaction");
const smartContracts_1 = require("../smartContracts");
const proposeTransferExecuteContractInput_1 = require("./proposeTransferExecuteContractInput");
/**
 * Use this class to create multisig related transactions like creating a new multisig contract,
 * proposing actions, signing actions, and performing actions.
 */
class MultisigTransactionsFactory extends baseFactory_1.BaseFactory {
    constructor(options) {
        super({ config: options.config, gasLimitEstimator: options.gasLimitEstimator });
        this.config = options.config;
        this.abi = options.abi;
        this.argSerializer = new abi_1.ArgSerializer();
        this.smartContractFactory = new smartContracts_1.SmartContractTransactionsFactory(options);
    }
    /**
     * Creates a transaction to deploy a new multisig contract
     */
    async createTransactionForDeploy(sender, options) {
        const boardAddresses = options.board.map((addr) => new abi_1.AddressValue(addr));
        const args = [new abi_1.U32Value(options.quorum), abi_1.VariadicValue.fromItems(...boardAddresses)];
        return await this.smartContractFactory.createTransactionForDeploy(sender, {
            bytecode: options.bytecode,
            gasLimit: options.gasLimit,
            isUpgradeable: options.isUpgradeable,
            isReadable: options.isReadable,
            isPayable: options.isPayable,
            isPayableBySmartContract: options.isPayableBySmartContract,
            arguments: args,
        });
    }
    /**
     * Proposes adding a new board member
     */
    async createTransactionForProposeAddBoardMember(sender, options) {
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeAddBoardMember",
            gasLimit: options.gasLimit,
            arguments: [options.boardMember],
        });
    }
    /**
     * Proposes adding a new proposer
     */
    async createTransactionForProposeAddProposer(sender, options) {
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeAddProposer",
            gasLimit: options.gasLimit,
            arguments: [options.proposer],
        });
    }
    /**
     * Proposes removing a user (board member or proposer)
     */
    async createTransactionForProposeRemoveUser(sender, options) {
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeRemoveUser",
            gasLimit: options.gasLimit,
            arguments: [options.userAddress],
        });
    }
    /**
     * Proposes changing the quorum (minimum signatures required)
     */
    async createTransactionForProposeChangeQuorum(sender, options) {
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeChangeQuorum",
            gasLimit: options.gasLimit,
            arguments: [options.newQuorum],
        });
    }
    /**
     * Proposes a transaction that will transfer EGLD and/or execute a function
     */
    async createTransactionForProposeTransferExecute(sender, options) {
        const gasOption = options.optGasLimit ? new abi_1.U64Value(options.optGasLimit) : null;
        let functionCall = [];
        if (options.functionName) {
            const input = await proposeTransferExecuteContractInput_1.ProposeTransferExecuteContractInput.newFromTransferExecuteInput({
                multisig: options.multisigContract,
                to: options.to,
                functionName: options.functionName,
                arguments: options.functionArguments,
                abi: options.abi,
            });
            functionCall = input.functionCall;
        }
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeTransferExecute",
            gasLimit: options.gasLimit,
            arguments: [
                new abi_1.AddressValue(options.to),
                new abi_1.BigUIntValue(options.nativeTokenAmount),
                new abi_1.OptionValue(new abi_1.OptionType(new abi_1.U64Type()), gasOption),
                abi_1.VariadicValue.fromItems(...functionCall.map((value) => new abi_1.BytesValue(value))),
            ],
        });
    }
    /**
     * Proposes a transaction that will transfer EGLD and/or execute a function
     */
    async createTransactionForDeposit(sender, options) {
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "deposit",
            gasLimit: options.gasLimit,
            arguments: [],
            nativeTransferAmount: options.nativeTokenAmount,
            tokenTransfers: options.tokenTransfers,
        });
    }
    /**
     * Proposes a transaction that will transfer ESDT tokens and/or execute a function
     */
    async createTransactionForProposeTransferExecuteEsdt(sender, options) {
        const input = await proposeTransferExecuteContractInput_1.ProposeTransferExecuteContractInput.newFromTransferExecuteInput({
            multisig: options.multisigContract,
            to: options.to,
            functionName: options.functionName,
            arguments: options.functionArguments,
            abi: options.abi,
        });
        const tokenPayments = this.mapTokenPayments(options);
        const dataParts = [
            "proposeTransferExecuteEsdt",
            ...this.argSerializer.valuesToStrings(abi_1.NativeSerializer.nativeToTypedValues([options.to, tokenPayments, options.optGasLimit, abi_1.VariadicValue.fromItems(...input.functionCall)], this.abi.getEndpoint("proposeTransferExecuteEsdt"))),
        ];
        const transaction = new transaction_1.Transaction({
            sender: sender,
            receiver: options.multisigContract,
            chainID: this.config.chainID,
            gasLimit: 0n,
        });
        this.setTransactionPayload(transaction, dataParts);
        await this.setGasLimit(transaction, options.gasLimit);
        return transaction;
    }
    mapTokenPayments(options) {
        const tokenComputer = new core_1.TokenComputer();
        const tokens = [];
        for (const token of options.tokens) {
            tokens.push({
                token_identifier: tokenComputer.extractIdentifierFromExtendedIdentifier(token.token.identifier),
                token_nonce: token.token.nonce,
                amount: token.amount,
            });
        }
        return tokens;
    }
    /**
     * Proposes an async call to another contract
     */
    async createTransactionForProposeAsyncCall(sender, options) {
        const input = await proposeTransferExecuteContractInput_1.ProposeTransferExecuteContractInput.newFromProposeAsyncCallInput({
            multisig: options.multisigContract,
            to: options.to,
            tokenTransfers: options.tokenTransfers,
            functionName: options.functionName,
            arguments: options.functionArguments,
            abi: options.abi,
        });
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeAsyncCall",
            gasLimit: options.gasLimit,
            arguments: [
                new abi_1.AddressValue(options.to),
                new abi_1.BigUIntValue(options.nativeTransferAmount),
                new abi_1.BigUIntValue(options.optGasLimit ?? 0n),
                abi_1.VariadicValue.fromItems(...input.functionCall.map((value) => new abi_1.BytesValue(value))),
            ],
        });
    }
    /**
     * Proposes deploying a smart contract from source
     */
    async createTransactionForProposeContractDeployFromSource(sender, options) {
        let args = this.argsToTypedValues(options.arguments, options.abi?.constructorDefinition);
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeSCDeployFromSource",
            gasLimit: options.gasLimit,
            arguments: [
                new abi_1.BigUIntValue(options.amount),
                new abi_1.AddressValue(options.multisigContract),
                new abi_1.CodeMetadataValue(options.codeMetadata),
                abi_1.VariadicValue.fromItems(...args),
            ],
        });
    }
    /**
     * Proposes upgrading a smart contract from source
     */
    async createTransactionForProposeContractUpgradeFromSource(sender, options) {
        let args = this.argsToTypedValues(options.arguments, options.abi?.constructorDefinition);
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeSCUpgradeFromSource",
            gasLimit: options.gasLimit,
            arguments: [
                new abi_1.AddressValue(options.multisigContract),
                new abi_1.BigUIntValue(options.amount),
                new abi_1.AddressValue(options.source),
                new abi_1.CodeMetadataValue(options.codeMetadata),
                abi_1.VariadicValue.fromItems(...args),
            ],
        });
    }
    /**
     * Signs an action (by a board member)
     */
    async createTransactionForSignAction(sender, options) {
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "sign",
            gasLimit: options.gasLimit,
            arguments: [options.actionId],
        });
    }
    /**
     * Signs all actions in a batch
     */
    async createTransactionForSignBatch(sender, options) {
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "signBatch",
            gasLimit: options.gasLimit,
            arguments: [options.groupId],
        });
    }
    /**
     * Signs and performs an action in one transaction
     */
    async createTransactionForSignAndPerform(sender, options) {
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "signAndPerform",
            gasLimit: options.gasLimit,
            arguments: [options.actionId],
        });
    }
    /**
     * Signs and performs all actions in a batch
     */
    async createTransactionForSignBatchAndPerform(sender, options) {
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "signBatchAndPerform",
            gasLimit: options.gasLimit,
            arguments: [options.groupId],
        });
    }
    /**
     * Withdraws signature from an action
     */
    async createTransactionForUnsign(sender, options) {
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "unsign",
            gasLimit: options.gasLimit,
            arguments: [options.actionId],
        });
    }
    /**
     * Withdraws signatures from all actions in a batch
     */
    async createTransactionForUnsignBatch(sender, options) {
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "unsignBatch",
            gasLimit: options.gasLimit,
            arguments: [options.groupId],
        });
    }
    /**
     * Removes signatures from outdated board members
     */
    async createTransactionForUnsignForOutdatedBoardMembers(sender, options) {
        const outdatedBoardMembers = options.outdatedBoardMembers.map((id) => new abi_1.U32Value(id));
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "unsignForOutdatedBoardMembers",
            gasLimit: options.gasLimit,
            arguments: [new abi_1.U32Value(options.actionId), abi_1.VariadicValue.fromItems(...outdatedBoardMembers)],
        });
    }
    /**
     * Performs an action that has reached quorum
     */
    async createTransactionForPerformAction(sender, options) {
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "performAction",
            gasLimit: options.gasLimit,
            arguments: [options.actionId],
        });
    }
    /**
     * Performs all actions in a batch that have reached quorum
     */
    async createTransactionForPerformBatch(sender, options) {
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "performBatch",
            gasLimit: options.gasLimit,
            arguments: [options.groupId],
        });
    }
    /**
     * Discards an action that is no longer needed
     */
    async createTransactionForDiscardAction(sender, options) {
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "discardAction",
            gasLimit: options.gasLimit,
            arguments: [options.actionId],
        });
    }
    /**
     * Discards all actions in the provided list
     */
    async createTransactionForDiscardBatch(sender, options) {
        const actionIdsArgs = options.actionIds.map((id) => new abi_1.U32Value(id));
        return await this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "discardBatch",
            gasLimit: options.gasLimit,
            arguments: [abi_1.VariadicValue.fromItems(...actionIdsArgs)],
        });
    }
    argsToTypedValues(args, endpoint) {
        if (endpoint) {
            const typedArgs = abi_1.NativeSerializer.nativeToTypedValues(args, endpoint);
            return typedArgs;
        }
        if (this.areArgsOfTypedValue(args)) {
            return args;
        }
        throw new core_1.Err("Can't convert args to TypedValues");
    }
    areArgsOfTypedValue(args) {
        return args.every((arg) => abi_1.isTyped(arg));
    }
}
exports.MultisigTransactionsFactory = MultisigTransactionsFactory;
//# sourceMappingURL=multisigTransactionsFactory.js.map