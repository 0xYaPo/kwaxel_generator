import { Abi } from "../abi";
import { Address, BaseController, BaseControllerInput, IAccount, IGasLimitEstimator, Transaction, TransactionOnNetwork } from "../core";
import { INetworkProvider } from "../networkProviders/interface";
import { SmartContractDeployOutcome } from "../smartContracts";
import * as resources from "./resources";
export declare class MultisigController extends BaseController {
    private transactionAwaiter;
    private multisigFactory;
    private multisigParser;
    private smartContractController;
    constructor(options: {
        chainID: string;
        networkProvider: INetworkProvider;
        abi: Abi;
        gasLimitEstimator?: IGasLimitEstimator;
    });
    /**
     * Creates a transaction for deploying a new multisig contract
     */
    createTransactionForDeploy(sender: IAccount, nonce: bigint, options: resources.DeployMultisigContractInput & BaseControllerInput): Promise<Transaction>;
    parseDeploy(transactionOnNetwork: TransactionOnNetwork): SmartContractDeployOutcome;
    awaitCompletedDeploy(txHash: string): Promise<SmartContractDeployOutcome>;
    /**
     * Gets quorum for specific multisig
     */
    getQuorum(options: {
        multisigAddress: string;
    }): Promise<number>;
    /**
     * Gets number of board members for specific multisig
     */
    getNumBoardMembers(options: {
        multisigAddress: string;
    }): Promise<number>;
    /**
     * Gets number of groups for specific multisig
     */
    getNumGroups(options: {
        multisigAddress: string;
    }): Promise<number>;
    /**
     * Gets number of proposers for specific multisig
     */
    getNumProposers(options: {
        multisigAddress: string;
    }): Promise<number>;
    /**
     * Gets action group for specific multisig
     */
    getActionGroup(options: {
        multisigAddress: string;
        groupId: number;
    }): Promise<number[]>;
    /**
     * Gets last group action id specific multisig
     */
    getLastGroupActionId(options: {
        multisigAddress: string;
    }): Promise<number>;
    /**
     * Gets last action index specific multisig
     */
    getActionLastIndex(options: {
        multisigAddress: string;
    }): Promise<number>;
    /**
     * Returns `true` (`1`) if the user has signed the action.
     * Does not check whether or not the user is still a board member and the signature valid.
     */
    hasSignedAction(options: {
        multisigAddress: string;
        userAddress: string;
        actionId: number;
    }): Promise<boolean>;
    /**
     * Returns `true` (`1`) if `getActionValidSignerCount >= getQuorum`.
     */
    quorumReached(options: {
        multisigAddress: string;
        actionId: number;
    }): Promise<boolean>;
    /**
     * Lists all users that can sign actions.
     */
    getAllBoardMembers(options: {
        multisigAddress: string;
    }): Promise<string[]>;
    /**
     * Lists all proposers that are not board members.
     */
    getAllProposers(options: {
        multisigAddress: string;
    }): Promise<string[]>;
    /**
     *  "Indicates user rights.",
     * `0` = no rights,",
     * `1` = can propose, but not sign,
     * `2` = can propose and sign.
     */
    getUserRole(options: {
        multisigAddress: string;
        userAddress: string;
    }): Promise<resources.UserRoleEnum>;
    /**
     * Serialized action data of an action with index.
     */
    getActionData(options: {
        multisigAddress: string;
        actionId: number;
    }): Promise<resources.MultisigAction>;
    /**
     * Gets all pending actions.
     */
    getPendingActionFullInfo(options: {
        multisigAddress: string;
    }): Promise<resources.FullMultisigAction[]>;
    /**
     * Gets addresses of all users who signed an action.
     * Does not check if those users are still board members or not, so the result may contain invalid signers.
     */
    getActionSigners(options: {
        multisigAddress: string;
        actionId: number;
    }): Promise<string[]>;
    /**
     * Gets addresses of all users who signed an action and are still board members.
     * All these signatures are currently valid.
     */
    getActionSignerCount(options: {
        multisigAddress: string;
        actionId: number;
    }): Promise<number>;
    /**
     * Gets addresses of all users who signed an action and are still board members.
     * All these signatures are currently valid.
     */
    getActionValidSignerCount(options: {
        multisigAddress: string;
        actionId: number;
    }): Promise<number>;
    /**
     * Creates a transaction for proposing to add a board member
     */
    createTransactionForProposeAddBoardMember(sender: IAccount, nonce: bigint, options: resources.ProposeAddBoardMemberInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for proposing to add a proposer
     */
    createTransactionForProposeAddProposer(sender: IAccount, nonce: bigint, options: resources.ProposeAddProposerInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for proposing to remove a user
     */
    createTransactionForProposeRemoveUser(sender: IAccount, nonce: bigint, options: resources.ProposeRemoveUserInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for proposing to change quorum
     */
    createTransactionForProposeChangeQuorum(sender: IAccount, nonce: bigint, options: resources.ProposeChangeQuorumInput & BaseControllerInput): Promise<Transaction>;
    parseProposeAction(transaction: TransactionOnNetwork): number;
    awaitCompletedProposeAction(txHash: string): Promise<number>;
    /**
     * Creates a transaction for signing an action
     */
    createTransactionForSignAction(sender: IAccount, nonce: bigint, options: resources.ActionInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for performing an action
     */
    createTransactionForPerformAction(sender: IAccount, nonce: bigint, options: resources.ActionInput & BaseControllerInput): Promise<Transaction>;
    parsePerformAction(transaction: TransactionOnNetwork): Address | undefined;
    awaitCompletedPerformAction(txHash: string): Promise<Address | undefined>;
    /**
     * Creates a transaction for unsigning an action
     */
    createTransactionForUnsignAction(sender: IAccount, nonce: bigint, options: resources.ActionInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for discarding an action
     */
    createTransactionForDiscardAction(sender: IAccount, nonce: bigint, options: resources.ActionInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for deposit native token or tokens
     */
    createTransactionForDeposit(sender: IAccount, nonce: bigint, options: resources.DepositExecuteInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for proposing to transfer EGLD and execute a smart contract call
     */
    createTransactionForProposeTransferExecute(sender: IAccount, nonce: bigint, options: resources.ProposeTransferExecuteInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for proposing to transfer ESDT tokens and execute a smart contract call
     */
    createTransactionForProposeTransferExecuteEsdt(sender: IAccount, nonce: bigint, options: resources.ProposeTransferExecuteEsdtInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for proposing an async call to another contract
     */
    createTransactionForProposeAsyncCall(sender: IAccount, nonce: bigint, options: resources.ProposeAsyncCallInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for proposing to deploy a smart contract from source
     */
    createTransactionForProposeContractDeployFromSource(sender: IAccount, nonce: bigint, options: resources.ProposeContractDeployFromSourceInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for proposing to upgrade a smart contract from source
     */
    createTransactionForProposeContractUpgradeFromSource(sender: IAccount, nonce: bigint, options: resources.ProposeContractUpgradeFromSourceInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for signing a batch of actions
     */
    createTransactionForSignBatch(sender: IAccount, nonce: bigint, options: resources.GroupInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for signing and performing an action in one step
     */
    createTransactionForSignAndPerform(sender: IAccount, nonce: bigint, options: resources.ActionInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for unsigning for outdated board members
     */
    createTransactionForUnsignForOutdatedBoardMembers(sender: IAccount, nonce: bigint, options: resources.UnsignForOutdatedBoardMembersInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for performing a batch of actions
     */
    createTransactionForPerformBatch(sender: IAccount, nonce: bigint, options: resources.GroupInput & BaseControllerInput): Promise<Transaction>;
    /**
     * Creates a transaction for discarding a batch of actions
     */
    createTransactionForDiscardBatch(sender: IAccount, nonce: bigint, options: resources.DiscardBatchInput & BaseControllerInput): Promise<Transaction>;
    private mapResponseToAction;
}
