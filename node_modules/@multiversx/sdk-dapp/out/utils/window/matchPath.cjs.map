{
  "version": 3,
  "sources": ["../../../src/utils/window/matchPath.ts"],
  "sourcesContent": ["// credits go to: https://remix.run\n// sourcecode: https://raw.githubusercontent.com/remix-run/react-router/6b44e99f0b659428ce2ec8d5098e90c7fddda2c5/packages/react-router/lib/router.ts\n\nfunction warning(cond: any, message: string): void {\n  if (!cond) {\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty, @typescript-eslint/no-unused-vars\n    } catch (error) {}\n  }\n}\n\ntype ParamParseFailed = { failed: true };\n\ntype ParamParseSegment<Segment extends string> =\n  // Check here if there exists a forward slash in the string.\n\n  Segment extends `${infer LeftSegment}/${infer RightSegment}`\n    ? // If there is a forward slash, then attempt to parse each side of the\n      // forward slash.\n      ParamParseSegment<LeftSegment> extends infer LeftResult\n      ? ParamParseSegment<RightSegment> extends infer RightResult\n        ? LeftResult extends string\n          ? // If the left side is successfully parsed as a param, then check if\n            // the right side can be successfully parsed as well. If both sides\n            // can be parsed, then the result is a union of the two sides\n            // (read: \"foo\" | \"bar\").\n            RightResult extends string\n            ? LeftResult | RightResult\n            : LeftResult\n          : // If the left side is not successfully parsed as a param, then check\n            // if only the right side can be successfully parse as a param. If it\n            // can, then the result is just right, else it's a failure.\n            RightResult extends string\n            ? RightResult\n            : ParamParseFailed\n        : ParamParseFailed\n      : // If the left side didn't parse into a param, then just check the right\n        // side.\n        ParamParseSegment<RightSegment> extends infer RightResult\n        ? RightResult extends string\n          ? RightResult\n          : ParamParseFailed\n        : ParamParseFailed\n    : // If there's no forward slash, then check if this segment starts with a\n      // colon. If it does, then this is a dynamic segment, so the result is\n      // just the remainder of the string. Otherwise, it's a failure.\n      Segment extends `:${infer Remaining}`\n      ? Remaining\n      : ParamParseFailed;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\ntype ParamParseKey<Segment extends string> =\n  ParamParseSegment<Segment> extends string\n    ? ParamParseSegment<Segment>\n    : string;\n\n/**\n * The parameters that were parsed from the URL path.\n */\ntype Params<Key extends string = string> = {\n  readonly [_key in Key]: string | undefined;\n};\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\ninterface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\ninterface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/match-path\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === 'string') {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  const [matcher, paramNames] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  const match = pathname.match(matcher);\n  if (!match) {\n    return null;\n  }\n\n  const matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, '$1');\n  const captureGroups = match.slice(1);\n  const params: Params = paramNames.reduce<Mutable<Params>>(\n    (memo, paramName, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === '*') {\n        const splatValue = captureGroups[index] || '';\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, '$1');\n      }\n\n      memo[paramName] = safelyDecodeURIComponent(\n        captureGroups[index] || '',\n        paramName\n      );\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, string[]] {\n  warning(\n    path === '*' || !path.endsWith('*') || path.endsWith('/*'),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, '/*')}\" because the \\`*\\` character must ` +\n      'always follow a `/` in the pattern. To get rid of this warning, ' +\n      `please change the route path to \"${path.replace(/\\*$/, '/*')}\".`\n  );\n\n  const paramNames: string[] = [];\n  let regexpSource =\n    '^' +\n    path\n      .replace(/\\/*\\*?$/, '') // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, '/') // Make sure it has a leading /\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, '\\\\$&') // Escape special regex chars\n      .replace(/:(\\w+)/g, (_: string, paramName: string) => {\n        paramNames.push(paramName);\n        return '([^\\\\/]+)';\n      });\n\n  if (path.endsWith('*')) {\n    paramNames.push('*');\n    regexpSource +=\n      path === '*' || path === '/*'\n        ? '(.*)$' // Already matched the initial /, just match the rest\n        : '(?:\\\\/(.+)|\\\\/*)$'; // Don't include the / in params[\"*\"]\n  } else {\n    regexpSource += end\n      ? '\\\\/*$' // When matching to the end, ignore trailing slashes\n      : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts\n        // parent routes to matching only their own words and nothing more, e.g. parent\n        // route \"/home\" should not match \"/home2\".\n        // Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,\n        // but do not consume the character in the matched path so they can match against\n        // nested paths.\n        '(?:(?=[.~-]|%[0-9A-F]{2})|\\\\b|\\\\/|$)';\n  }\n\n  const matcher = new RegExp(regexpSource, caseSensitive ? undefined : 'i');\n\n  return [matcher, paramNames];\n}\n\nfunction safelyDecodeURIComponent(value: string, paramName: string) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,SAAS,QAAQ,MAAW,SAAuB;AACjD,MAAI,CAAC,MAAM;AACT,QAAI,OAAO,YAAY,aAAa;AAClC,cAAQ,KAAK,OAAO;AAAA,IACtB;AAEA,QAAI;AAMF,YAAM,IAAI,MAAM,OAAO;AAAA,IAEzB,SAAS,OAAO;AAAA,IAAC;AAAA,EACnB;AACF;AA6GO,SAAS,UAId,SACA,UAC4B;AAC5B,MAAI,OAAO,YAAY,UAAU;AAC/B,cAAU,EAAE,MAAM,SAAS,eAAe,OAAO,KAAK,KAAK;AAAA,EAC7D;AAEA,QAAM,CAAC,SAAS,UAAU,IAAI;AAAA,IAC5B,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,QAAQ;AAAA,EACV;AAEA,QAAM,QAAQ,SAAS,MAAM,OAAO;AACpC,MAAI,CAAC,OAAO;AACV,WAAO;AAAA,EACT;AAEA,QAAM,kBAAkB,MAAM,CAAC;AAC/B,MAAI,eAAe,gBAAgB,QAAQ,WAAW,IAAI;AAC1D,QAAM,gBAAgB,MAAM,MAAM,CAAC;AACnC,QAAM,SAAiB,WAAW;AAAA,IAChC,CAAC,MAAM,WAAW,UAAU;AAG1B,UAAI,cAAc,KAAK;AACrB,cAAM,aAAa,cAAc,KAAK,KAAK;AAC3C,uBAAe,gBACZ,MAAM,GAAG,gBAAgB,SAAS,WAAW,MAAM,EACnD,QAAQ,WAAW,IAAI;AAAA,MAC5B;AAEA,WAAK,SAAS,IAAI;AAAA,QAChB,cAAc,KAAK,KAAK;AAAA,QACxB;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,IACA,CAAC;AAAA,EACH;AAEA,SAAO;AAAA,IACL;AAAA,IACA,UAAU;AAAA,IACV;AAAA,IACA;AAAA,EACF;AACF;AAEA,SAAS,YACP,MACA,gBAAgB,OAChB,MAAM,MACc;AACpB;AAAA,IACE,SAAS,OAAO,CAAC,KAAK,SAAS,GAAG,KAAK,KAAK,SAAS,IAAI;AAAA,IACzD,eAAe,IAAI,oCACb,KAAK,QAAQ,OAAO,IAAI,CAAC,yIAEO,KAAK,QAAQ,OAAO,IAAI,CAAC;AAAA,EACjE;AAEA,QAAM,aAAuB,CAAC;AAC9B,MAAI,eACF,MACA,KACG,QAAQ,WAAW,EAAE,EACrB,QAAQ,QAAQ,GAAG,EACnB,QAAQ,uBAAuB,MAAM,EACrC,QAAQ,WAAW,CAAC,GAAW,cAAsB;AACpD,eAAW,KAAK,SAAS;AACzB,WAAO;AAAA,EACT,CAAC;AAEL,MAAI,KAAK,SAAS,GAAG,GAAG;AACtB,eAAW,KAAK,GAAG;AACnB,oBACE,SAAS,OAAO,SAAS,OACrB,UACA;AAAA,EACR,OAAO;AACL,oBAAgB,MACZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOA;AAAA;AAAA,EACN;AAEA,QAAM,UAAU,IAAI,OAAO,cAAc,gBAAgB,SAAY,GAAG;AAExE,SAAO,CAAC,SAAS,UAAU;AAC7B;AAEA,SAAS,yBAAyB,OAAe,WAAmB;AAClE,MAAI;AACF,WAAO,mBAAmB,KAAK;AAAA,EACjC,SAAS,OAAO;AACd;AAAA,MACE;AAAA,MACA,gCAAgC,SAAS,6CACvB,KAAK,iFACc,KAAK;AAAA,IAC5C;AAEA,WAAO;AAAA,EACT;AACF;",
  "names": []
}
