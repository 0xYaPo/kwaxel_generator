"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getTokenFromData_exports = {};
__export(getTokenFromData_exports, {
  decodeData: () => decodeData,
  getTokenFromData: () => getTokenFromData
});
module.exports = __toCommonJS(getTokenFromData_exports);
var import_sdk_core = require("@multiversx/sdk-core");
var import_bignumber = __toESM(require("bignumber.js"));
var import_enums = require("../../../../types/enums.types");
var import_decodePart = require("../../../../utils/decoders/decodePart");
var import_addressIsValid = require("../../../../utils/validation/addressIsValid");
const noData = {
  tokenId: "",
  amount: ""
};
const decodeData = (data) => {
  const nonceIndex = 2;
  const amountIndex = 3;
  const parts = data.split("@");
  const decodedParts = parts.map(
    (part, i) => [nonceIndex, amountIndex].includes(i) ? part : (0, import_decodePart.decodePart)(part)
  );
  return decodedParts;
};
function getTokenFromData(data) {
  if (!data) {
    return noData;
  }
  const isTokenTransfer = data.startsWith(import_enums.TransactionTypesEnum.ESDTTransfer);
  const isNftTransfer = data.startsWith(import_enums.TransactionTypesEnum.ESDTNFTTransfer) && data.includes("@");
  const isNftBurn = data.startsWith(import_enums.TransactionTypesEnum.ESDTNFTBurn) && data.includes("@");
  try {
    if (isTokenTransfer) {
      const [, encodedToken, encodedAmount] = data.split("@");
      const tokenId = Buffer.from(encodedToken, "hex").toString("ascii");
      if (!tokenId) {
        return noData;
      }
      const amount = new import_bignumber.default(
        "0x" + encodedAmount.replace("0x", "")
      ).toString(10);
      return {
        tokenId,
        amount
      };
    }
    const decodedData = decodeData(data);
    if (isNftTransfer) {
      const [
        ,
        /*ESDTNFTTransfer*/
        collection,
        nonce,
        quantity,
        receiver
      ] = decodedData;
      if ([collection, nonce, quantity, receiver].every((el) => Boolean(el)) && (0, import_addressIsValid.addressIsValid)(new import_sdk_core.Address(receiver).toBech32())) {
        return {
          tokenId: `${collection}-${nonce}`,
          amount: new import_bignumber.default(quantity, 16).toString(10),
          collection,
          nonce,
          receiver: new import_sdk_core.Address(receiver).toBech32()
        };
      }
    }
    if (isNftBurn) {
      const [
        ,
        /*ESDTNFTBurn*/
        collection,
        nonce,
        quantity
      ] = decodedData;
      if ([collection, nonce, quantity].every((el) => Boolean(el))) {
        return {
          tokenId: `${collection}-${nonce}`,
          amount: new import_bignumber.default(quantity, 16).toString(10),
          collection,
          nonce
        };
      }
    }
  } catch {
    return noData;
  }
  return noData;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  decodeData,
  getTokenFromData
});
//# sourceMappingURL=getTokenFromData.cjs.map
