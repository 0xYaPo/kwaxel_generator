"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var initializeWebsocketConnection_exports = {};
__export(initializeWebsocketConnection_exports, {
  initializeWebsocketConnection: () => initializeWebsocketConnection
});
module.exports = __toCommonJS(initializeWebsocketConnection_exports);
var import_socket = require("socket.io-client");
var import_websocket = require("../../../apiCalls/websocket");
var import_websocket2 = require("../../../constants/websocket.constants");
var import_accountActions = require("../../../store/actions/account/accountActions");
var import_configActions = require("../../../store/actions/config/configActions");
var import_selectors = require("../../../store/selectors");
var import_store = require("../../../store/store");
var import_retryMultipleTimes = require("../../../utils/retryMultipleTimes");
const TIMEOUT = 3e3;
const RECONNECTION_ATTEMPTS = 3;
const RETRY_INTERVAL = 500;
const MESSAGE_DELAY = 1e3;
const SOCKET_CONNECTION_DELAY = 1e3;
const BATCH_UPDATED_EVENT = "batchUpdated";
const CONNECT = "connect";
const CONNECT_ERROR = "connect_error";
const DISCONNECT = "disconnect";
async function initializeWebsocketConnection(address) {
  const { apiAddress, websocketUrl: customWebsocketUrl } = (0, import_selectors.networkSelector)(
    (0, import_store.getStore)().getState()
  );
  if (!address) {
    throw new Error("Websocket could not be initialized: address missing");
  }
  let messageTimeout = null;
  let batchTimeout = null;
  const updateSocketStatus = (status) => {
    import_websocket2.websocketConnection.status = status;
    (0, import_configActions.setWebsocketStatus)(status);
  };
  const handleMessageReceived = (message) => {
    if (messageTimeout) {
      clearTimeout(messageTimeout);
    }
    messageTimeout = setTimeout(() => {
      (0, import_accountActions.setWebsocketEvent)(message);
    }, MESSAGE_DELAY);
  };
  const handleBatchUpdate = (data) => {
    if (batchTimeout) {
      clearTimeout(batchTimeout);
    }
    batchTimeout = setTimeout(() => {
      (0, import_accountActions.setWebsocketBatchEvent)(data);
    }, MESSAGE_DELAY);
  };
  const closeConnection = () => {
    const instance = import_websocket2.websocketConnection.instance;
    if (instance) {
      instance.off(CONNECT_ERROR);
      instance.off(CONNECT);
      instance.off(BATCH_UPDATED_EVENT);
      instance.off(DISCONNECT);
      instance.close();
      console.log("Websocket disconnected.");
    }
    updateSocketStatus(import_websocket2.WebsocketConnectionStatusEnum.NOT_INITIALIZED);
    import_websocket2.websocketConnection.instance = null;
    if (messageTimeout) {
      clearTimeout(messageTimeout);
    }
    if (batchTimeout) {
      clearTimeout(batchTimeout);
    }
  };
  const initializeConnection = (0, import_retryMultipleTimes.retryMultipleTimes)(
    async () => {
      const retryWebsocketConnect = async (retries = RECONNECTION_ATTEMPTS, delay = RETRY_INTERVAL) => {
        let attempt = 0;
        let connectionCheckTimeout = null;
        let retryTimeout = null;
        const tryReconnect = async () => {
          if (attempt >= retries) {
            console.warn("WebSocket reconnection failed after max attempts.");
            updateSocketStatus(import_websocket2.WebsocketConnectionStatusEnum.NOT_INITIALIZED);
            return;
          }
          attempt++;
          import_websocket2.websocketConnection.instance?.off();
          import_websocket2.websocketConnection.instance?.close();
          import_websocket2.websocketConnection.instance = null;
          try {
            await initializeConnection();
            connectionCheckTimeout = setTimeout(() => {
              const isConnected = import_websocket2.websocketConnection.instance?.connected;
              if (!isConnected) {
                retryTimeout = setTimeout(tryReconnect, delay);
              }
            }, SOCKET_CONNECTION_DELAY);
          } catch {
            retryTimeout = setTimeout(tryReconnect, delay);
          }
        };
        tryReconnect();
        const clearTimeouts = () => {
          if (connectionCheckTimeout) {
            clearTimeout(connectionCheckTimeout);
            connectionCheckTimeout = null;
          }
          if (retryTimeout) {
            clearTimeout(retryTimeout);
            retryTimeout = null;
          }
        };
        return clearTimeouts;
      };
      updateSocketStatus(import_websocket2.WebsocketConnectionStatusEnum.PENDING);
      const websocketUrl = customWebsocketUrl ?? await (0, import_websocket.getWebsocketUrl)(apiAddress);
      if (!websocketUrl) {
        updateSocketStatus(import_websocket2.WebsocketConnectionStatusEnum.NOT_INITIALIZED);
        return;
      }
      import_websocket2.websocketConnection.instance = (0, import_socket.io)(websocketUrl, {
        forceNew: true,
        reconnection: true,
        reconnectionAttempts: RECONNECTION_ATTEMPTS,
        timeout: TIMEOUT,
        query: { address }
      });
      import_websocket2.websocketConnection.instance.onAny(handleMessageReceived);
      import_websocket2.websocketConnection.instance.on(BATCH_UPDATED_EVENT, handleBatchUpdate);
      import_websocket2.websocketConnection.instance.on(CONNECT, () => {
        console.log("Websocket connected.");
        updateSocketStatus(import_websocket2.WebsocketConnectionStatusEnum.COMPLETED);
      });
      import_websocket2.websocketConnection.instance.on(CONNECT_ERROR, async (error) => {
        console.warn("Websocket connect error: ", error.message);
        const clearTimeouts = await retryWebsocketConnect();
        clearTimeouts();
      });
      import_websocket2.websocketConnection.instance.on(DISCONNECT, async () => {
        console.warn("Websocket disconnected. Trying to reconnect...");
        const clearTimeouts = await retryWebsocketConnect();
        clearTimeouts();
      });
    },
    { retries: 2, delay: RETRY_INTERVAL }
  );
  if (import_websocket2.websocketConnection.status === import_websocket2.WebsocketConnectionStatusEnum.NOT_INITIALIZED && !import_websocket2.websocketConnection.instance?.active) {
    await initializeConnection();
  }
  return {
    closeConnection
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  initializeWebsocketConnection
});
//# sourceMappingURL=initializeWebsocketConnection.cjs.map
