{
  "version": 3,
  "sources": ["../../../../../src/methods/trackTransactions/helpers/checkTransactionStatus/checkBatch.ts"],
  "sourcesContent": ["import { getTransactionsByHashes } from 'apiCalls/transactions/getTransactionsByHashes';\nimport {\n  updateTransactionStatus,\n  updateSessionStatus\n} from 'store/actions/transactions/transactionsActions';\nimport { getIsTransactionFailed } from 'store/actions/transactions/transactionStateByStatus';\nimport {\n  TransactionBatchStatusesEnum,\n  TransactionServerStatusesEnum\n} from 'types/enums.types';\nimport {\n  TrackedTransactionResultType,\n  SignedTransactionType\n} from 'types/transactions.types';\n\nimport { getPendingTransactions } from './getPendingTransactions';\nimport { manageFailedTransactions } from './manageFailedTransactions';\nimport { runSessionCallbacks } from './runSessionCallbacks';\n\nexport interface TransactionStatusTrackerPropsType {\n  sessionId: string;\n  transactionBatch: SignedTransactionType[];\n  isSequential?: boolean;\n}\n\ninterface RetriesType {\n  [hash: string]: number;\n}\n\nconst retries: RetriesType = {};\n\ninterface ManageTransactionType {\n  serverTransaction: TrackedTransactionResultType;\n  sessionId: string;\n  isSequential?: boolean;\n}\n\nasync function manageTransaction({\n  serverTransaction: transaction,\n  sessionId,\n  isSequential\n}: ManageTransactionType) {\n  const { hash, status, results, invalidTransaction, hasStatusChanged } =\n    transaction;\n  try {\n    const retriesForThisHash = retries[hash];\n    if (retriesForThisHash > 30) {\n      // consider transaction as stuck after 1 minute\n      updateSessionStatus({\n        sessionId,\n        status: TransactionBatchStatusesEnum.timedOut\n      });\n\n      await runSessionCallbacks({\n        sessionId,\n        status: TransactionBatchStatusesEnum.timedOut\n      });\n\n      return;\n    }\n\n    if (\n      (invalidTransaction && !isSequential) ||\n      status === TransactionBatchStatusesEnum.sent\n    ) {\n      retries[hash] = retries[hash] ? retries[hash] + 1 : 1;\n      return;\n    }\n\n    // The tx is from a sequential batch.\n    // If the transactions before this are not successful then it means that no other tx will be processed\n    if (isSequential && !status) {\n      const newStatus = updateTransactionStatus({\n        sessionId,\n        transaction\n      });\n      await runSessionCallbacks({\n        sessionId,\n        status: newStatus\n      });\n      return;\n    }\n\n    if (hasStatusChanged) {\n      const newStatus = updateTransactionStatus({\n        sessionId,\n        transaction\n      });\n\n      await runSessionCallbacks({\n        sessionId,\n        status: newStatus\n      });\n    }\n\n    if (getIsTransactionFailed(status)) {\n      await manageFailedTransactions({ sessionId, hash, results });\n    }\n  } catch (error) {\n    console.error(error);\n    updateSessionStatus({\n      sessionId,\n      status: TransactionBatchStatusesEnum.timedOut\n    });\n    await runSessionCallbacks({\n      sessionId,\n      status: TransactionBatchStatusesEnum.timedOut\n    });\n  }\n}\n\nexport async function checkBatch({\n  sessionId,\n  transactionBatch: transactions,\n  isSequential\n}: TransactionStatusTrackerPropsType) {\n  try {\n    if (transactions == null) {\n      return;\n    }\n\n    const pendingTransactions = getPendingTransactions(transactions);\n\n    const serverTransactions =\n      await getTransactionsByHashes(pendingTransactions);\n\n    for (const serverTransaction of serverTransactions) {\n      await manageTransaction({\n        serverTransaction,\n        sessionId,\n        isSequential\n      });\n    }\n\n    const hasCompleted = serverTransactions.every(\n      (tx) => tx.status !== TransactionServerStatusesEnum.pending\n    );\n\n    // Call the onSuccess or onFail callback only if the transactions are sent normally (not using batch transactions mechanism).\n    // The batch transactions mechanism will call the callbacks separately.\n\n    if (hasCompleted) {\n      const isSuccessful = serverTransactions.every(\n        (tx) => tx.status === TransactionServerStatusesEnum.success\n      );\n\n      if (isSuccessful) {\n        return updateSessionStatus({\n          sessionId,\n          status: TransactionBatchStatusesEnum.success\n        });\n      }\n\n      const isFailed = serverTransactions.some(\n        (tx) => tx.status === TransactionServerStatusesEnum.fail\n      );\n\n      if (isFailed) {\n        return updateSessionStatus({\n          sessionId,\n          status: TransactionBatchStatusesEnum.fail\n        });\n      }\n\n      const isInvalid = serverTransactions.every((tx) => tx.invalidTransaction);\n\n      if (isInvalid) {\n        return updateSessionStatus({\n          sessionId,\n          status: TransactionBatchStatusesEnum.invalid\n        });\n      }\n    }\n  } catch (error) {\n    console.error(error);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
