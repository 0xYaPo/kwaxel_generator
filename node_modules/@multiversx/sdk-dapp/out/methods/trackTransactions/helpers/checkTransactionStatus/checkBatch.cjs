"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var checkBatch_exports = {};
__export(checkBatch_exports, {
  checkBatch: () => checkBatch
});
module.exports = __toCommonJS(checkBatch_exports);
var import_getTransactionsByHashes = require("../../../../apiCalls/transactions/getTransactionsByHashes");
var import_transactionsActions = require("../../../../store/actions/transactions/transactionsActions");
var import_transactionStateByStatus = require("../../../../store/actions/transactions/transactionStateByStatus");
var import_enums = require("../../../../types/enums.types");
var import_getPendingTransactions = require("./getPendingTransactions");
var import_manageFailedTransactions = require("./manageFailedTransactions");
var import_runSessionCallbacks = require("./runSessionCallbacks");
const retries = {};
async function manageTransaction({
  serverTransaction: transaction,
  sessionId,
  isSequential
}) {
  const { hash, status, results, invalidTransaction, hasStatusChanged } = transaction;
  try {
    const retriesForThisHash = retries[hash];
    if (retriesForThisHash > 30) {
      (0, import_transactionsActions.updateSessionStatus)({
        sessionId,
        status: import_enums.TransactionBatchStatusesEnum.timedOut
      });
      await (0, import_runSessionCallbacks.runSessionCallbacks)({
        sessionId,
        status: import_enums.TransactionBatchStatusesEnum.timedOut
      });
      return;
    }
    if (invalidTransaction && !isSequential || status === import_enums.TransactionBatchStatusesEnum.sent) {
      retries[hash] = retries[hash] ? retries[hash] + 1 : 1;
      return;
    }
    if (isSequential && !status) {
      const newStatus = (0, import_transactionsActions.updateTransactionStatus)({
        sessionId,
        transaction
      });
      await (0, import_runSessionCallbacks.runSessionCallbacks)({
        sessionId,
        status: newStatus
      });
      return;
    }
    if (hasStatusChanged) {
      const newStatus = (0, import_transactionsActions.updateTransactionStatus)({
        sessionId,
        transaction
      });
      await (0, import_runSessionCallbacks.runSessionCallbacks)({
        sessionId,
        status: newStatus
      });
    }
    if ((0, import_transactionStateByStatus.getIsTransactionFailed)(status)) {
      await (0, import_manageFailedTransactions.manageFailedTransactions)({ sessionId, hash, results });
    }
  } catch (error) {
    console.error(error);
    (0, import_transactionsActions.updateSessionStatus)({
      sessionId,
      status: import_enums.TransactionBatchStatusesEnum.timedOut
    });
    await (0, import_runSessionCallbacks.runSessionCallbacks)({
      sessionId,
      status: import_enums.TransactionBatchStatusesEnum.timedOut
    });
  }
}
async function checkBatch({
  sessionId,
  transactionBatch: transactions,
  isSequential
}) {
  try {
    if (transactions == null) {
      return;
    }
    const pendingTransactions = (0, import_getPendingTransactions.getPendingTransactions)(transactions);
    const serverTransactions = await (0, import_getTransactionsByHashes.getTransactionsByHashes)(pendingTransactions);
    for (const serverTransaction of serverTransactions) {
      await manageTransaction({
        serverTransaction,
        sessionId,
        isSequential
      });
    }
    const hasCompleted = serverTransactions.every(
      (tx) => tx.status !== import_enums.TransactionServerStatusesEnum.pending
    );
    if (hasCompleted) {
      const isSuccessful = serverTransactions.every(
        (tx) => tx.status === import_enums.TransactionServerStatusesEnum.success
      );
      if (isSuccessful) {
        return (0, import_transactionsActions.updateSessionStatus)({
          sessionId,
          status: import_enums.TransactionBatchStatusesEnum.success
        });
      }
      const isFailed = serverTransactions.some(
        (tx) => tx.status === import_enums.TransactionServerStatusesEnum.fail
      );
      if (isFailed) {
        return (0, import_transactionsActions.updateSessionStatus)({
          sessionId,
          status: import_enums.TransactionBatchStatusesEnum.fail
        });
      }
      const isInvalid = serverTransactions.every((tx) => tx.invalidTransaction);
      if (isInvalid) {
        return (0, import_transactionsActions.updateSessionStatus)({
          sessionId,
          status: import_enums.TransactionBatchStatusesEnum.invalid
        });
      }
    }
  } catch (error) {
    console.error(error);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  checkBatch
});
//# sourceMappingURL=checkBatch.cjs.map
