{
  "version": 3,
  "sources": ["../../../../src/services/nativeAuth/helpers/getLatestBlockHash.ts"],
  "sourcesContent": ["import axios from 'axios';\nimport { BLOCKS_ENDPOINT } from 'apiCalls/endpoints';\nimport { retryMultipleTimes } from 'utils/retryMultipleTimes';\n\nexport interface LatestBlockHashType {\n  hash: string;\n  timestamp: number;\n}\n\nconst getBlockFromPosition = 4;\nconst cachingDurationMs = 30000; // 30 seconds, a block hash is valid for 1 minute from its generation\n//this is an object with .current, so it doesn't get affected by closure and is always a fresh value\nconst cachedResponse: Record<string, LatestBlockHashType | null> = {\n  current: null\n};\n\nconst requestPromise: {\n  current: Promise<LatestBlockHashType> | null;\n} = {\n  current: null\n};\n\nconst getLatestBlockHashFromServer = retryMultipleTimes(\n  async (\n    apiUrl: string,\n    blockHashShard?: number,\n    getBlockHash?: () => Promise<string>\n  ): Promise<LatestBlockHashType | null> => {\n    // get current block hash\n    if (getBlockHash) {\n      const timestamp = Math.floor(Date.now() / 1000);\n      const hash = await getBlockHash();\n\n      return { hash, timestamp };\n    }\n\n    //get the penultimate block hash (3 shards + the meta chain) to make sure that the block is seen by auth server\n    const { data } = await axios.get<Array<LatestBlockHashType>>(\n      `${apiUrl}/${BLOCKS_ENDPOINT}?from=${getBlockFromPosition}&size=1&fields=hash,timestamp${\n        blockHashShard ? '&shard=' + blockHashShard : ''\n      }`\n    );\n    const [latestBlock] = data;\n    return latestBlock;\n  }\n);\n\ntype GetLatestBlockHashType = {\n  apiAddress: string;\n  blockHashShard?: number;\n  getBlockHash: () => Promise<string>;\n  noCache?: boolean;\n};\n\nexport async function getLatestBlockHash({\n  apiAddress,\n  noCache,\n  blockHashShard,\n  getBlockHash\n}: GetLatestBlockHashType): Promise<LatestBlockHashType> {\n  if (apiAddress == null) {\n    throw new Error('missing api url');\n  }\n\n  const currentTimestampMs = Date.now();\n  if (\n    cachedResponse.current != null &&\n    currentTimestampMs <\n      cachedResponse.current.timestamp * 1000 + cachingDurationMs &&\n    !noCache\n  ) {\n    return cachedResponse.current;\n  }\n  //this will prevent multiple calls to this function from generating multiple hashes\n  if (requestPromise.current != null) {\n    //if there is already an await in progress for the API, just return the result of that promise\n    return await requestPromise.current;\n  }\n\n  //if a promise is not in progress, get a new promise and add it to the promise\n  requestPromise.current = getLatestBlockHashFromServer(\n    apiAddress,\n    blockHashShard,\n    getBlockHash\n  );\n\n  try {\n    const response = await requestPromise.current;\n    if (response == null) {\n      requestPromise.current = null;\n      throw new Error('could not get block hash');\n    }\n    //set the new response, the new expiry and unlock the regeneration flow for the next expiration period\n    cachedResponse.current = {\n      hash: response.hash,\n      timestamp: response.timestamp\n    };\n\n    requestPromise.current = null;\n    return response;\n  } catch (_error) {\n    requestPromise.current = null;\n    return null as any;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkB;AAClB,uBAAgC;AAChC,gCAAmC;AAOnC,MAAM,uBAAuB;AAC7B,MAAM,oBAAoB;AAE1B,MAAM,iBAA6D;AAAA,EACjE,SAAS;AACX;AAEA,MAAM,iBAEF;AAAA,EACF,SAAS;AACX;AAEA,MAAM,mCAA+B;AAAA,EACnC,OACE,QACA,gBACA,iBACwC;AAExC,QAAI,cAAc;AAChB,YAAM,YAAY,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI;AAC9C,YAAM,OAAO,MAAM,aAAa;AAEhC,aAAO,EAAE,MAAM,UAAU;AAAA,IAC3B;AAGA,UAAM,EAAE,KAAK,IAAI,MAAM,aAAAA,QAAM;AAAA,MAC3B,GAAG,MAAM,IAAI,gCAAe,SAAS,oBAAoB,gCACvD,iBAAiB,YAAY,iBAAiB,EAChD;AAAA,IACF;AACA,UAAM,CAAC,WAAW,IAAI;AACtB,WAAO;AAAA,EACT;AACF;AASA,eAAsB,mBAAmB;AAAA,EACvC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAyD;AACvD,MAAI,cAAc,MAAM;AACtB,UAAM,IAAI,MAAM,iBAAiB;AAAA,EACnC;AAEA,QAAM,qBAAqB,KAAK,IAAI;AACpC,MACE,eAAe,WAAW,QAC1B,qBACE,eAAe,QAAQ,YAAY,MAAO,qBAC5C,CAAC,SACD;AACA,WAAO,eAAe;AAAA,EACxB;AAEA,MAAI,eAAe,WAAW,MAAM;AAElC,WAAO,MAAM,eAAe;AAAA,EAC9B;AAGA,iBAAe,UAAU;AAAA,IACvB;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI;AACF,UAAM,WAAW,MAAM,eAAe;AACtC,QAAI,YAAY,MAAM;AACpB,qBAAe,UAAU;AACzB,YAAM,IAAI,MAAM,0BAA0B;AAAA,IAC5C;AAEA,mBAAe,UAAU;AAAA,MACvB,MAAM,SAAS;AAAA,MACf,WAAW,SAAS;AAAA,IACtB;AAEA,mBAAe,UAAU;AACzB,WAAO;AAAA,EACT,SAAS,QAAQ;AACf,mBAAe,UAAU;AACzB,WAAO;AAAA,EACT;AACF;",
  "names": ["axios"]
}
