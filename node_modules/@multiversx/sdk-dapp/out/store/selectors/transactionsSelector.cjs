"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var transactionsSelector_exports = {};
__export(transactionsSelector_exports, {
  failedTransactionsSelector: () => failedTransactionsSelector,
  failedTransactionsSessionsSelector: () => failedTransactionsSessionsSelector,
  pendingTransactionsSelector: () => pendingTransactionsSelector,
  pendingTransactionsSessionsSelector: () => pendingTransactionsSessionsSelector,
  successfulTransactionsSelector: () => successfulTransactionsSelector,
  successfulTransactionsSessionsSelector: () => successfulTransactionsSessionsSelector,
  timedOutTransactionsSelector: () => timedOutTransactionsSelector,
  transactionsSliceSelector: () => transactionsSliceSelector
});
module.exports = __toCommonJS(transactionsSelector_exports);
var import_enums = require("../../types/enums.types");
const transactionsSliceSelector = ({ transactions }) => transactions;
const pendingTransactionsSessionsSelector = ({
  transactions: state
}) => {
  const pendingSessions = {};
  Object.entries(state).forEach(([sessionId, data]) => {
    const hasPendingTransactions = data.transactions.some(
      ({ status }) => status === import_enums.TransactionServerStatusesEnum.pending
    );
    if (hasPendingTransactions && data.status === "sent") {
      pendingSessions[sessionId] = data;
    }
  });
  return pendingSessions;
};
const successfulTransactionsSessionsSelector = ({
  transactions: state
}) => {
  const successfulSessions = {};
  Object.entries(state).forEach(([sessionId, data]) => {
    const hasSuccessfulTransactions = data.transactions.some(
      ({ status }) => status === import_enums.TransactionServerStatusesEnum.success
    );
    if (hasSuccessfulTransactions && data.status === "sent") {
      successfulSessions[sessionId] = data;
    }
  });
  return successfulSessions;
};
const failedTransactionsSessionsSelector = ({
  transactions: state
}) => {
  const failedSessions = {};
  Object.entries(state).forEach(([sessionId, data]) => {
    const hasFailedTransactions = data.transactions.some(
      ({ status }) => status && [
        import_enums.TransactionServerStatusesEnum.fail,
        import_enums.TransactionServerStatusesEnum.invalid,
        import_enums.TransactionBatchStatusesEnum.cancelled,
        import_enums.TransactionBatchStatusesEnum.timedOut
      ].includes(status)
    );
    if (hasFailedTransactions && data.status === "sent") {
      failedSessions[sessionId] = data;
    }
  });
  return failedSessions;
};
const pendingTransactionsSelector = ({
  transactions: state
}) => {
  const pendingTransactions = [];
  Object.values(state).forEach(({ transactions }) => {
    transactions.forEach((transaction) => {
      if (transaction.status && [
        import_enums.TransactionServerStatusesEnum.pending,
        import_enums.TransactionBatchStatusesEnum.sent
      ].includes(transaction.status)) {
        pendingTransactions.push(transaction);
      }
    });
  });
  return pendingTransactions;
};
const successfulTransactionsSelector = ({
  transactions: state
}) => {
  const successfulTransactions = [];
  Object.values(state).forEach(({ transactions }) => {
    transactions.forEach((transaction) => {
      if (transaction.status === import_enums.TransactionServerStatusesEnum.success) {
        successfulTransactions.push(transaction);
      }
    });
  });
  return successfulTransactions;
};
const failedTransactionsSelector = ({
  transactions: state
}) => {
  const failedTransactions = [];
  Object.values(state).forEach(({ transactions }) => {
    transactions.forEach((transaction) => {
      if (transaction.status && [
        import_enums.TransactionServerStatusesEnum.fail,
        import_enums.TransactionServerStatusesEnum.invalid,
        import_enums.TransactionBatchStatusesEnum.cancelled,
        import_enums.TransactionBatchStatusesEnum.timedOut
      ].includes(transaction.status)) {
        failedTransactions.push(transaction);
      }
    });
  });
  return failedTransactions;
};
const timedOutTransactionsSelector = ({
  transactions: state
}) => {
  const timedOutTransactions = [];
  Object.values(state).forEach(({ transactions }) => {
    transactions.forEach((transaction) => {
      if (transaction.status === import_enums.TransactionBatchStatusesEnum.timedOut) {
        timedOutTransactions.push(transaction);
      }
    });
  });
  return timedOutTransactions;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  failedTransactionsSelector,
  failedTransactionsSessionsSelector,
  pendingTransactionsSelector,
  pendingTransactionsSessionsSelector,
  successfulTransactionsSelector,
  successfulTransactionsSessionsSelector,
  timedOutTransactionsSelector,
  transactionsSliceSelector
});
//# sourceMappingURL=transactionsSelector.cjs.map
