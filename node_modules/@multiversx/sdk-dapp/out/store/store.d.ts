import { StorageCallback } from './storage';
import { StoreType } from './store.types';
export type MutatorsIn = [
    [
        'zustand/devtools',
        never
    ],
    [
        'zustand/persist',
        unknown
    ],
    [
        'zustand/immer',
        never
    ]
];
export type MutatorsOut = [
    [
        'zustand/devtools',
        never
    ],
    [
        'zustand/persist',
        StoreType
    ],
    [
        'zustand/immer',
        never
    ]
];
export declare const createDAppStore: (getStorageCallback: StorageCallback) => Omit<Omit<Omit<import("zustand/vanilla").StoreApi<StoreType>, "setState"> & {
    setState<A extends string | {
        type: string;
    }>(partial: StoreType | Partial<StoreType> | ((state: StoreType) => StoreType | Partial<StoreType>), replace?: boolean | undefined, action?: A | undefined): void;
}, "persist"> & {
    persist: {
        setOptions: (options: Partial<import("zustand/middleware").PersistOptions<StoreType, StoreType>>) => void;
        clearStorage: () => void;
        rehydrate: () => void | Promise<void>;
        hasHydrated: () => boolean;
        onHydrate: (fn: (state: StoreType) => void) => () => void;
        onFinishHydration: (fn: (state: StoreType) => void) => () => void;
        getOptions: () => Partial<import("zustand/middleware").PersistOptions<StoreType, StoreType>>;
    };
}, "setState"> & {
    setState(nextStateOrUpdater: StoreType | Partial<StoreType> | ((state: import("immer").WritableDraft<StoreType>) => void), shouldReplace?: boolean | undefined, action?: string | {
        type: string;
    } | undefined): void;
};
export type StoreApi = ReturnType<typeof createDAppStore>;
export declare const setDAppStore: (_store: StoreApi) => void;
export declare const getStore: () => Omit<Omit<Omit<import("zustand/vanilla").StoreApi<StoreType>, "setState"> & {
    setState<A extends string | {
        type: string;
    }>(partial: StoreType | Partial<StoreType> | ((state: StoreType) => StoreType | Partial<StoreType>), replace?: boolean | undefined, action?: A | undefined): void;
}, "persist"> & {
    persist: {
        setOptions: (options: Partial<import("zustand/middleware").PersistOptions<StoreType, StoreType>>) => void;
        clearStorage: () => void;
        rehydrate: () => void | Promise<void>;
        hasHydrated: () => boolean;
        onHydrate: (fn: (state: StoreType) => void) => () => void;
        onFinishHydration: (fn: (state: StoreType) => void) => () => void;
        getOptions: () => Partial<import("zustand/middleware").PersistOptions<StoreType, StoreType>>;
    };
}, "setState"> & {
    setState(nextStateOrUpdater: StoreType | Partial<StoreType> | ((state: import("immer").WritableDraft<StoreType>) => void), shouldReplace?: boolean | undefined, action?: string | {
        type: string;
    } | undefined): void;
};
/**
 * Initialize store with the preferred storage by passing a callback.
 * Default storage is localStorage.
 * You can pass your own storage.
 * Call this function before using store, ideally before app bootstrapping.
 * @param getStorageCallback
 * @default () => localStorage
 * @returns persistent store instance
 * @example
 * initStore(() => window.localStorage);
 * initStore(() => window.sessionStorage);
 * initStore(() => new InMemoryStorage());
 * */
export declare const initStore: (getStorageCallback?: StorageCallback) => Omit<Omit<Omit<import("zustand/vanilla").StoreApi<StoreType>, "setState"> & {
    setState<A extends string | {
        type: string;
    }>(partial: StoreType | Partial<StoreType> | ((state: StoreType) => StoreType | Partial<StoreType>), replace?: boolean | undefined, action?: A | undefined): void;
}, "persist"> & {
    persist: {
        setOptions: (options: Partial<import("zustand/middleware").PersistOptions<StoreType, StoreType>>) => void;
        clearStorage: () => void;
        rehydrate: () => void | Promise<void>;
        hasHydrated: () => boolean;
        onHydrate: (fn: (state: StoreType) => void) => () => void;
        onFinishHydration: (fn: (state: StoreType) => void) => () => void;
        getOptions: () => Partial<import("zustand/middleware").PersistOptions<StoreType, StoreType>>;
    };
}, "setState"> & {
    setState(nextStateOrUpdater: StoreType | Partial<StoreType> | ((state: import("immer").WritableDraft<StoreType>) => void), shouldReplace?: boolean | undefined, action?: string | {
        type: string;
    } | undefined): void;
};
export declare const getState: () => StoreType;
