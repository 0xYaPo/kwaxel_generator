{
  "version": 3,
  "sources": ["../../src/providers/ProviderFactory.ts", "../../src/providers/strategies/LedgerProviderStrategy/LedgerProviderStrategy.ts", "../../src/managers/internal/LedgerIdleStateManager/LedgerIdleStateManager.ts", "../../src/providers/strategies/CrossWindowProviderStrategy/CrossWindowProviderStrategy.ts", "../../src/providers/strategies/ExtensionProviderStrategy/ExtensionProviderStrategy.ts", "../../src/providers/strategies/IframeProviderStrategy/IframeProviderStrategy.ts", "../../src/providers/strategies/WalletConnectProviderStrategy/WalletConnectProviderStrategy.ts", "../../src/providers/strategies/helpers/signMessage/signMessage.ts", "../../src/providers/strategies/LedgerProviderStrategy/helpers/signLedgerMessage.ts"],
  "sourcesContent": ["import { IframeLoginTypes } from '@multiversx/sdk-web-wallet-iframe-provider/out/constants';\nimport { LedgerIdleStateManager } from 'managers/internal/LedgerIdleStateManager/LedgerIdleStateManager';\nimport { getAddress } from 'methods/account/getAddress';\nimport {\n  CrossWindowProviderStrategy,\n  ExtensionProviderStrategy,\n  IframeProviderStrategy,\n  LedgerProviderStrategy,\n  WalletConnectProviderStrategy,\n  WalletConnectV2Error\n} from 'providers/strategies';\nimport { setProviderType } from 'store/actions/loginInfo/loginInfoActions';\nimport { walletConnectConfigSelector } from 'store/selectors/configSelectors';\nimport { getState } from 'store/store';\nimport { DappProvider } from './DappProvider/DappProvider';\nimport {\n  getAccountProvider,\n  setAccountProvider\n} from './helpers/accountProvider';\nimport { clearInitiatedLogins } from './helpers/clearInitiatedLogins';\nimport { WebviewProviderStrategy } from './strategies/WebviewProviderStrategy';\nimport {\n  ICustomProvider,\n  IProvider,\n  IProviderFactory,\n  ProviderType,\n  ProviderTypeEnum\n} from './types/providerFactory.types';\n\nexport class ProviderFactory {\n  private static _customProviders: ICustomProvider[] = [];\n\n  public static set customProviders(providers: ICustomProvider[]) {\n    this._customProviders = providers;\n  }\n\n  public static get customProviders() {\n    return this._customProviders;\n  }\n\n  public static async create({\n    type,\n    anchor\n  }: IProviderFactory): Promise<DappProvider> {\n    let createdProvider: IProvider | null = null;\n\n    switch (type) {\n      case ProviderTypeEnum.extension: {\n        createdProvider = new ExtensionProviderStrategy();\n\n        break;\n      }\n\n      case ProviderTypeEnum.crossWindow: {\n        createdProvider = new CrossWindowProviderStrategy();\n\n        break;\n      }\n\n      case ProviderTypeEnum.ledger: {\n        createdProvider = new LedgerProviderStrategy({ anchor });\n\n        const ledgerIdleStateManager = LedgerIdleStateManager.getInstance();\n        await ledgerIdleStateManager.init();\n\n        break;\n      }\n\n      case ProviderTypeEnum.metamask: {\n        createdProvider = new IframeProviderStrategy({\n          type: IframeLoginTypes.metamask\n        });\n\n        break;\n      }\n\n      case ProviderTypeEnum.passkey: {\n        createdProvider = new IframeProviderStrategy({\n          type: IframeLoginTypes.passkey\n        });\n\n        break;\n      }\n      case ProviderTypeEnum.walletConnect: {\n        const walletConnectConfig = walletConnectConfigSelector(getState());\n\n        if (!walletConnectConfig?.walletConnectV2ProjectId) {\n          throw new Error(WalletConnectV2Error.invalidConfig);\n        }\n\n        createdProvider = new WalletConnectProviderStrategy({\n          anchor,\n          ...walletConnectConfig\n        });\n\n        break;\n      }\n      case ProviderTypeEnum.webview: {\n        createdProvider = new WebviewProviderStrategy();\n        break;\n      }\n\n      default: {\n        const address = getAddress();\n\n        for (const customProvider of this._customProviders) {\n          if (customProvider.type === type) {\n            createdProvider = await customProvider.constructor({\n              address,\n              anchor\n            });\n          }\n        }\n        break;\n      }\n    }\n\n    if (!createdProvider) {\n      throw new Error('Unable to create provider');\n    }\n\n    await createdProvider.init();\n\n    const dappProvider = new DappProvider(createdProvider);\n    setAccountProvider(dappProvider);\n\n    const shouldClearInitiatedLogins = (\n      [\n        ProviderTypeEnum.crossWindow,\n        ProviderTypeEnum.metamask,\n        ProviderTypeEnum.passkey\n      ] as readonly ProviderType[]\n    ).includes(type);\n\n    // Clear initiated logins and skip the login method if it's crossWindow or metamask\n    clearInitiatedLogins(\n      shouldClearInitiatedLogins ? { skipLoginMethod: type } : null\n    );\n\n    return dappProvider;\n  }\n\n  public static async destroy() {\n    const provider = getAccountProvider();\n    provider.cancelLogin();\n    setAccountProvider(null);\n    setProviderType(ProviderTypeEnum.none);\n  }\n}\n", "import { HWProvider } from '@multiversx/sdk-hw-provider';\n\nimport { CANCEL_TRANSACTION_TOAST_DEFAULT_DURATION } from 'constants/transactions.constants';\nimport { Message, Transaction } from 'lib/sdkCore';\nimport { IDAppProviderAccount } from 'lib/sdkDappUtils';\nimport { LedgerConnectStateManager } from 'managers/internal/LedgerConnectStateManager/LedgerConnectStateManager';\nimport { ToastIconsEnum } from 'managers/internal/ToastManager/helpers/getToastDataStateByStatus';\nimport { getIsLoggedIn } from 'methods/account/getIsLoggedIn';\nimport {\n  ProviderTypeEnum,\n  ProviderType\n} from 'providers/types/providerFactory.types';\nimport { createCustomToast } from 'store/actions/toasts/toastsActions';\nimport { ProviderErrorsEnum } from 'types/provider.types';\nimport { getLedgerProvider } from './helpers';\nimport { authenticateLedgerAccount } from './helpers/authenticateLedgerAccount';\nimport { initializeLedgerProvider } from './helpers/initializeLedgerProvider';\nimport { signLedgerMessage } from './helpers/signLedgerMessage';\nimport { LedgerConfigType } from './types/ledgerProvider.types';\nimport {\n  BaseProviderStrategy,\n  LoginOptionsTypes\n} from '../BaseProviderStrategy/BaseProviderStrategy';\nimport { signTransactions } from '../helpers/signTransactions/signTransactions';\n\ntype LedgerProviderStrategyOptionsType = {\n  anchor?: HTMLElement;\n  shouldInitProvider?: boolean;\n};\n\ntype LedgerProviderStrategyType = LedgerProviderStrategyOptionsType & {\n  address?: string;\n};\n\nexport class LedgerProviderStrategy extends BaseProviderStrategy {\n  private provider: HWProvider | null = null;\n  private config: LedgerConfigType | null = null;\n  private readonly options?: LedgerProviderStrategyOptionsType;\n\n  constructor({\n    address,\n    anchor,\n    shouldInitProvider\n  }: LedgerProviderStrategyType) {\n    super(address);\n    this.options = { anchor, shouldInitProvider };\n    this._login = this.ledgerLogin.bind(this);\n  }\n\n  async init(): Promise<boolean> {\n    try {\n      this.initializeAddress();\n      await this.initializeProvider();\n    } catch {\n      return false;\n    }\n\n    return true;\n  }\n\n  logout(): Promise<boolean> {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    return this.provider.logout();\n  }\n\n  getType(): ProviderType {\n    return ProviderTypeEnum.ledger;\n  }\n\n  getAddress(): Promise<string | undefined> {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    return this.provider.getAddress();\n  }\n\n  setAccount(account: IDAppProviderAccount): void {\n    return this.provider?.setAccount(account);\n  }\n\n  isInitialized(): boolean {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    return this.provider.isInitialized();\n  }\n\n  private async initializeProvider() {\n    await this.initLegderConnectManager(this.options?.anchor);\n    const ledgerConnectManager = LedgerConnectStateManager.getInstance();\n\n    const { ledgerProvider, ledgerConfig } = await new Promise<\n      Awaited<ReturnType<typeof getLedgerProvider>>\n    >((resolve, reject) =>\n      initializeLedgerProvider({\n        manager: ledgerConnectManager,\n        resolve,\n        reject,\n        shouldInitProvider: this.options?.shouldInitProvider\n      })\n    );\n\n    this.config = ledgerConfig;\n    this.provider = ledgerProvider;\n  }\n\n  private readonly ledgerLogin = async (\n    options?: LoginOptionsTypes & { addressIndex?: number }\n  ): Promise<{ address: string; signature: string }> => {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n    if (!options || typeof options.addressIndex !== 'number') {\n      throw new Error('Missing addressIndex for Ledger login');\n    }\n    const { address, signature } = await this.provider.login({\n      addressIndex: options.addressIndex\n    });\n    return {\n      address,\n      signature: signature ?? ''\n    };\n  };\n\n  public override loginOperation = async (options?: LoginOptionsTypes) => {\n    if (!this.provider || !this.config) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    return await authenticateLedgerAccount({\n      options,\n      config: this.config,\n      provider: this.provider,\n      login: this.ledgerLogin.bind(this)\n    });\n  };\n\n  private readonly initLegderConnectManager = async (anchor?: HTMLElement) => {\n    const shouldInitiateLogin = !getIsLoggedIn();\n\n    if (!shouldInitiateLogin) {\n      return;\n    }\n\n    const ledgerConnectManager = LedgerConnectStateManager.getInstance();\n    await ledgerConnectManager.init(anchor);\n  };\n\n  signTransactions = async (transactions: Transaction[]) => {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    await this.rebuildProvider();\n\n    const signedTransactions = await signTransactions({\n      transactions,\n      handleSign: this.provider.signTransactions.bind(this.provider)\n    });\n\n    return signedTransactions;\n  };\n\n  signMessage = async (message: Message): Promise<Message> => {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    await this.rebuildProvider();\n\n    const signedMessage = await signLedgerMessage({\n      message,\n      handleSignMessage: this.provider.signMessage.bind(this.provider)\n    });\n\n    return signedMessage;\n  };\n\n  /**\n   * Makes sure the device is accessible and if not, tries to initialize a new provider\n   */\n  private readonly rebuildProvider = async () => {\n    try {\n      await this.provider?.getAddress(); // can communicate with device\n    } catch (_err) {\n      try {\n        const { ledgerProvider } = await getLedgerProvider({\n          shouldInitProvider: true\n        });\n        this.provider = ledgerProvider;\n      } catch (error) {\n        createCustomToast({\n          toastId: 'ledger-provider-rebuild-error',\n          duration: CANCEL_TRANSACTION_TOAST_DEFAULT_DURATION,\n          icon: ToastIconsEnum.times,\n          iconClassName: 'warning',\n          message: 'Unlock your device & open the MultiversX App',\n          title: 'Ledger unavailable'\n        });\n        throw error;\n      }\n    }\n  };\n}\n", "import { DappProvider } from 'providers/DappProvider';\nimport {\n  getAccountProvider,\n  setAccountProvider\n} from 'providers/helpers/accountProvider';\nimport { LedgerProviderStrategy } from 'providers/strategies/LedgerProviderStrategy/LedgerProviderStrategy';\nimport { ProviderTypeEnum } from 'providers/types/providerFactory.types';\nimport { isLoggedInSelector, loginInfoSelector } from 'store/selectors';\nimport { isSidePanelOpenSelector } from 'store/selectors/uiSelectors';\nimport { getState, getStore } from 'store/store';\nimport { ToastIconsEnum } from '../ToastManager/helpers/getToastDataStateByStatus';\nimport { ToastManager } from '../ToastManager/ToastManager';\n\nconst LEDGER_IDLE_STATE_CHECK_INTERVAL = 30_000;\nconst LEDGER_IDLE_STATE_RECONNECT_INTERVAL = 5_000;\nconst RECONNECT_SUCCESS_DURATION = 3000;\n\nexport class LedgerIdleStateManager {\n  private static instance: LedgerIdleStateManager;\n  private store = getStore();\n  private connectionCheckInterval: ReturnType<typeof setInterval> | null = null;\n  private recreateProviderInterval: ReturnType<typeof setInterval> | null =\n    null;\n\n  public static getInstance(): LedgerIdleStateManager {\n    if (!LedgerIdleStateManager.instance) {\n      LedgerIdleStateManager.instance = new LedgerIdleStateManager();\n    }\n    return LedgerIdleStateManager.instance;\n  }\n\n  private constructor() {}\n\n  public init = async () => {\n    this.startCheckConnectionLoop();\n  };\n\n  private readonly shouldCheckConnection = (): boolean => {\n    const state = this.store.getState();\n    const { providerType } = loginInfoSelector(state);\n    const isLoggedIn = isLoggedInSelector(state);\n    return Boolean(providerType === ProviderTypeEnum.ledger && isLoggedIn);\n  };\n\n  private readonly startCheckConnectionLoop = () => {\n    if (this.connectionCheckInterval) {\n      return;\n    }\n\n    this.connectionCheckInterval = setInterval(async () => {\n      const isSigningProcess = isSidePanelOpenSelector(getState());\n\n      if (!this.shouldCheckConnection() || isSigningProcess) {\n        return;\n      }\n\n      try {\n        const ledgerProvider = getAccountProvider().getProvider();\n        await ledgerProvider.getAddress();\n      } catch (_error) {\n        ToastManager.getInstance().createCustomToast({\n          toastId: 'ledger-provider-idle-warning',\n          icon: ToastIconsEnum.times,\n          iconClassName: 'warning',\n          message: 'Unlock your device to continue signing transactions',\n          title: 'Ledger disconnected'\n        });\n        this.reset();\n        if (this.recreateProviderInterval) {\n          return;\n        }\n        this.recreateProviderInterval = setInterval(\n          this.reconnectProvider,\n          LEDGER_IDLE_STATE_RECONNECT_INTERVAL\n        );\n      }\n    }, LEDGER_IDLE_STATE_CHECK_INTERVAL);\n  };\n\n  private readonly reconnectProvider = async () => {\n    if (!this.shouldCheckConnection()) {\n      return;\n    }\n\n    try {\n      const createdProvider = new LedgerProviderStrategy({\n        shouldInitProvider: true\n      });\n\n      await createdProvider.init();\n\n      const dappProvider = new DappProvider(createdProvider);\n      createdProvider.getType = () => ProviderTypeEnum.ledger;\n      setAccountProvider(dappProvider);\n\n      this.reset();\n      clearInterval(this.recreateProviderInterval ?? 0);\n      this.recreateProviderInterval = null;\n\n      ToastManager.getInstance().createCustomToast({\n        toastId: 'ledger-provider-idle-warning',\n        duration: RECONNECT_SUCCESS_DURATION,\n        icon: ToastIconsEnum.check,\n        iconClassName: 'success',\n        message: 'Your device is ready to sign transactions',\n        title: 'Ledger reconnected'\n      });\n      this.startCheckConnectionLoop();\n    } catch (_err) {\n      console.log('Unable to reconnect to Ledger');\n    }\n  };\n\n  public reset = () => {\n    clearInterval(this.connectionCheckInterval ?? 0);\n    this.connectionCheckInterval = null;\n  };\n}\n", "import { providerLabels } from 'constants/providerFactory.constants';\nimport { Message, Transaction } from 'lib/sdkCore';\nimport { IDAppProviderAccount } from 'lib/sdkDappUtils';\nimport { CrossWindowProvider } from 'lib/sdkWebWalletCrossWindowProvider';\nimport {\n  ProviderTypeEnum,\n  ProviderType\n} from 'providers/types/providerFactory.types';\nimport { networkSelector } from 'store/selectors/networkSelectors';\nimport { getState } from 'store/store';\nimport { ProviderErrorsEnum } from 'types/provider.types';\nimport { BaseProviderStrategy } from '../BaseProviderStrategy/BaseProviderStrategy';\nimport { signMessage } from '../helpers/signMessage/signMessage';\nimport { guardTransactions } from '../helpers/signTransactions/helpers/guardTransactions/guardTransactions';\n\ntype CrossWindowProviderProps = {\n  address?: string;\n  walletAddress?: string;\n};\n\nexport class CrossWindowProviderStrategy extends BaseProviderStrategy {\n  private readonly provider: CrossWindowProvider;\n  private readonly walletAddress?: string;\n\n  constructor(config?: CrossWindowProviderProps) {\n    super(config?.address);\n    this.walletAddress = config?.walletAddress;\n    this.provider = CrossWindowProvider.getInstance();\n    this._login = this.provider.login.bind(this.provider);\n  }\n\n  async init(): Promise<boolean> {\n    this.initializeAddress();\n    return this.initializeProvider();\n  }\n\n  private async initializeProvider() {\n    const network = networkSelector(getState());\n\n    const isProviderInitialized = await this.provider.init();\n\n    this.provider.setWalletUrl(this.walletAddress ?? network.walletAddress);\n\n    if (this.address) {\n      this.provider.setAddress(this.address);\n    }\n\n    return isProviderInitialized;\n  }\n\n  logout(): Promise<boolean> {\n    return this.provider.logout();\n  }\n\n  getType(): ProviderType {\n    return ProviderTypeEnum.crossWindow;\n  }\n\n  getAddress(): Promise<string | undefined> {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    return this.provider.getAddress();\n  }\n\n  setAccount(account: IDAppProviderAccount): void {\n    return this.provider.setAccount(account);\n  }\n\n  isInitialized(): boolean {\n    return this.provider.isInitialized();\n  }\n\n  cancelAction = async () => {\n    this.provider.cancelAction();\n  };\n\n  signTransactions = async (transactions: Transaction[]) => {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    const { onClose, manager } = await this.initSignState();\n\n    try {\n      const signedTransactions: Transaction[] =\n        (await this.provider.signTransactions(transactions)) ?? [];\n\n      const optionallyGuardedTransactions =\n        await guardTransactions(signedTransactions);\n\n      return optionallyGuardedTransactions;\n    } catch (error) {\n      await onClose({ shouldCancelAction: true });\n\n      throw error;\n    } finally {\n      manager.closeUI();\n    }\n  };\n\n  signMessage = async (message: Message) => {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    const signedMessage = await signMessage({\n      message,\n      handleSignMessage: this.provider.signMessage.bind(this.provider),\n      cancelAction: this.cancelAction,\n      providerType: providerLabels.crossWindow\n    });\n\n    return signedMessage;\n  };\n}\n", "import { ExtensionProvider } from '@multiversx/sdk-extension-provider/out/extensionProvider';\nimport { providerLabels } from 'constants/providerFactory.constants';\nimport { Message, Transaction } from 'lib/sdkCore';\nimport { IDAppProviderAccount } from 'lib/sdkDappUtils';\nimport {\n  ProviderTypeEnum,\n  ProviderType\n} from 'providers/types/providerFactory.types';\nimport { ProviderErrorsEnum } from 'types/provider.types';\nimport { BaseProviderStrategy } from '../BaseProviderStrategy/BaseProviderStrategy';\nimport { signMessage } from '../helpers/signMessage/signMessage';\n\nexport class ExtensionProviderStrategy extends BaseProviderStrategy {\n  private readonly provider: ExtensionProvider;\n\n  constructor(address?: string) {\n    super(address);\n    this.provider = ExtensionProvider.getInstance();\n    this._login = this.provider.login.bind(this.provider);\n  }\n\n  async init(): Promise<boolean> {\n    this.initializeAddress();\n    return this.initializeProvider();\n  }\n\n  private async initializeProvider() {\n    const initialized = await this.provider.init();\n\n    if (this.address) {\n      this.setAccount({ address: this.address });\n    }\n\n    return initialized;\n  }\n\n  getAddress(): Promise<string | undefined> {\n    return this.provider.getAddress();\n  }\n\n  setAccount(account: IDAppProviderAccount): void {\n    return this.provider.setAccount(account);\n  }\n\n  isInitialized(): boolean {\n    return this.provider.isInitialized();\n  }\n\n  logout(): Promise<boolean> {\n    return this.provider.logout();\n  }\n\n  getType(): ProviderType {\n    return ProviderTypeEnum.extension;\n  }\n\n  cancelAction = async () => {\n    this.provider.cancelAction();\n  };\n\n  signTransactions = async (transactions: Transaction[]) => {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    const { manager, onClose } = await this.initSignState();\n\n    try {\n      const signedTransactions: Transaction[] =\n        (await this.provider.signTransactions(transactions)) ?? [];\n\n      return signedTransactions;\n    } catch (error) {\n      await onClose({ shouldCancelAction: false });\n      throw error;\n    } finally {\n      manager.closeUI();\n    }\n  };\n\n  signMessage = async (message: Message) => {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    const signedMessage = await signMessage({\n      message,\n      handleSignMessage: this.provider.signMessage.bind(this.provider),\n      cancelAction: this.cancelAction,\n      providerType: providerLabels.extension\n    });\n\n    return signedMessage;\n  };\n}\n", "import { IframeLoginTypes } from '@multiversx/sdk-web-wallet-iframe-provider/out/constants';\n\nimport { providerLabels } from 'constants/providerFactory.constants';\nimport { Message, Transaction } from 'lib/sdkCore';\nimport { IDAppProviderAccount } from 'lib/sdkDappUtils';\nimport { IframeProvider } from 'lib/sdkWebWalletIframeProvider';\nimport {\n  ProviderTypeEnum,\n  ProviderType\n} from 'providers/types/providerFactory.types';\nimport { networkSelector } from 'store/selectors/networkSelectors';\nimport { getState } from 'store/store';\nimport { ProviderErrorsEnum } from 'types/provider.types';\nimport { IframeProviderType } from './types';\nimport { BaseProviderStrategy } from '../BaseProviderStrategy/BaseProviderStrategy';\nimport { signMessage } from '../helpers/signMessage/signMessage';\n\ntype IframeProviderStrategyType =\n  | typeof ProviderTypeEnum.passkey\n  | typeof ProviderTypeEnum.metamask;\n\nconst IFRAME_PROVIDER_MAP: Record<\n  IframeLoginTypes,\n  IframeProviderStrategyType\n> = {\n  passkey: ProviderTypeEnum.passkey,\n  metamask: ProviderTypeEnum.metamask\n};\n\nexport class IframeProviderStrategy extends BaseProviderStrategy {\n  private readonly provider: IframeProvider;\n  private readonly type: IframeLoginTypes;\n  private walletUrl: string;\n\n  constructor({ type, address, walletUrl }: IframeProviderType) {\n    super(address);\n    this.type = type;\n    this.walletUrl = walletUrl ?? '';\n    this.provider = IframeProvider.getInstance();\n    this._login = this.provider.login.bind(this.provider);\n  }\n\n  init(): Promise<boolean> {\n    this.initializeAddress();\n    this.initializeWalletUrl();\n    return this.initializeProvider();\n  }\n\n  private initializeWalletUrl() {\n    if (this.walletUrl) {\n      return;\n    }\n\n    const network = networkSelector(getState());\n\n    if (!network.iframeWalletAddress) {\n      throw new Error('Invalid walletUrl');\n    }\n\n    this.walletUrl = network.iframeWalletAddress;\n  }\n\n  private async initializeProvider() {\n    await this.provider.init();\n\n    if (this.address) {\n      this.setAccount({ address: this.address });\n    }\n\n    this.provider.setLoginType(this.type);\n    this.provider.setWalletUrl(this.walletUrl);\n\n    return true;\n  }\n\n  logout(): Promise<boolean> {\n    return this.provider.logout();\n  }\n\n  getType(): ProviderType {\n    return IFRAME_PROVIDER_MAP[this.type];\n  }\n\n  getAddress(): Promise<string | undefined> {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    return this.provider.getAddress();\n  }\n\n  setAccount(account: IDAppProviderAccount): void {\n    this.provider.setAccount(account);\n  }\n\n  isInitialized(): boolean {\n    return this.provider.isInitialized();\n  }\n\n  cancelAction = async () => {\n    this.provider.cancelAction();\n  };\n\n  signTransactions = async (transactions: Transaction[]) => {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    const { manager, onClose } = await this.initSignState();\n\n    try {\n      const signedTransactions: Transaction[] =\n        await this.provider.signTransactions(transactions);\n\n      return signedTransactions;\n    } catch (error) {\n      await onClose({ shouldCancelAction: true });\n      throw error;\n    } finally {\n      manager.closeUI();\n    }\n  };\n\n  signMessage = async (message: Message) => {\n    if (!this.provider || !this.type) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    const signedMessage = await signMessage({\n      message,\n      handleSignMessage: this.provider.signMessage.bind(this.provider),\n      cancelAction: this.cancelAction,\n      providerType: providerLabels[this.type]\n    });\n\n    return signedMessage;\n  };\n}\n", "import {\n  SessionEventTypes,\n  SessionTypes,\n  OptionalOperation\n} from '@multiversx/sdk-wallet-connect-provider/out';\nimport { providerLabels } from 'constants/providerFactory.constants';\nimport { fallbackWalletConnectConfigurations } from 'constants/walletConnect.constants';\nimport { Message, Transaction } from 'lib/sdkCore';\nimport { IDAppProviderAccount } from 'lib/sdkDappUtils';\nimport { WalletConnectStateManager } from 'managers/internal/WalletConnectStateManager/WalletConnectStateManager';\nimport { getIsLoggedIn } from 'methods/account/getIsLoggedIn';\nimport {\n  ProviderTypeEnum,\n  ProviderType\n} from 'providers/types/providerFactory.types';\nimport { logoutAction } from 'store/actions';\nimport { chainIdSelector, nativeAuthConfigSelector } from 'store/selectors';\nimport { getState } from 'store/store';\nimport { ProviderErrorsEnum } from 'types/provider.types';\nimport {\n  WalletConnectOptionalMethodsEnum,\n  WalletConnectV2Provider\n} from 'utils/walletconnect/__sdkWalletconnectProvider';\nimport { WalletConnectV2Error, WalletConnectConfig } from './types';\nimport { BaseProviderStrategy } from '../BaseProviderStrategy/BaseProviderStrategy';\nimport { signMessage } from '../helpers/signMessage/signMessage';\n\nconst dappMethods: string[] = [\n  WalletConnectOptionalMethodsEnum.CANCEL_ACTION,\n  WalletConnectOptionalMethodsEnum.SIGN_LOGIN_TOKEN\n];\n\ntype WalletConnectProviderStrategyConfigType = WalletConnectConfig & {\n  anchor?: HTMLElement;\n};\n\nexport class WalletConnectProviderStrategy extends BaseProviderStrategy {\n  private provider: WalletConnectV2Provider | null = null;\n  private readonly config: WalletConnectProviderStrategyConfigType;\n  private methods: string[] = [];\n  private _approval: (() => Promise<SessionTypes.Struct>) | null = null;\n  protected cancelActionAbortController: AbortController | null = null;\n\n  constructor(config: WalletConnectProviderStrategyConfigType) {\n    super();\n    this.config = config;\n  }\n\n  async init(): Promise<boolean> {\n    try {\n      await this.initializeProvider();\n    } catch {\n      return false;\n    }\n\n    return true;\n  }\n\n  logout(): Promise<boolean> {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    return this.provider.logout();\n  }\n\n  getType(): ProviderType {\n    return ProviderTypeEnum.walletConnect;\n  }\n\n  getAddress(): Promise<string | undefined> {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    return Promise.resolve(this.provider.getAddress());\n  }\n\n  setAccount(account: IDAppProviderAccount): void {\n    return this.provider?.setAccount(account);\n  }\n\n  isInitialized(): boolean {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    return this.provider.isInitialized();\n  }\n\n  private async initializeProvider() {\n    await this.initWalletConnectManager();\n\n    if (!this.config) {\n      throw new Error(WalletConnectV2Error.invalidConfig);\n    }\n\n    const { walletConnectProvider, dappMethods: dAppMethods } =\n      await this.createWalletConnectProvider(this.config);\n\n    this.provider = walletConnectProvider;\n    this.methods = dAppMethods;\n\n    const { uri = '', approval } = await this.provider.connect({\n      methods: this.methods\n    });\n\n    const walletConnectDeepLink =\n      this.config.walletConnectDeepLink ??\n      fallbackWalletConnectConfigurations.walletConnectDeepLink;\n\n    this._approval = approval;\n    const walletConnectManager = WalletConnectStateManager.getInstance();\n    walletConnectManager.updateData({\n      wcURI: uri,\n      walletConnectDeepLink: `${walletConnectDeepLink}?wallet-connect=${encodeURIComponent(uri)}`\n    });\n  }\n\n  private async initWalletConnectManager() {\n    const shouldInitiateLogin = !getIsLoggedIn();\n\n    if (!shouldInitiateLogin) {\n      return;\n    }\n\n    const walletConnectManager = WalletConnectStateManager.getInstance();\n    await walletConnectManager.init(this.config?.anchor);\n  }\n\n  private async createWalletConnectProvider(config: WalletConnectConfig) {\n    const isLoggedIn = getIsLoggedIn();\n    const chainId = chainIdSelector(getState());\n    const nativeAuthConfig = nativeAuthConfigSelector(getState());\n\n    if (nativeAuthConfig) {\n      dappMethods.push(WalletConnectOptionalMethodsEnum.SIGN_NATIVE_AUTH_TOKEN);\n    }\n\n    if (!config?.walletConnectV2ProjectId) {\n      throw new Error(WalletConnectV2Error.invalidConfig);\n    }\n\n    const handleOnLogin = () => {};\n\n    const handleOnLogout = () => {\n      logoutAction();\n    };\n\n    const handleOnEvent = (_event: SessionEventTypes['event']) => {};\n\n    const providerHandlers = {\n      onClientLogin: handleOnLogin,\n      onClientLogout: handleOnLogout,\n      onClientEvent: handleOnEvent\n    };\n\n    try {\n      const {\n        walletConnectV2ProjectId,\n        walletConnectV2Options = {},\n        walletConnectV2RelayAddress = ''\n      } = config;\n      const walletConnectProvider = new WalletConnectV2Provider(\n        providerHandlers,\n        chainId,\n        walletConnectV2RelayAddress,\n        walletConnectV2ProjectId,\n        walletConnectV2Options\n      );\n\n      await walletConnectProvider.init();\n\n      return { walletConnectProvider, dappMethods };\n    } catch (err) {\n      console.error(WalletConnectV2Error.connectError, err);\n\n      if (isLoggedIn) {\n        await this.logout();\n      }\n\n      throw err;\n    }\n  }\n\n  async login(options?: { token?: string }): Promise<{\n    address: string;\n    signature: string;\n  }> {\n    if (!this.provider) {\n      throw new Error(\n        'Provider is not initialized. Call createProvider first.'\n      );\n    }\n\n    const reconnect = async (): Promise<{\n      address: string;\n      signature: string;\n    }> => {\n      if (!this.provider) {\n        throw new Error(ProviderErrorsEnum.notInitialized);\n      }\n\n      try {\n        await this.provider.init();\n        const walletConnectManager = WalletConnectStateManager.getInstance();\n\n        const { uri = '', approval: wcApproval } = await this.provider.connect({\n          methods: this.methods\n        });\n\n        const walletConnectDeepLink =\n          this.config.walletConnectDeepLink ??\n          fallbackWalletConnectConfigurations.walletConnectDeepLink;\n\n        walletConnectManager.updateData({\n          wcURI: uri,\n          walletConnectDeepLink: `${walletConnectDeepLink}?wallet-connect=${encodeURIComponent(uri)}`\n        });\n\n        const providerInfo = await this.provider.login({\n          approval: wcApproval,\n          token: options?.token\n        });\n\n        const { address = '', signature = '' } = providerInfo ?? {};\n\n        walletConnectManager.handleClose({ isLoginFinished: Boolean(address) });\n        return { address, signature };\n      } catch {\n        return await reconnect();\n      }\n    };\n\n    if (!this._approval) {\n      throw new Error('Approval or login is not initialized');\n    }\n\n    try {\n      const providerData = await this.provider.login({\n        approval: this._approval.bind(this),\n        token: options?.token\n      });\n\n      const { address = '', signature = '' } = providerData ?? {};\n\n      const walletConnectManager = WalletConnectStateManager.getInstance();\n      walletConnectManager.handleClose({ isLoginFinished: Boolean(address) });\n      return { address, signature };\n    } catch (error) {\n      console.error(WalletConnectV2Error.userRejected, error);\n      return await reconnect();\n    }\n  }\n\n  signTransactions = async (transactions: Transaction[]) => {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    const { manager, onClose } = await this.initSignState();\n\n    this.cancelActionAbortController = new AbortController();\n    const signal = this.cancelActionAbortController.signal;\n\n    try {\n      const abortPromise = new Promise<never>((_, reject) => {\n        signal.addEventListener('abort', () => {\n          reject(new Error('cancelled by user'));\n        });\n      });\n\n      const signedTransactions: Transaction[] = await Promise.race([\n        this.provider.signTransactions(transactions),\n        abortPromise\n      ]);\n\n      return signedTransactions;\n    } catch (error) {\n      await onClose({ shouldCancelAction: true });\n      throw error;\n    } finally {\n      manager.closeUI();\n    }\n  };\n\n  cancelAction = async () => {\n    this.sendCustomRequest({\n      method: WalletConnectOptionalMethodsEnum.CANCEL_ACTION,\n      action: OptionalOperation.CANCEL_ACTION\n    });\n\n    this.cancelActionAbortController?.abort();\n  };\n\n  signMessage = async (message: Message) => {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    this.cancelActionAbortController = new AbortController();\n    const signal = this.cancelActionAbortController.signal;\n\n    const abortPromise = new Promise<never>((_, reject) => {\n      signal.addEventListener('abort', () => {\n        reject(new Error('cancelled by user'));\n      });\n    });\n\n    const signedMessage = await Promise.race([\n      signMessage({\n        message,\n        handleSignMessage: this.provider.signMessage.bind(this.provider),\n        cancelAction: this.cancelAction,\n        providerType: providerLabels.extension\n      }),\n      abortPromise\n    ]);\n\n    return signedMessage;\n  };\n\n  private async sendCustomRequest({\n    action,\n    method\n  }: {\n    action: OptionalOperation;\n    method: WalletConnectOptionalMethodsEnum;\n  }) {\n    if (!this.provider) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    try {\n      await this.provider.sendCustomRequest?.({\n        request: {\n          method,\n          params: { action }\n        }\n      });\n    } catch (error) {\n      console.error(WalletConnectV2Error.actionError, error);\n    }\n  }\n}\n", "import { providerLabels } from 'constants/providerFactory.constants';\nimport { Message } from 'lib/sdkCore';\nimport { PendingTransactionsEventsEnum } from 'managers/internal/PendingTransactionsStateManager/types/pendingTransactions.types';\nimport { ProviderFactory } from 'providers/ProviderFactory';\nimport {\n  ProviderType,\n  ProviderTypeEnum,\n  ICustomProvider\n} from 'providers/types/providerFactory.types';\nimport { SigningWarningsEnum } from 'types/enums.types';\nimport { getPendingTransactionsHandlers } from '../getPendingTransactionsHandlers';\n\ntype SignMessageWithModalPropsType<T> = {\n  message: Message;\n  handleSignMessage: (message: Message) => Promise<Message>;\n  cancelAction?: () => Promise<T> | undefined;\n  providerType: string;\n};\n\nconst isProviderType = (\n  allProviders: ICustomProvider[],\n  type: string\n): type is ProviderType =>\n  allProviders.some((provider) => provider.type === type);\n\nexport async function signMessage<T>({\n  message,\n  handleSignMessage,\n  cancelAction,\n  providerType\n}: SignMessageWithModalPropsType<T>): Promise<Message> {\n  const signedMsg = await new Promise<Awaited<Message>>(\n    async (resolve, reject) => {\n      const { manager, onClose } = await getPendingTransactionsHandlers({\n        cancelAction\n      });\n\n      const allProviders = Object.values(ProviderFactory.customProviders);\n      const allCustomProviderLabels = allProviders.reduce(\n        (acc, provider) => {\n          acc[provider.type] = provider.name;\n          return acc;\n        },\n        {} as Record<ProviderType, string>\n      );\n\n      const allProviderLabels = {\n        ...providerLabels,\n        ...allCustomProviderLabels\n      };\n\n      const handleClose = async () => {\n        await onClose({ shouldCancelAction: true });\n        reject({ message: SigningWarningsEnum.cancelled });\n      };\n\n      manager.subscribeToEventBus(\n        PendingTransactionsEventsEnum.CLOSE,\n        handleClose\n      );\n\n      const providerKey = isProviderType(allProviders, providerType)\n        ? providerType\n        : ProviderTypeEnum.none;\n\n      manager.updateData({\n        name: allProviderLabels[providerKey],\n        type: providerKey\n      });\n\n      try {\n        const signedMessage = await handleSignMessage(message);\n        resolve(signedMessage);\n      } catch (err) {\n        await onClose({ shouldCancelAction: true });\n        reject(err);\n      } finally {\n        manager.closeUI();\n      }\n    }\n  );\n  return signedMsg;\n}\n", "import { providerLabels } from 'constants/providerFactory.constants';\nimport { Message } from 'lib/sdkCore';\nimport { getLedgerErrorCodes } from './getLedgerErrorCodes';\nimport { signMessage } from '../../helpers/signMessage/signMessage';\n\nexport async function signLedgerMessage({\n  message,\n  handleSignMessage\n}: {\n  message: Message;\n  handleSignMessage: (msg: Message) => Promise<Message>;\n}): Promise<Message> {\n  try {\n    const signedMessage = await signMessage({\n      message,\n      handleSignMessage: handleSignMessage,\n      providerType: providerLabels.ledger\n    });\n    return signedMessage;\n  } catch (error) {\n    const { errorMessage } = getLedgerErrorCodes(error);\n    throw errorMessage ? { message: errorMessage } : error;\n  }\n}\n"],
  "mappings": "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",
  "names": ["IframeLoginTypes", "LedgerProviderStrategy", "BaseProviderStrategy", "address", "anchor", "shouldInitProvider", "options", "signature", "authenticateLedgerAccount", "getIsLoggedIn", "LedgerConnectStateManager", "transactions", "signTransactions", "message", "signLedgerMessage", "ledgerProvider", "getLedgerProvider", "error", "createCustomToast", "ProviderTypeEnum", "account", "ledgerConnectManager", "ledgerConfig", "resolve", "reject", "initializeLedgerProvider", "LEDGER_IDLE_STATE_CHECK_INTERVAL", "LEDGER_IDLE_STATE_RECONNECT_INTERVAL", "RECONNECT_SUCCESS_DURATION", "LedgerIdleStateManager", "_LedgerIdleStateManager", "getStore", "state", "providerType", "loginInfoSelector", "isLoggedIn", "isLoggedInSelector", "ProviderTypeEnum", "isSigningProcess", "isSidePanelOpenSelector", "getState", "getAccountProvider", "ToastManager", "createdProvider", "LedgerProviderStrategy", "dappProvider", "DappProvider", "setAccountProvider", "CrossWindowProviderStrategy", "BaseProviderStrategy", "config", "transactions", "onClose", "manager", "signedTransactions", "guardTransactions", "error", "message", "signMessage", "providerLabels", "CrossWindowProvider", "network", "networkSelector", "getState", "isProviderInitialized", "ProviderTypeEnum", "account", "ExtensionProvider", "ExtensionProviderStrategy", "BaseProviderStrategy", "address", "transactions", "manager", "onClose", "error", "message", "signMessage", "providerLabels", "ExtensionProvider", "initialized", "account", "ProviderTypeEnum", "IFRAME_PROVIDER_MAP", "ProviderTypeEnum", "IframeProviderStrategy", "BaseProviderStrategy", "type", "address", "walletUrl", "transactions", "manager", "onClose", "error", "message", "signMessage", "providerLabels", "IframeProvider", "network", "networkSelector", "getState", "account", "OptionalOperation", "dappMethods", "WalletConnectOptionalMethodsEnum", "WalletConnectProviderStrategy", "BaseProviderStrategy", "config", "transactions", "manager", "onClose", "signal", "abortPromise", "_", "reject", "error", "OptionalOperation", "message", "signMessage", "providerLabels", "ProviderTypeEnum", "account", "walletConnectProvider", "dAppMethods", "uri", "approval", "walletConnectDeepLink", "fallbackWalletConnectConfigurations", "WalletConnectStateManager", "getIsLoggedIn", "isLoggedIn", "chainId", "chainIdSelector", "getState", "nativeAuthConfigSelector", "providerHandlers", "logoutAction", "_event", "walletConnectV2ProjectId", "walletConnectV2Options", "walletConnectV2RelayAddress", "WalletConnectV2Provider", "err", "options", "reconnect", "walletConnectManager", "wcApproval", "providerInfo", "address", "signature", "providerData", "action", "method", "ProviderFactory", "providers", "type", "anchor", "createdProvider", "ProviderTypeEnum", "ExtensionProviderStrategy", "CrossWindowProviderStrategy", "LedgerProviderStrategy", "LedgerIdleStateManager", "IframeProviderStrategy", "IframeLoginTypes", "walletConnectConfig", "walletConnectConfigSelector", "getState", "WalletConnectProviderStrategy", "WebviewProviderStrategy", "address", "getAddress", "customProvider", "dappProvider", "DappProvider", "setAccountProvider", "shouldClearInitiatedLogins", "clearInitiatedLogins", "getAccountProvider", "setProviderType", "isProviderType", "allProviders", "type", "provider", "signMessage", "message", "handleSignMessage", "cancelAction", "providerType", "resolve", "reject", "manager", "onClose", "getPendingTransactionsHandlers", "ProviderFactory", "allCustomProviderLabels", "acc", "allProviderLabels", "providerLabels", "handleClose", "providerKey", "ProviderTypeEnum", "signedMessage", "err", "signLedgerMessage", "message", "handleSignMessage", "signMessage", "providerLabels", "error", "errorMessage", "getLedgerErrorCodes"]
}
