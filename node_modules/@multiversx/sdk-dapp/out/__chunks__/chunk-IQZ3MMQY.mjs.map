{
  "version": 3,
  "sources": ["../../src/managers/TransactionManager/TransactionManager.ts"],
  "sourcesContent": ["import axios, { AxiosError } from 'axios';\nimport { BATCH_TRANSACTIONS_ID_SEPARATOR } from 'constants/transactions.constants';\nimport { Transaction } from 'lib/sdkCore';\nimport { getAccount } from 'methods/account/getAccount';\nimport { TransactionTrackingConfigType } from 'methods/initApp/initApp.types';\nimport { addTransactionToast } from 'store/actions/toasts/toastsActions';\nimport { createTransactionsSession } from 'store/actions/transactions/transactionsActions';\nimport { networkSelector } from 'store/selectors';\nimport { getState } from 'store/store';\nimport {\n  TransactionBatchStatusesEnum,\n  TransactionServerStatusesEnum\n} from 'types/enums.types';\nimport { BatchTransactionsResponseType } from 'types/serverTransactions.types';\nimport { SignedTransactionType } from 'types/transactions.types';\nimport { isGuardianTx } from 'utils/transactions/isGuardianTx';\nimport { getToastDuration } from './helpers/getToastDuration';\nimport { getTransactionsSessionStatus } from './helpers/getTransactionsStatus';\nimport { isBatchTransaction } from './helpers/isBatchTransaction';\nimport { registerSessionCallbacks } from './helpers/sessionCallbacks';\nimport { TransactionManagerTrackOptionsType } from './TransactionManager.types';\n\nexport class TransactionManager {\n  private static instance: TransactionManager | null = null;\n\n  public static getInstance(): TransactionManager {\n    if (!TransactionManager.instance) {\n      TransactionManager.instance = new TransactionManager();\n    }\n    return TransactionManager.instance;\n  }\n\n  /**\n   * Set callbacks to be executed when the transaction session is successful or fails.\n   * @param onSuccess - The callback to run when the transaction session is successful.\n   * @param onFail - The callback to run when the transaction session fails.\n   * @example\n   * ```ts\n   * TransactionManager.setCallbacks({\n   *   onSuccess: (sessionId) => {\n   *     console.log('Transaction session successful', sessionId);\n   *   },\n   * });\n   */\n  public setCallbacks = ({\n    onSuccess,\n    onFail\n  }: TransactionTrackingConfigType) => {\n    registerSessionCallbacks({ onSuccess, onFail });\n  };\n\n  public send = async (\n    signedTransactions: Transaction[] | Transaction[][]\n  ): Promise<SignedTransactionType[] | SignedTransactionType[][]> => {\n    if (signedTransactions.length === 0) {\n      throw new Error('No transactions to send');\n    }\n\n    try {\n      if (!isBatchTransaction(signedTransactions)) {\n        const flatTransactions =\n          await this.sendSignedTransactions(signedTransactions);\n\n        return flatTransactions;\n      }\n\n      const sentTransactions =\n        await this.sendSignedBatchTransactions(signedTransactions);\n\n      if (!sentTransactions.data || sentTransactions.data.error) {\n        throw new Error(\n          sentTransactions.data?.error ?? 'Failed to send transactions'\n        );\n      }\n\n      const groupedTransactions = sentTransactions.data.transactions;\n\n      return groupedTransactions;\n    } catch (error) {\n      const responseData = <{ message: string }>(\n        (error as AxiosError).response?.data\n      );\n      throw responseData?.message ?? (error as Error).message;\n    }\n  };\n\n  public track = async (\n    sentTransactions: SignedTransactionType[] | SignedTransactionType[][],\n    options: TransactionManagerTrackOptionsType = { disableToasts: false }\n  ): Promise<string> => {\n    const flatTransactions = this.sequentialToFlatArray(sentTransactions).map(\n      (transaction) => ({\n        ...transaction,\n        status: transaction.status ?? TransactionServerStatusesEnum.pending\n      })\n    );\n\n    const status = getTransactionsSessionStatus(flatTransactions);\n\n    const sessionId = createTransactionsSession({\n      transactions: flatTransactions,\n      transactionsDisplayInfo: options.transactionsDisplayInfo,\n      status: status ?? TransactionBatchStatusesEnum.sent,\n      sessionInformation: options.sessionInformation\n    });\n\n    if (options.disableToasts === true) {\n      return sessionId;\n    }\n\n    const totalDuration = getToastDuration(sentTransactions);\n    addTransactionToast({\n      toastId: sessionId,\n      totalDuration\n    });\n\n    return sessionId;\n  };\n\n  private readonly sendSignedTransactions = async (\n    signedTransactions: Transaction[]\n  ): Promise<SignedTransactionType[]> => {\n    const { apiAddress, apiTimeout } = networkSelector(getState());\n\n    const mergedTransactions = await Promise.all(\n      signedTransactions.map(async (transaction) => {\n        const response = await axios.post(\n          `${apiAddress}/transactions`,\n          transaction.toPlainObject(),\n          { timeout: Number(apiTimeout) }\n        );\n\n        const txHash = response.data.txHash;\n\n        return {\n          ...transaction.toPlainObject(),\n          ...response.data,\n          status: TransactionServerStatusesEnum.pending,\n          hash: txHash\n        };\n      })\n    );\n\n    return mergedTransactions;\n  };\n\n  private readonly sendSignedBatchTransactions = async (\n    signedTransactions: Transaction[][]\n  ) => {\n    const { address } = getAccount();\n    const { apiAddress, apiTimeout } = networkSelector(getState());\n\n    if (!address) {\n      return {\n        error:\n          'Invalid address provided. You need to be logged in to send transactions'\n      };\n    }\n\n    const batchId = this.buildBatchId(address);\n\n    const plainTransactions = signedTransactions.map((group) =>\n      group.map((tx) => tx.toPlainObject())\n    );\n\n    const payload = {\n      transactions: plainTransactions,\n      id: batchId\n    };\n\n    const { data } = await axios.post<BatchTransactionsResponseType>(\n      `${apiAddress}/batch`,\n      payload,\n      {\n        timeout: Number(apiTimeout)\n      }\n    );\n\n    const parsedTransactions = data.transactions.map((group) =>\n      group.map((tx) => {\n        const parsedTx: SignedTransactionType = {\n          ...tx,\n          status: TransactionServerStatusesEnum.pending,\n          hash: tx.hash\n        };\n\n        // Remove when the protocol supports usernames for guardian transactions\n        if (isGuardianTx({ data: parsedTx.data })) {\n          delete parsedTx.senderUsername;\n          delete parsedTx.receiverUsername;\n        }\n\n        return parsedTx;\n      })\n    );\n\n    return {\n      data: {\n        ...data,\n        transactions: parsedTransactions\n      }\n    };\n  };\n\n  private readonly buildBatchId = (address: string) => {\n    const sessionId = Date.now().toString();\n    return `${sessionId}${BATCH_TRANSACTIONS_ID_SEPARATOR}${address}`;\n  };\n  private readonly sequentialToFlatArray = (\n    transactions: SignedTransactionType[] | SignedTransactionType[][] = []\n  ) =>\n    this.getIsSequential(transactions)\n      ? transactions.flat()\n      : (transactions as SignedTransactionType[]);\n\n  private readonly getIsSequential = (\n    transactions?: SignedTransactionType[] | SignedTransactionType[][]\n  ) => transactions?.every((transaction) => Array.isArray(transaction));\n}\n"],
  "mappings": "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",
  "names": ["axios", "_TransactionManager", "onSuccess", "onFail", "registerSessionCallbacks", "signedTransactions", "isBatchTransaction", "sentTransactions", "error", "options", "flatTransactions", "transaction", "status", "getTransactionsSessionStatus", "sessionId", "createTransactionsSession", "totalDuration", "getToastDuration", "addTransactionToast", "apiAddress", "apiTimeout", "networkSelector", "getState", "response", "axios", "txHash", "address", "getAccount", "batchId", "payload", "group", "tx", "data", "parsedTransactions", "parsedTx", "isGuardianTx", "BATCH_TRANSACTIONS_ID_SEPARATOR", "transactions", "TransactionManager"]
}
