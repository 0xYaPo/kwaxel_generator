import{a as ae}from"./chunk-G4Z3ZQR6.mjs";import{a as se}from"./chunk-M3YL36ZL.mjs";import{a as te}from"./chunk-SJI2GC55.mjs";import{a as U}from"./chunk-L2FIQYTN.mjs";import{a as ie}from"./chunk-AINUFDKG.mjs";import{a as re}from"./chunk-A4SG3QVX.mjs";import{a as I}from"./chunk-42TVUSAN.mjs";import{a as ee}from"./chunk-YUFPUG5O.mjs";import{a as de}from"./chunk-VJWOCVLK.mjs";import{a as p}from"./chunk-PWN5WOKL.mjs";import{a as Z}from"./chunk-73M7E2JA.mjs";import{a as ne}from"./chunk-7EBKBMO6.mjs";import{a as oe}from"./chunk-ADEF5DN6.mjs";import{a as Q}from"./chunk-QJGFIK7H.mjs";import{b as J}from"./chunk-4Z3DZ2A3.mjs";import{b as C,c as Y}from"./chunk-NRXYSTRW.mjs";import{j as $,l as O,r as M,s as P,t as L}from"./chunk-RHSQVMHN.mjs";import{a as y}from"./chunk-J27BEIYP.mjs";import{g as K}from"./chunk-CAA4VJRH.mjs";import{a as q}from"./chunk-5HL466PN.mjs";import{a as D}from"./chunk-4TBVQD27.mjs";import{a as X}from"./chunk-4E5NEWOF.mjs";import{a as F,q as j,s as l}from"./chunk-NKJSP5LJ.mjs";import{f as R}from"./chunk-UERJ6AKK.mjs";import{b as E,c as V}from"./chunk-SAAOQW7P.mjs";import{a as B}from"./chunk-VNLGNNIL.mjs";import{b as H,c as G}from"./chunk-6JM4DPOH.mjs";import{a as c}from"./chunk-CDQ2BNUD.mjs";import{a as o}from"./chunk-PLUWBWJ2.mjs";import{IframeLoginTypes as pe}from"@multiversx/sdk-web-wallet-iframe-provider/out/constants";var f=class extends p{constructor({address:e,anchor:r,shouldInitProvider:t}){super(e);this.provider=null;this.config=null;this.ledgerLogin=async e=>{if(!this.provider)throw new Error("Provider is not initialized.");if(!e||typeof e.addressIndex!="number")throw new Error("Missing addressIndex for Ledger login");let{address:r,signature:t}=await this.provider.login({addressIndex:e.addressIndex});return{address:r,signature:t??""}};this.loginOperation=async e=>{if(!this.provider||!this.config)throw new Error("Provider is not initialized.");return await te({options:e,config:this.config,provider:this.provider,login:this.ledgerLogin.bind(this)})};this.initLegderConnectManager=async e=>{if(!!I())return;await U.getInstance().init(e)};this.signTransactions=async e=>{if(!this.provider)throw new Error("Provider is not initialized.");return await this.rebuildProvider(),await ne({transactions:e,handleSign:this.provider.signTransactions.bind(this.provider)})};this.signMessage=async e=>{if(!this.provider)throw new Error("Provider is not initialized.");return await this.rebuildProvider(),await ce({message:e,handleSignMessage:this.provider.signMessage.bind(this.provider)})};this.rebuildProvider=async()=>{try{await this.provider?.getAddress()}catch{try{let{ledgerProvider:r}=await re({shouldInitProvider:!0});this.provider=r}catch(r){throw $({toastId:"ledger-provider-rebuild-error",duration:1e4,icon:"times",iconClassName:"warning",message:"Unlock your device & open the MultiversX App",title:"Ledger unavailable"}),r}}};this.options={anchor:r,shouldInitProvider:t},this._login=this.ledgerLogin.bind(this)}async init(){try{this.initializeAddress(),await this.initializeProvider()}catch{return!1}return!0}logout(){if(!this.provider)throw new Error("Provider is not initialized.");return this.provider.logout()}getType(){return o.ledger}getAddress(){if(!this.provider)throw new Error("Provider is not initialized.");return this.provider.getAddress()}setAccount(e){return this.provider?.setAccount(e)}isInitialized(){if(!this.provider)throw new Error("Provider is not initialized.");return this.provider.isInitialized()}async initializeProvider(){await this.initLegderConnectManager(this.options?.anchor);let e=U.getInstance(),{ledgerProvider:r,ledgerConfig:t}=await new Promise((n,s)=>ie({manager:e,resolve:n,reject:s,shouldInitProvider:this.options?.shouldInitProvider}));this.config=t,this.provider=r}};var ve=3e4,me=5e3,he=3e3,S=class a{constructor(){this.store=j();this.connectionCheckInterval=null;this.recreateProviderInterval=null;this.init=async()=>{this.startCheckConnectionLoop()};this.shouldCheckConnection=()=>{let i=this.store.getState(),{providerType:e}=B(i),r=R(i);return!!(e===o.ledger&&r)};this.startCheckConnectionLoop=()=>{this.connectionCheckInterval||(this.connectionCheckInterval=setInterval(async()=>{let i=J(l());if(!(!this.shouldCheckConnection()||i))try{await L().getProvider().getAddress()}catch{if(O.getInstance().createCustomToast({toastId:"ledger-provider-idle-warning",icon:"times",iconClassName:"warning",message:"Unlock your device to continue signing transactions",title:"Ledger disconnected"}),this.reset(),this.recreateProviderInterval)return;this.recreateProviderInterval=setInterval(this.reconnectProvider,me)}},ve))};this.reconnectProvider=async()=>{if(this.shouldCheckConnection())try{let i=new f({shouldInitProvider:!0});await i.init();let e=new M(i);i.getType=()=>o.ledger,P(e),this.reset(),clearInterval(this.recreateProviderInterval??0),this.recreateProviderInterval=null,O.getInstance().createCustomToast({toastId:"ledger-provider-idle-warning",duration:he,icon:"check",iconClassName:"success",message:"Your device is ready to sign transactions",title:"Ledger reconnected"}),this.startCheckConnectionLoop()}catch{console.log("Unable to reconnect to Ledger")}};this.reset=()=>{clearInterval(this.connectionCheckInterval??0),this.connectionCheckInterval=null}}static getInstance(){return a.instance||(a.instance=new a),a.instance}};var k=class extends p{constructor(e){super(e?.address);this.cancelAction=async()=>{this.provider.cancelAction()};this.signTransactions=async e=>{if(!this.provider)throw new Error("Provider is not initialized.");let{onClose:r,manager:t}=await this.initSignState();try{let n=await this.provider.signTransactions(e)??[];return await oe(n)}catch(n){throw await r({shouldCancelAction:!0}),n}finally{t.closeUI()}};this.signMessage=async e=>{if(!this.provider)throw new Error("Provider is not initialized.");return await g({message:e,handleSignMessage:this.provider.signMessage.bind(this.provider),cancelAction:this.cancelAction,providerType:c.crossWindow})};this.walletAddress=e?.walletAddress,this.provider=Q.getInstance(),this._login=this.provider.login.bind(this.provider)}async init(){return this.initializeAddress(),this.initializeProvider()}async initializeProvider(){let e=E(l()),r=await this.provider.init();return this.provider.setWalletUrl(this.walletAddress??e.walletAddress),this.address&&this.provider.setAddress(this.address),r}logout(){return this.provider.logout()}getType(){return o.crossWindow}getAddress(){if(!this.provider)throw new Error("Provider is not initialized.");return this.provider.getAddress()}setAccount(e){return this.provider.setAccount(e)}isInitialized(){return this.provider.isInitialized()}};import{ExtensionProvider as ue}from"@multiversx/sdk-extension-provider/out/extensionProvider";var z=class extends p{constructor(e){super(e);this.cancelAction=async()=>{this.provider.cancelAction()};this.signTransactions=async e=>{if(!this.provider)throw new Error("Provider is not initialized.");let{manager:r,onClose:t}=await this.initSignState();try{return await this.provider.signTransactions(e)??[]}catch(n){throw await t({shouldCancelAction:!1}),n}finally{r.closeUI()}};this.signMessage=async e=>{if(!this.provider)throw new Error("Provider is not initialized.");return await g({message:e,handleSignMessage:this.provider.signMessage.bind(this.provider),cancelAction:this.cancelAction,providerType:c.extension})};this.provider=ue.getInstance(),this._login=this.provider.login.bind(this.provider)}async init(){return this.initializeAddress(),this.initializeProvider()}async initializeProvider(){let e=await this.provider.init();return this.address&&this.setAccount({address:this.address}),e}getAddress(){return this.provider.getAddress()}setAccount(e){return this.provider.setAccount(e)}isInitialized(){return this.provider.isInitialized()}logout(){return this.provider.logout()}getType(){return o.extension}};var fe={passkey:o.passkey,metamask:o.metamask},T=class extends p{constructor({type:e,address:r,walletUrl:t}){super(r);this.cancelAction=async()=>{this.provider.cancelAction()};this.signTransactions=async e=>{if(!this.provider)throw new Error("Provider is not initialized.");let{manager:r,onClose:t}=await this.initSignState();try{return await this.provider.signTransactions(e)}catch(n){throw await t({shouldCancelAction:!0}),n}finally{r.closeUI()}};this.signMessage=async e=>{if(!this.provider||!this.type)throw new Error("Provider is not initialized.");return await g({message:e,handleSignMessage:this.provider.signMessage.bind(this.provider),cancelAction:this.cancelAction,providerType:c[this.type]})};this.type=e,this.walletUrl=t??"",this.provider=se.getInstance(),this._login=this.provider.login.bind(this.provider)}init(){return this.initializeAddress(),this.initializeWalletUrl(),this.initializeProvider()}initializeWalletUrl(){if(this.walletUrl)return;let e=E(l());if(!e.iframeWalletAddress)throw new Error("Invalid walletUrl");this.walletUrl=e.iframeWalletAddress}async initializeProvider(){return await this.provider.init(),this.address&&this.setAccount({address:this.address}),this.provider.setLoginType(this.type),this.provider.setWalletUrl(this.walletUrl),!0}logout(){return this.provider.logout()}getType(){return fe[this.type]}getAddress(){if(!this.provider)throw new Error("Provider is not initialized.");return this.provider.getAddress()}setAccount(e){this.provider.setAccount(e)}isInitialized(){return this.provider.isInitialized()}};import{OptionalOperation as ye}from"@multiversx/sdk-wallet-connect-provider/out";var le=[C.CANCEL_ACTION,C.SIGN_LOGIN_TOKEN],_=class extends p{constructor(e){super();this.provider=null;this.methods=[];this._approval=null;this.cancelActionAbortController=null;this.signTransactions=async e=>{if(!this.provider)throw new Error("Provider is not initialized.");let{manager:r,onClose:t}=await this.initSignState();this.cancelActionAbortController=new AbortController;let n=this.cancelActionAbortController.signal;try{let s=new Promise((h,v)=>{n.addEventListener("abort",()=>{v(new Error("cancelled by user"))})});return await Promise.race([this.provider.signTransactions(e),s])}catch(s){throw await t({shouldCancelAction:!0}),s}finally{r.closeUI()}};this.cancelAction=async()=>{this.sendCustomRequest({method:C.CANCEL_ACTION,action:ye.CANCEL_ACTION}),this.cancelActionAbortController?.abort()};this.signMessage=async e=>{if(!this.provider)throw new Error("Provider is not initialized.");this.cancelActionAbortController=new AbortController;let r=this.cancelActionAbortController.signal,t=new Promise((s,d)=>{r.addEventListener("abort",()=>{d(new Error("cancelled by user"))})});return await Promise.race([g({message:e,handleSignMessage:this.provider.signMessage.bind(this.provider),cancelAction:this.cancelAction,providerType:c.extension}),t])};this.config=e}async init(){try{await this.initializeProvider()}catch{return!1}return!0}logout(){if(!this.provider)throw new Error("Provider is not initialized.");return this.provider.logout()}getType(){return o.walletConnect}getAddress(){if(!this.provider)throw new Error("Provider is not initialized.");return Promise.resolve(this.provider.getAddress())}setAccount(e){return this.provider?.setAccount(e)}isInitialized(){if(!this.provider)throw new Error("Provider is not initialized.");return this.provider.isInitialized()}async initializeProvider(){if(await this.initWalletConnectManager(),!this.config)throw new Error("Invalid WalletConnect setup");let{walletConnectProvider:e,dappMethods:r}=await this.createWalletConnectProvider(this.config);this.provider=e,this.methods=r;let{uri:t="",approval:n}=await this.provider.connect({methods:this.methods}),s=this.config.walletConnectDeepLink??D.walletConnectDeepLink;this._approval=n,y.getInstance().updateData({wcURI:t,walletConnectDeepLink:`${s}?wallet-connect=${encodeURIComponent(t)}`})}async initWalletConnectManager(){if(!!I())return;await y.getInstance().init(this.config?.anchor)}async createWalletConnectProvider(e){let r=I(),t=V(l());if(H(l())&&le.push(C.SIGN_NATIVE_AUTH_TOKEN),!e?.walletConnectV2ProjectId)throw new Error("Invalid WalletConnect setup");let v={onClientLogin:()=>{},onClientLogout:()=>{X()},onClientEvent:m=>{}};try{let{walletConnectV2ProjectId:m,walletConnectV2Options:x={},walletConnectV2RelayAddress:W=""}=e,w=new Y(v,t,W,m,x);return await w.init(),{walletConnectProvider:w,dappMethods:le}}catch(m){throw console.error("Unable to connect",m),r&&await this.logout(),m}}async login(e){if(!this.provider)throw new Error("Provider is not initialized. Call createProvider first.");let r=async()=>{if(!this.provider)throw new Error("Provider is not initialized.");try{await this.provider.init();let t=y.getInstance(),{uri:n="",approval:s}=await this.provider.connect({methods:this.methods}),d=this.config.walletConnectDeepLink??D.walletConnectDeepLink;t.updateData({wcURI:n,walletConnectDeepLink:`${d}?wallet-connect=${encodeURIComponent(n)}`});let h=await this.provider.login({approval:s,token:e?.token}),{address:v="",signature:m=""}=h??{};return t.handleClose({isLoginFinished:!!v}),{address:v,signature:m}}catch{return await r()}};if(!this._approval)throw new Error("Approval or login is not initialized");try{let t=await this.provider.login({approval:this._approval.bind(this),token:e?.token}),{address:n="",signature:s=""}=t??{};return y.getInstance().handleClose({isLoginFinished:!!n}),{address:n,signature:s}}catch(t){return console.error("User rejected connection proposal",t),await r()}}async sendCustomRequest({action:e,method:r}){if(!this.provider)throw new Error("Provider is not initialized.");try{await this.provider.sendCustomRequest?.({request:{method:r,params:{action:e}}})}catch(t){console.error("Unable to send event",t)}}};var A=class{static set customProviders(i){this._customProviders=i}static get customProviders(){return this._customProviders}static async create({type:i,anchor:e}){let r=null;switch(i){case o.extension:{r=new z;break}case o.crossWindow:{r=new k;break}case o.ledger:{r=new f({anchor:e}),await S.getInstance().init();break}case o.metamask:{r=new T({type:pe.metamask});break}case o.passkey:{r=new T({type:pe.passkey});break}case o.walletConnect:{let s=G(l());if(!s?.walletConnectV2ProjectId)throw new Error("Invalid WalletConnect setup");r=new _({anchor:e,...s});break}case o.webview:{r=new de;break}default:{let s=q();for(let d of this._customProviders)d.type===i&&(r=await d.constructor({address:s,anchor:e}));break}}if(!r)throw new Error("Unable to create provider");await r.init();let t=new M(r);P(t);let n=[o.crossWindow,o.metamask,o.passkey].includes(i);return ae(n?{skipLoginMethod:i}:null),t}static async destroy(){L().cancelLogin(),P(null),F(o.none)}};A._customProviders=[];var Pe=(a,i)=>a.some(e=>e.type===i);async function g({message:a,handleSignMessage:i,cancelAction:e,providerType:r}){return await new Promise(async(n,s)=>{let{manager:d,onClose:h}=await Z({cancelAction:e}),v=Object.values(A.customProviders),m=v.reduce((u,N)=>(u[N.type]=N.name,u),{}),x={...c,...m},W=async()=>{await h({shouldCancelAction:!0}),s({message:"Signing canceled"})};d.subscribeToEventBus("CLOSE_PENDING_TRANSACTIONS",W);let w=Pe(v,r)?r:o.none;d.updateData({name:x[w],type:w});try{let u=await i(a);n(u)}catch(u){await h({shouldCancelAction:!0}),s(u)}finally{d.closeUI()}})}async function ce({message:a,handleSignMessage:i}){try{return await g({message:a,handleSignMessage:i,providerType:c.ledger})}catch(e){let{errorMessage:r}=ee(e);throw r?{message:r}:e}}export{ce as a,f as b,S as c,A as d,g as e,k as f,z as g,T as h,_ as i};
//# sourceMappingURL=chunk-EN4H5FPE.mjs.map
