{
  "version": 3,
  "sources": ["../../src/utils/window/matchPath.ts"],
  "sourcesContent": ["// credits go to: https://remix.run\n// sourcecode: https://raw.githubusercontent.com/remix-run/react-router/6b44e99f0b659428ce2ec8d5098e90c7fddda2c5/packages/react-router/lib/router.ts\n\nfunction warning(cond: any, message: string): void {\n  if (!cond) {\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty, @typescript-eslint/no-unused-vars\n    } catch (error) {}\n  }\n}\n\ntype ParamParseFailed = { failed: true };\n\ntype ParamParseSegment<Segment extends string> =\n  // Check here if there exists a forward slash in the string.\n\n  Segment extends `${infer LeftSegment}/${infer RightSegment}`\n    ? // If there is a forward slash, then attempt to parse each side of the\n      // forward slash.\n      ParamParseSegment<LeftSegment> extends infer LeftResult\n      ? ParamParseSegment<RightSegment> extends infer RightResult\n        ? LeftResult extends string\n          ? // If the left side is successfully parsed as a param, then check if\n            // the right side can be successfully parsed as well. If both sides\n            // can be parsed, then the result is a union of the two sides\n            // (read: \"foo\" | \"bar\").\n            RightResult extends string\n            ? LeftResult | RightResult\n            : LeftResult\n          : // If the left side is not successfully parsed as a param, then check\n            // if only the right side can be successfully parse as a param. If it\n            // can, then the result is just right, else it's a failure.\n            RightResult extends string\n            ? RightResult\n            : ParamParseFailed\n        : ParamParseFailed\n      : // If the left side didn't parse into a param, then just check the right\n        // side.\n        ParamParseSegment<RightSegment> extends infer RightResult\n        ? RightResult extends string\n          ? RightResult\n          : ParamParseFailed\n        : ParamParseFailed\n    : // If there's no forward slash, then check if this segment starts with a\n      // colon. If it does, then this is a dynamic segment, so the result is\n      // just the remainder of the string. Otherwise, it's a failure.\n      Segment extends `:${infer Remaining}`\n      ? Remaining\n      : ParamParseFailed;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\ntype ParamParseKey<Segment extends string> =\n  ParamParseSegment<Segment> extends string\n    ? ParamParseSegment<Segment>\n    : string;\n\n/**\n * The parameters that were parsed from the URL path.\n */\ntype Params<Key extends string = string> = {\n  readonly [_key in Key]: string | undefined;\n};\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\ninterface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\ninterface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/match-path\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === 'string') {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  const [matcher, paramNames] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  const match = pathname.match(matcher);\n  if (!match) {\n    return null;\n  }\n\n  const matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, '$1');\n  const captureGroups = match.slice(1);\n  const params: Params = paramNames.reduce<Mutable<Params>>(\n    (memo, paramName, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === '*') {\n        const splatValue = captureGroups[index] || '';\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, '$1');\n      }\n\n      memo[paramName] = safelyDecodeURIComponent(\n        captureGroups[index] || '',\n        paramName\n      );\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, string[]] {\n  warning(\n    path === '*' || !path.endsWith('*') || path.endsWith('/*'),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, '/*')}\" because the \\`*\\` character must ` +\n      'always follow a `/` in the pattern. To get rid of this warning, ' +\n      `please change the route path to \"${path.replace(/\\*$/, '/*')}\".`\n  );\n\n  const paramNames: string[] = [];\n  let regexpSource =\n    '^' +\n    path\n      .replace(/\\/*\\*?$/, '') // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, '/') // Make sure it has a leading /\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, '\\\\$&') // Escape special regex chars\n      .replace(/:(\\w+)/g, (_: string, paramName: string) => {\n        paramNames.push(paramName);\n        return '([^\\\\/]+)';\n      });\n\n  if (path.endsWith('*')) {\n    paramNames.push('*');\n    regexpSource +=\n      path === '*' || path === '/*'\n        ? '(.*)$' // Already matched the initial /, just match the rest\n        : '(?:\\\\/(.+)|\\\\/*)$'; // Don't include the / in params[\"*\"]\n  } else {\n    regexpSource += end\n      ? '\\\\/*$' // When matching to the end, ignore trailing slashes\n      : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts\n        // parent routes to matching only their own words and nothing more, e.g. parent\n        // route \"/home\" should not match \"/home2\".\n        // Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,\n        // but do not consume the character in the matched path so they can match against\n        // nested paths.\n        '(?:(?=[.~-]|%[0-9A-F]{2})|\\\\b|\\\\/|$)';\n  }\n\n  const matcher = new RegExp(regexpSource, caseSensitive ? undefined : 'i');\n\n  return [matcher, paramNames];\n}\n\nfunction safelyDecodeURIComponent(value: string, paramName: string) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n"],
  "mappings": "AAGA,SAASA,EAAQC,EAAWC,EAAuB,CACjD,GAAI,CAACD,EAAM,CACL,OAAO,QAAY,KACrB,QAAQ,KAAKC,CAAO,EAGtB,GAAI,CAMF,MAAM,IAAI,MAAMA,CAAO,CAEzB,MAAgB,CAAC,CACnB,CACF,CA6GO,SAASC,EAIdC,EACAC,EAC4B,CACxB,OAAOD,GAAY,WACrBA,EAAU,CAAE,KAAMA,EAAS,cAAe,GAAO,IAAK,EAAK,GAG7D,GAAM,CAACE,EAASC,CAAU,EAAIC,EAC5BJ,EAAQ,KACRA,EAAQ,cACRA,EAAQ,GACV,EAEMK,EAAQJ,EAAS,MAAMC,CAAO,EACpC,GAAI,CAACG,EACH,OAAO,KAGT,IAAMC,EAAkBD,EAAM,CAAC,EAC3BE,EAAeD,EAAgB,QAAQ,UAAW,IAAI,EACpDE,EAAgBH,EAAM,MAAM,CAAC,EAqBnC,MAAO,CACL,OArBqBF,EAAW,OAChC,CAACM,EAAMC,EAAWC,IAAU,CAG1B,GAAID,IAAc,IAAK,CACrB,IAAME,EAAaJ,EAAcG,CAAK,GAAK,GAC3CJ,EAAeD,EACZ,MAAM,EAAGA,EAAgB,OAASM,EAAW,MAAM,EACnD,QAAQ,UAAW,IAAI,CAC5B,CAEA,OAAAH,EAAKC,CAAS,EAAIG,EAChBL,EAAcG,CAAK,GAAK,GACxBD,CACF,EACOD,CACT,EACA,CAAC,CACH,EAIE,SAAUH,EACV,aAAAC,EACA,QAAAP,CACF,CACF,CAEA,SAASI,EACPU,EACAC,EAAgB,GAChBC,EAAM,GACc,CACpBpB,EACEkB,IAAS,KAAO,CAACA,EAAK,SAAS,GAAG,GAAKA,EAAK,SAAS,IAAI,EACzD,eAAeA,CAAI,oCACbA,EAAK,QAAQ,MAAO,IAAI,CAAC,yIAEOA,EAAK,QAAQ,MAAO,IAAI,CAAC,IACjE,EAEA,IAAMX,EAAuB,CAAC,EAC1Bc,EACF,IACAH,EACG,QAAQ,UAAW,EAAE,EACrB,QAAQ,OAAQ,GAAG,EACnB,QAAQ,sBAAuB,MAAM,EACrC,QAAQ,UAAW,CAACI,EAAWR,KAC9BP,EAAW,KAAKO,CAAS,EAClB,YACR,EAEL,OAAII,EAAK,SAAS,GAAG,GACnBX,EAAW,KAAK,GAAG,EACnBc,GACEH,IAAS,KAAOA,IAAS,KACrB,QACA,qBAENG,GAAgBD,EACZ,QAOA,uCAKC,CAFS,IAAI,OAAOC,EAAcF,EAAgB,OAAY,GAAG,EAEvDZ,CAAU,CAC7B,CAEA,SAASU,EAAyBM,EAAeT,EAAmB,CAClE,GAAI,CACF,OAAO,mBAAmBS,CAAK,CACjC,OAASC,EAAO,CACd,OAAAxB,EACE,GACA,gCAAgCc,CAAS,6CACvBS,CAAK,iFACcC,CAAK,IAC5C,EAEOD,CACT,CACF",
  "names": ["warning", "cond", "message", "matchPath", "pattern", "pathname", "matcher", "paramNames", "compilePath", "match", "matchedPathname", "pathnameBase", "captureGroups", "memo", "paramName", "index", "splatValue", "safelyDecodeURIComponent", "path", "caseSensitive", "end", "regexpSource", "_", "value", "error"]
}
