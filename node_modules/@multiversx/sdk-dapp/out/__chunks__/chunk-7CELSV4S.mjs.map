{
  "version": 3,
  "sources": ["../../src/utils/validation/isContract.ts"],
  "sourcesContent": ["import { Address } from 'lib/sdkCore';\nimport { ESDTTransferTypesEnum, TypesOfSmartContractCallsEnum } from 'types';\nimport { isStringBase64 } from 'utils/decoders/base64Utils';\nimport { addressIsValid } from './addressIsValid';\nimport { isHexValidCharacters, isHexValidLength } from './hex';\n\nexport function isContract(\n  receiver: string,\n  sender?: string,\n  data = ''\n): boolean {\n  const isValid = addressIsValid(receiver);\n\n  if (!isValid) {\n    return false;\n  }\n\n  const isContractAddress = new Address(receiver).isSmartContract();\n\n  if (isContractAddress) {\n    return true;\n  }\n\n  const extractedAddress = getAddressFromDataField({ receiver, data });\n\n  if (!extractedAddress) {\n    return false;\n  }\n\n  const isExtractedAddressContractCall = new Address(\n    extractedAddress\n  ).isSmartContract();\n\n  return (\n    isExtractedAddressContractCall || isSelfESDTContract(receiver, sender, data)\n  );\n}\n\nexport function isSelfESDTContract(\n  receiver: string,\n  sender?: string,\n  data?: string\n) {\n  const parts = data?.split('@');\n  if (parts == null) {\n    return false;\n  }\n  const [type, ...restParts] = parts;\n  const isSelfTransaction =\n    sender != null && receiver != null && receiver === sender;\n  const isCorrectESDTType = Object.values(ESDTTransferTypesEnum).includes(\n    type as ESDTTransferTypesEnum\n  );\n  const areDataPartsValid = restParts.every(\n    (part) => isHexValidCharacters(part) && isHexValidLength(part)\n  );\n  return isSelfTransaction && isCorrectESDTType && areDataPartsValid;\n}\n\nexport function getAddressFromDataField({\n  receiver,\n  data\n}: {\n  receiver: string;\n  data: string;\n}) {\n  try {\n    if (!data) {\n      return receiver;\n    }\n    const parsedData = isStringBase64(data)\n      ? Buffer.from(data, 'base64').toString()\n      : data;\n\n    const addressIndex = getAddressIndex(parsedData);\n\n    const parts = parsedData.split('@');\n    return addressIndex > -1 ? parts[addressIndex] : receiver;\n  } catch (err) {\n    console.log(err);\n    return;\n  }\n}\n\nfunction getAddressIndex(data: string) {\n  if (data.includes(TypesOfSmartContractCallsEnum.MultiESDTNFTTransfer)) {\n    return 1;\n  }\n  if (data.includes(TypesOfSmartContractCallsEnum.ESDTNFTTransfer)) {\n    return 4;\n  }\n  return -1;\n}\n"],
  "mappings": "oNAMO,SAASA,EACdC,EACAC,EACAC,EAAO,GACE,CAGT,GAAI,CAFYC,EAAeH,CAAQ,EAGrC,MAAO,GAKT,GAF0B,IAAII,EAAQJ,CAAQ,EAAE,gBAAgB,EAG9D,MAAO,GAGT,IAAMK,EAAmBC,EAAwB,CAAE,SAAAN,EAAU,KAAAE,CAAK,CAAC,EAEnE,OAAKG,EAIkC,IAAID,EACzCC,CACF,EAAE,gBAAgB,GAGkBE,EAAmBP,EAAUC,EAAQC,CAAI,EARpE,EAUX,CAEO,SAASK,EACdP,EACAC,EACAC,EACA,CACA,IAAMM,EAAQN,GAAM,MAAM,GAAG,EAC7B,GAAIM,GAAS,KACX,MAAO,GAET,GAAM,CAACC,EAAM,GAAGC,CAAS,EAAIF,EACvBG,EACJV,GAAU,MAAQD,GAAY,MAAQA,IAAaC,EAC/CW,EAAoB,OAAO,OAAOC,CAAqB,EAAE,SAC7DJ,CACF,EACMK,EAAoBJ,EAAU,MACjCK,GAASC,EAAqBD,CAAI,GAAKE,EAAiBF,CAAI,CAC/D,EACA,OAAOJ,GAAqBC,GAAqBE,CACnD,CAEO,SAASR,EAAwB,CACtC,SAAAN,EACA,KAAAE,CACF,EAGG,CACD,GAAI,CACF,GAAI,CAACA,EACH,OAAOF,EAET,IAAMkB,EAAaC,EAAejB,CAAI,EAClC,OAAO,KAAKA,EAAM,QAAQ,EAAE,SAAS,EACrCA,EAEEkB,EAAeC,EAAgBH,CAAU,EAEzCV,EAAQU,EAAW,MAAM,GAAG,EAClC,OAAOE,EAAe,GAAKZ,EAAMY,CAAY,EAAIpB,CACnD,OAASsB,EAAK,CACZ,QAAQ,IAAIA,CAAG,EACf,MACF,CACF,CAEA,SAASD,EAAgBnB,EAAc,CACrC,OAAIA,EAAK,+BAA2D,EAC3D,EAELA,EAAK,0BAAsD,EACtD,EAEF,EACT",
  "names": ["isContract", "receiver", "sender", "data", "addressIsValid", "Address", "extractedAddress", "getAddressFromDataField", "isSelfESDTContract", "parts", "type", "restParts", "isSelfTransaction", "isCorrectESDTType", "ESDTTransferTypesEnum", "areDataPartsValid", "part", "isHexValidCharacters", "isHexValidLength", "parsedData", "isStringBase64", "addressIndex", "getAddressIndex", "err"]
}
