{
  "version": 3,
  "sources": ["../../src/methods/trackTransactions/helpers/checkTransactionStatus/checkBatch.ts"],
  "sourcesContent": ["import { getTransactionsByHashes } from 'apiCalls/transactions/getTransactionsByHashes';\nimport {\n  updateTransactionStatus,\n  updateSessionStatus\n} from 'store/actions/transactions/transactionsActions';\nimport { getIsTransactionFailed } from 'store/actions/transactions/transactionStateByStatus';\nimport {\n  TransactionBatchStatusesEnum,\n  TransactionServerStatusesEnum\n} from 'types/enums.types';\nimport {\n  TrackedTransactionResultType,\n  SignedTransactionType\n} from 'types/transactions.types';\n\nimport { getPendingTransactions } from './getPendingTransactions';\nimport { manageFailedTransactions } from './manageFailedTransactions';\nimport { runSessionCallbacks } from './runSessionCallbacks';\n\nexport interface TransactionStatusTrackerPropsType {\n  sessionId: string;\n  transactionBatch: SignedTransactionType[];\n  isSequential?: boolean;\n}\n\ninterface RetriesType {\n  [hash: string]: number;\n}\n\nconst retries: RetriesType = {};\n\ninterface ManageTransactionType {\n  serverTransaction: TrackedTransactionResultType;\n  sessionId: string;\n  isSequential?: boolean;\n}\n\nasync function manageTransaction({\n  serverTransaction: transaction,\n  sessionId,\n  isSequential\n}: ManageTransactionType) {\n  const { hash, status, results, invalidTransaction, hasStatusChanged } =\n    transaction;\n  try {\n    const retriesForThisHash = retries[hash];\n    if (retriesForThisHash > 30) {\n      // consider transaction as stuck after 1 minute\n      updateSessionStatus({\n        sessionId,\n        status: TransactionBatchStatusesEnum.timedOut\n      });\n\n      await runSessionCallbacks({\n        sessionId,\n        status: TransactionBatchStatusesEnum.timedOut\n      });\n\n      return;\n    }\n\n    if (\n      (invalidTransaction && !isSequential) ||\n      status === TransactionBatchStatusesEnum.sent\n    ) {\n      retries[hash] = retries[hash] ? retries[hash] + 1 : 1;\n      return;\n    }\n\n    // The tx is from a sequential batch.\n    // If the transactions before this are not successful then it means that no other tx will be processed\n    if (isSequential && !status) {\n      const newStatus = updateTransactionStatus({\n        sessionId,\n        transaction\n      });\n      await runSessionCallbacks({\n        sessionId,\n        status: newStatus\n      });\n      return;\n    }\n\n    if (hasStatusChanged) {\n      const newStatus = updateTransactionStatus({\n        sessionId,\n        transaction\n      });\n\n      await runSessionCallbacks({\n        sessionId,\n        status: newStatus\n      });\n    }\n\n    if (getIsTransactionFailed(status)) {\n      await manageFailedTransactions({ sessionId, hash, results });\n    }\n  } catch (error) {\n    console.error(error);\n    updateSessionStatus({\n      sessionId,\n      status: TransactionBatchStatusesEnum.timedOut\n    });\n    await runSessionCallbacks({\n      sessionId,\n      status: TransactionBatchStatusesEnum.timedOut\n    });\n  }\n}\n\nexport async function checkBatch({\n  sessionId,\n  transactionBatch: transactions,\n  isSequential\n}: TransactionStatusTrackerPropsType) {\n  try {\n    if (transactions == null) {\n      return;\n    }\n\n    const pendingTransactions = getPendingTransactions(transactions);\n\n    const serverTransactions =\n      await getTransactionsByHashes(pendingTransactions);\n\n    for (const serverTransaction of serverTransactions) {\n      await manageTransaction({\n        serverTransaction,\n        sessionId,\n        isSequential\n      });\n    }\n\n    const hasCompleted = serverTransactions.every(\n      (tx) => tx.status !== TransactionServerStatusesEnum.pending\n    );\n\n    // Call the onSuccess or onFail callback only if the transactions are sent normally (not using batch transactions mechanism).\n    // The batch transactions mechanism will call the callbacks separately.\n\n    if (hasCompleted) {\n      const isSuccessful = serverTransactions.every(\n        (tx) => tx.status === TransactionServerStatusesEnum.success\n      );\n\n      if (isSuccessful) {\n        return updateSessionStatus({\n          sessionId,\n          status: TransactionBatchStatusesEnum.success\n        });\n      }\n\n      const isFailed = serverTransactions.some(\n        (tx) => tx.status === TransactionServerStatusesEnum.fail\n      );\n\n      if (isFailed) {\n        return updateSessionStatus({\n          sessionId,\n          status: TransactionBatchStatusesEnum.fail\n        });\n      }\n\n      const isInvalid = serverTransactions.every((tx) => tx.invalidTransaction);\n\n      if (isInvalid) {\n        return updateSessionStatus({\n          sessionId,\n          status: TransactionBatchStatusesEnum.invalid\n        });\n      }\n    }\n  } catch (error) {\n    console.error(error);\n  }\n}\n"],
  "mappings": "wPA6BA,IAAMA,EAAuB,CAAC,EAQ9B,eAAeC,EAAkB,CAC/B,kBAAmBC,EACnB,UAAAC,EACA,aAAAC,CACF,EAA0B,CACxB,GAAM,CAAE,KAAAC,EAAM,OAAAC,EAAQ,QAAAC,EAAS,mBAAAC,EAAoB,iBAAAC,CAAiB,EAClEP,EACF,GAAI,CAEF,GAD2BF,EAAQK,CAAI,EACd,GAAI,CAE3BK,EAAoB,CAClB,UAAAP,EACA,iBACF,CAAC,EAED,MAAMQ,EAAoB,CACxB,UAAAR,EACA,iBACF,CAAC,EAED,MACF,CAEA,GACGK,GAAsB,CAACJ,GACxBE,WACA,CACAN,EAAQK,CAAI,EAAIL,EAAQK,CAAI,EAAIL,EAAQK,CAAI,EAAI,EAAI,EACpD,MACF,CAIA,GAAID,GAAgB,CAACE,EAAQ,CAC3B,IAAMM,EAAYC,EAAwB,CACxC,UAAAV,EACA,YAAAD,CACF,CAAC,EACD,MAAMS,EAAoB,CACxB,UAAAR,EACA,OAAQS,CACV,CAAC,EACD,MACF,CAEA,GAAIH,EAAkB,CACpB,IAAMG,EAAYC,EAAwB,CACxC,UAAAV,EACA,YAAAD,CACF,CAAC,EAED,MAAMS,EAAoB,CACxB,UAAAR,EACA,OAAQS,CACV,CAAC,CACH,CAEIE,EAAuBR,CAAM,GAC/B,MAAMS,EAAyB,CAAE,UAAAZ,EAAW,KAAAE,EAAM,QAAAE,CAAQ,CAAC,CAE/D,OAASS,EAAO,CACd,QAAQ,MAAMA,CAAK,EACnBN,EAAoB,CAClB,UAAAP,EACA,iBACF,CAAC,EACD,MAAMQ,EAAoB,CACxB,UAAAR,EACA,iBACF,CAAC,CACH,CACF,CAEA,eAAsBc,EAAW,CAC/B,UAAAd,EACA,iBAAkBe,EAClB,aAAAd,CACF,EAAsC,CACpC,GAAI,CACF,GAAIc,GAAgB,KAClB,OAGF,IAAMC,EAAsBC,EAAuBF,CAAY,EAEzDG,EACJ,MAAMC,EAAwBH,CAAmB,EAEnD,QAAWI,KAAqBF,EAC9B,MAAMpB,EAAkB,CACtB,kBAAAsB,EACA,UAAApB,EACA,aAAAC,CACF,CAAC,EAUH,GAPqBiB,EAAmB,MACrCG,GAAOA,EAAG,kBACb,EAKkB,CAKhB,GAJqBH,EAAmB,MACrCG,GAAOA,EAAG,kBACb,EAGE,OAAOd,EAAoB,CACzB,UAAAP,EACA,gBACF,CAAC,EAOH,GAJiBkB,EAAmB,KACjCG,GAAOA,EAAG,eACb,EAGE,OAAOd,EAAoB,CACzB,UAAAP,EACA,aACF,CAAC,EAKH,GAFkBkB,EAAmB,MAAOG,GAAOA,EAAG,kBAAkB,EAGtE,OAAOd,EAAoB,CACzB,UAAAP,EACA,gBACF,CAAC,CAEL,CACF,OAASa,EAAO,CACd,QAAQ,MAAMA,CAAK,CACrB,CACF",
  "names": ["retries", "manageTransaction", "transaction", "sessionId", "isSequential", "hash", "status", "results", "invalidTransaction", "hasStatusChanged", "updateSessionStatus", "runSessionCallbacks", "newStatus", "updateTransactionStatus", "getIsTransactionFailed", "manageFailedTransactions", "error", "checkBatch", "transactions", "pendingTransactions", "getPendingTransactions", "serverTransactions", "getTransactionsByHashes", "serverTransaction", "tx"]
}
