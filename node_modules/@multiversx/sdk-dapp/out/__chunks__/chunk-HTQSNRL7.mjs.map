{
  "version": 3,
  "sources": ["../../src/apiCalls/tokens/getPersistedTokenDetails.ts"],
  "sourcesContent": ["import { NFTS_ENDPOINT, TOKENS_ENDPOINT } from 'apiCalls/endpoints';\nimport { getPersistedToken } from 'apiCalls/tokens/getPersistedToken';\nimport { networkSelector } from 'store/selectors/networkSelectors';\nimport { getState } from 'store/store';\n\nimport { NftEnumType } from 'types/tokens.types';\nimport { getIdentifierType } from 'utils/validation/getIdentifierType';\n\nexport interface TokenAssets {\n  description: string;\n  status: string;\n  svgUrl: string;\n  website?: string;\n  pngUrl?: string;\n  social?: any;\n  extraTokens?: string[];\n  lockedAccounts?: { [key: string]: string };\n}\n\nexport interface TokenMediaType {\n  url?: string;\n  originalUrl?: string;\n  thumbnailUrl?: string;\n  fileType?: string;\n  fileSize?: number;\n}\n\nexport interface TokenOptionType {\n  tokenLabel: string;\n  tokenDecimals: number;\n  tokenImageUrl: string;\n  assets?: TokenAssets;\n  type?: NftEnumType;\n  error?: string;\n  esdtPrice?: number;\n  ticker?: string;\n  identifier?: string;\n  name?: string;\n}\n\ninterface TokenInfoResponse {\n  identifier: string;\n  name: string;\n  ticker: string;\n  decimals: number;\n  type?: NftEnumType;\n  assets: TokenAssets;\n  media?: TokenMediaType[];\n  price: number;\n}\n\nexport async function getPersistedTokenDetails({\n  tokenId\n}: {\n  tokenId?: string;\n}): Promise<TokenOptionType> {\n  const network = networkSelector(getState());\n\n  const noData = {\n    tokenDecimals: Number(network.decimals),\n    tokenLabel: '',\n    tokenImageUrl: ''\n  };\n\n  const { isNft } = getIdentifierType(tokenId);\n\n  const tokenIdentifier = tokenId;\n  const tokenEndpoint = isNft ? NFTS_ENDPOINT : TOKENS_ENDPOINT;\n\n  if (!tokenIdentifier) {\n    return noData;\n  }\n\n  try {\n    const selectedToken = await getPersistedToken<TokenInfoResponse>(\n      `${network.apiAddress}/${tokenEndpoint}/${tokenIdentifier}`\n    );\n\n    const tokenDecimals = selectedToken\n      ? selectedToken?.decimals\n      : Number(network.decimals);\n    const tokenLabel = selectedToken ? selectedToken?.name : '';\n    const tokenImageUrl = selectedToken\n      ? selectedToken?.assets?.svgUrl ?? selectedToken?.media?.[0]?.thumbnailUrl\n      : '';\n\n    return {\n      tokenDecimals: tokenDecimals,\n      tokenLabel,\n      type: selectedToken?.type,\n      tokenImageUrl,\n      identifier: selectedToken?.identifier,\n      assets: selectedToken?.assets,\n      esdtPrice: selectedToken?.price,\n      ticker: selectedToken?.ticker,\n      name: selectedToken?.name\n    };\n  } catch (error) {\n    return {\n      ...noData,\n      error: `${error}`\n    };\n  }\n}\n"],
  "mappings": "oNAmDA,eAAsBA,EAAyB,CAC7C,QAAAC,CACF,EAE6B,CAC3B,IAAMC,EAAUC,EAAgBC,EAAS,CAAC,EAEpCC,EAAS,CACb,cAAe,OAAOH,EAAQ,QAAQ,EACtC,WAAY,GACZ,cAAe,EACjB,EAEM,CAAE,MAAAI,CAAM,EAAIC,EAAkBN,CAAO,EAErCO,EAAkBP,EAClBQ,EAAgBH,EAAQI,EAAgBC,EAE9C,GAAI,CAACH,EACH,OAAOH,EAGT,GAAI,CACF,IAAMO,EAAgB,MAAMC,EAC1B,GAAGX,EAAQ,UAAU,IAAIO,CAAa,IAAID,CAAe,EAC3D,EAEMM,EAAgBF,EAClBA,GAAe,SACf,OAAOV,EAAQ,QAAQ,EACrBa,EAAaH,EAAgBA,GAAe,KAAO,GACnDI,EAAgBJ,EAClBA,GAAe,QAAQ,QAAUA,GAAe,QAAQ,CAAC,GAAG,aAC5D,GAEJ,MAAO,CACL,cAAeE,EACf,WAAAC,EACA,KAAMH,GAAe,KACrB,cAAAI,EACA,WAAYJ,GAAe,WAC3B,OAAQA,GAAe,OACvB,UAAWA,GAAe,MAC1B,OAAQA,GAAe,OACvB,KAAMA,GAAe,IACvB,CACF,OAASK,EAAO,CACd,MAAO,CACL,GAAGZ,EACH,MAAO,GAAGY,CAAK,EACjB,CACF,CACF",
  "names": ["getPersistedTokenDetails", "tokenId", "network", "networkSelector", "getState", "noData", "isNft", "getIdentifierType", "tokenIdentifier", "tokenEndpoint", "NFTS_ENDPOINT", "TOKENS_ENDPOINT", "selectedToken", "getPersistedToken", "tokenDecimals", "tokenLabel", "tokenImageUrl", "error"]
}
