{
  "version": 3,
  "sources": ["../../src/services/nativeAuth/helpers/getLatestBlockHash.ts"],
  "sourcesContent": ["import axios from 'axios';\nimport { BLOCKS_ENDPOINT } from 'apiCalls/endpoints';\nimport { retryMultipleTimes } from 'utils/retryMultipleTimes';\n\nexport interface LatestBlockHashType {\n  hash: string;\n  timestamp: number;\n}\n\nconst getBlockFromPosition = 4;\nconst cachingDurationMs = 30000; // 30 seconds, a block hash is valid for 1 minute from its generation\n//this is an object with .current, so it doesn't get affected by closure and is always a fresh value\nconst cachedResponse: Record<string, LatestBlockHashType | null> = {\n  current: null\n};\n\nconst requestPromise: {\n  current: Promise<LatestBlockHashType> | null;\n} = {\n  current: null\n};\n\nconst getLatestBlockHashFromServer = retryMultipleTimes(\n  async (\n    apiUrl: string,\n    blockHashShard?: number,\n    getBlockHash?: () => Promise<string>\n  ): Promise<LatestBlockHashType | null> => {\n    // get current block hash\n    if (getBlockHash) {\n      const timestamp = Math.floor(Date.now() / 1000);\n      const hash = await getBlockHash();\n\n      return { hash, timestamp };\n    }\n\n    //get the penultimate block hash (3 shards + the meta chain) to make sure that the block is seen by auth server\n    const { data } = await axios.get<Array<LatestBlockHashType>>(\n      `${apiUrl}/${BLOCKS_ENDPOINT}?from=${getBlockFromPosition}&size=1&fields=hash,timestamp${\n        blockHashShard ? '&shard=' + blockHashShard : ''\n      }`\n    );\n    const [latestBlock] = data;\n    return latestBlock;\n  }\n);\n\ntype GetLatestBlockHashType = {\n  apiAddress: string;\n  blockHashShard?: number;\n  getBlockHash: () => Promise<string>;\n  noCache?: boolean;\n};\n\nexport async function getLatestBlockHash({\n  apiAddress,\n  noCache,\n  blockHashShard,\n  getBlockHash\n}: GetLatestBlockHashType): Promise<LatestBlockHashType> {\n  if (apiAddress == null) {\n    throw new Error('missing api url');\n  }\n\n  const currentTimestampMs = Date.now();\n  if (\n    cachedResponse.current != null &&\n    currentTimestampMs <\n      cachedResponse.current.timestamp * 1000 + cachingDurationMs &&\n    !noCache\n  ) {\n    return cachedResponse.current;\n  }\n  //this will prevent multiple calls to this function from generating multiple hashes\n  if (requestPromise.current != null) {\n    //if there is already an await in progress for the API, just return the result of that promise\n    return await requestPromise.current;\n  }\n\n  //if a promise is not in progress, get a new promise and add it to the promise\n  requestPromise.current = getLatestBlockHashFromServer(\n    apiAddress,\n    blockHashShard,\n    getBlockHash\n  );\n\n  try {\n    const response = await requestPromise.current;\n    if (response == null) {\n      requestPromise.current = null;\n      throw new Error('could not get block hash');\n    }\n    //set the new response, the new expiry and unlock the regeneration flow for the next expiration period\n    cachedResponse.current = {\n      hash: response.hash,\n      timestamp: response.timestamp\n    };\n\n    requestPromise.current = null;\n    return response;\n  } catch (_error) {\n    requestPromise.current = null;\n    return null as any;\n  }\n}\n"],
  "mappings": "kFAAA,OAAOA,MAAW,QASlB,IAAMC,EAAuB,EACvBC,EAAoB,IAEpBC,EAA6D,CACjE,QAAS,IACX,EAEMC,EAEF,CACF,QAAS,IACX,EAEMC,EAA+BC,EACnC,MACEC,EACAC,EACAC,IACwC,CAExC,GAAIA,EAAc,CAChB,IAAMC,EAAY,KAAK,MAAM,KAAK,IAAI,EAAI,GAAI,EAG9C,MAAO,CAAE,KAFI,MAAMD,EAAa,EAEjB,UAAAC,CAAU,CAC3B,CAGA,GAAM,CAAE,KAAAC,CAAK,EAAI,MAAMC,EAAM,IAC3B,GAAGL,CAAM,IAAIM,CAAe,SAASZ,CAAoB,gCACvDO,EAAiB,UAAYA,EAAiB,EAChD,EACF,EACM,CAACM,CAAW,EAAIH,EACtB,OAAOG,CACT,CACF,EASA,eAAsBC,EAAmB,CACvC,WAAAC,EACA,QAAAC,EACA,eAAAT,EACA,aAAAC,CACF,EAAyD,CACvD,GAAIO,GAAc,KAChB,MAAM,IAAI,MAAM,iBAAiB,EAGnC,IAAME,EAAqB,KAAK,IAAI,EACpC,GACEf,EAAe,SAAW,MAC1Be,EACEf,EAAe,QAAQ,UAAY,IAAOD,GAC5C,CAACe,EAED,OAAOd,EAAe,QAGxB,GAAIC,EAAe,SAAW,KAE5B,OAAO,MAAMA,EAAe,QAI9BA,EAAe,QAAUC,EACvBW,EACAR,EACAC,CACF,EAEA,GAAI,CACF,IAAMU,EAAW,MAAMf,EAAe,QACtC,GAAIe,GAAY,KACd,MAAAf,EAAe,QAAU,KACnB,IAAI,MAAM,0BAA0B,EAG5C,OAAAD,EAAe,QAAU,CACvB,KAAMgB,EAAS,KACf,UAAWA,EAAS,SACtB,EAEAf,EAAe,QAAU,KAClBe,CACT,MAAiB,CACf,OAAAf,EAAe,QAAU,KAClB,IACT,CACF",
  "names": ["axios", "getBlockFromPosition", "cachingDurationMs", "cachedResponse", "requestPromise", "getLatestBlockHashFromServer", "retryMultipleTimes", "apiUrl", "blockHashShard", "getBlockHash", "timestamp", "data", "axios", "BLOCKS_ENDPOINT", "latestBlock", "getLatestBlockHash", "apiAddress", "noCache", "currentTimestampMs", "response"]
}
