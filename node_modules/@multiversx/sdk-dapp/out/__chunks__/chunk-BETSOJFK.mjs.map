{
  "version": 3,
  "sources": ["../../src/providers/strategies/helpers/signTransactions/helpers/getCommonData/helpers/decodeDataField.ts"],
  "sourcesContent": ["import { Address } from '@multiversx/sdk-core';\nimport BigNumber from 'bignumber.js';\nimport { TransactionTypesEnum } from 'types/enums.types';\nimport {\n  DecodeMethodEnum,\n  TransactionTokensType,\n  DecodedDisplayType\n} from 'types/serverTransactions.types';\nimport { isUtf8 } from 'utils/decoders';\nimport { addressIsValid } from 'utils/validation/addressIsValid';\nimport { isHexValidCharacters, isHexValidLength } from 'utils/validation/hex';\n\ninterface IGetDecodedParts {\n  parts: string[];\n  decodeMethod: DecodeMethodEnum;\n  identifier?: string;\n  decodedData: DecodedDisplayType;\n}\n\ninterface ISmartDecodedParts {\n  parts: string[];\n  decodedParts: string[];\n  identifier?: string;\n}\n\nconst getHexValidationWarnings = (str: string) => {\n  const warnings = [];\n\n  if (str && !isHexValidCharacters(str)) {\n    warnings.push(`Invalid Hex characters on argument @${str}`);\n  }\n\n  if (str && !isHexValidLength(str)) {\n    warnings.push(`Odd number of Hex characters on argument @${str}`);\n  }\n\n  return warnings;\n};\n\nconst decodeByMethod = (\n  part: string,\n  decodeMethod: DecodeMethodEnum | string,\n  transactionTokens?: TransactionTokensType\n) => {\n  switch (decodeMethod) {\n    case DecodeMethodEnum.text:\n      try {\n        return Buffer.from(part, 'hex').toString('utf8');\n      } catch {\n        return part;\n      }\n\n    case DecodeMethodEnum.decimal:\n      return part !== '' ? new BigNumber(part, 16).toString(10) : '';\n    case DecodeMethodEnum.smart:\n      try {\n        const bech32Encoded = Address.newFromHex(part).toString();\n\n        if (addressIsValid(bech32Encoded)) {\n          return bech32Encoded;\n        }\n      } catch {\n        // skip\n      }\n\n      try {\n        const decoded = Buffer.from(part, 'hex').toString('utf8');\n\n        if (!isUtf8(decoded)) {\n          if (transactionTokens) {\n            const tokens = [\n              ...transactionTokens.esdts,\n              ...transactionTokens.nfts\n            ];\n\n            if (tokens.some((token) => decoded.includes(token))) {\n              return decoded;\n            }\n          }\n\n          const bigNumber = new BigNumber(part, 16);\n\n          return bigNumber.isFinite() ? bigNumber.toString(10) : part;\n        } else {\n          return decoded;\n        }\n      } catch {\n        return part;\n      }\n\n    case DecodeMethodEnum.raw:\n    default:\n      return part;\n  }\n};\n\nconst getSmartDecodedParts = ({\n  parts,\n  decodedParts,\n  identifier\n}: ISmartDecodedParts) => {\n  const smartDecodedParts = [...decodedParts];\n\n  if (parts[0] === TransactionTypesEnum.ESDTNFTTransfer && parts[2]) {\n    smartDecodedParts[2] = decodeByMethod(parts[2], DecodeMethodEnum.decimal);\n  }\n\n  if (identifier === TransactionTypesEnum.ESDTNFTTransfer && parts[1]) {\n    const base64Buffer = Buffer.from(String(parts[1]), 'base64');\n    smartDecodedParts[1] = decodeByMethod(\n      base64Buffer.toString('hex'),\n      DecodeMethodEnum.decimal\n    );\n  }\n\n  return smartDecodedParts;\n};\n\nconst getDisplayValueAndValidationWarnings = ({\n  parts,\n  decodeMethod,\n  identifier,\n  decodedData\n}: IGetDecodedParts) => {\n  const initialDecodedParts = parts.map((part, index) => {\n    if (\n      parts.length >= 2 &&\n      ((index === 0 && part.length < 64) || (index === 1 && !parts[0]))\n    ) {\n      const encodedDisplayValue = /[^a-z0-9]/gi.test(part);\n\n      if (encodedDisplayValue) {\n        return decodeByMethod(part, decodeMethod);\n      }\n\n      return part;\n    }\n\n    const hexValidationWarnings = getHexValidationWarnings(part);\n\n    if (hexValidationWarnings?.length) {\n      decodedData.validationWarnings = Array.from(\n        new Set([...decodedData.validationWarnings, ...hexValidationWarnings])\n      );\n    }\n\n    return decodeByMethod(part, decodeMethod);\n  });\n\n  const decodedParts =\n    decodeMethod === DecodeMethodEnum.smart\n      ? getSmartDecodedParts({\n          parts,\n          decodedParts: initialDecodedParts,\n          identifier\n        })\n      : initialDecodedParts;\n\n  return decodedParts;\n};\n\nconst getDecodedParts = ({\n  parts,\n  decodeMethod,\n  identifier,\n  initialDecodedParts\n}: {\n  parts: string[];\n  decodeMethod: DecodeMethodEnum;\n  identifier?: string;\n  initialDecodedParts: string[];\n}) => {\n  if (decodeMethod === DecodeMethodEnum.smart) {\n    return getSmartDecodedParts({\n      parts,\n      decodedParts: initialDecodedParts,\n      identifier\n    });\n  }\n\n  return initialDecodedParts;\n};\n\nconst decodeHighlight = ({\n  data,\n  identifier,\n  decodeMethod,\n  delimiter\n}: {\n  data: string;\n  identifier?: string;\n  decodeMethod: DecodeMethodEnum;\n  delimiter: string;\n}) => {\n  const parts = data.split('@');\n\n  const initialDecodedParts = parts.map((part) => {\n    return decodeByMethod(part, decodeMethod);\n  });\n\n  const decodedHighlight = getDecodedParts({\n    parts,\n    initialDecodedParts,\n    identifier,\n    decodeMethod\n  });\n\n  return decodedHighlight.join(delimiter);\n};\n\nconst decodeDataField = ({\n  data,\n  identifier,\n  decodeMethod,\n  highlight\n}: {\n  data: string;\n  identifier?: string;\n  decodeMethod: DecodeMethodEnum;\n  highlight: string | null;\n}): DecodedDisplayType => {\n  const decodedData: DecodedDisplayType = {\n    displayValue: '',\n    validationWarnings: [],\n    highlight\n  };\n\n  const hasAt = data.includes('@');\n  const hasNewLine = data.includes('\\n');\n\n  if (!hasAt && !hasNewLine) {\n    return {\n      ...decodedData,\n      displayValue: decodeByMethod(data, decodeMethod),\n      highlight: highlight ? decodeByMethod(highlight, decodeMethod) : highlight\n    };\n  }\n\n  if (hasAt) {\n    const parts = data.split('@');\n    const decodedParts = getDisplayValueAndValidationWarnings({\n      parts,\n      decodeMethod,\n      identifier,\n      decodedData\n    });\n\n    const decodedHighlight = highlight\n      ? decodeHighlight({\n          data: highlight,\n          identifier,\n          decodeMethod,\n          delimiter: '@'\n        })\n      : null;\n\n    return {\n      ...decodedData,\n      displayValue: decodedParts.join('@'),\n      highlight: decodedHighlight\n    };\n  }\n\n  if (hasNewLine) {\n    const parts = data.split('\\n');\n\n    const initialDecodedParts = parts.map((part) => {\n      if (decodeMethod === DecodeMethodEnum.raw) {\n        return part;\n      }\n\n      return decodeByMethod(\n        Buffer.from(part, 'base64').toString('hex'),\n        decodeMethod\n      );\n    });\n\n    const decodedParts = getDecodedParts({\n      parts,\n      initialDecodedParts,\n      identifier,\n      decodeMethod\n    });\n\n    const decodedHighlight = highlight\n      ? decodeHighlight({\n          data: highlight,\n          identifier,\n          decodeMethod,\n          delimiter: '\\n'\n        })\n      : null;\n\n    return {\n      ...decodedData,\n      displayValue: decodedParts.join('\\n'),\n      highlight: decodedHighlight\n    };\n  }\n\n  return decodedData;\n};\n\nexport const getAllDecodedFormats = ({\n  data,\n  highlight,\n  identifier\n}: {\n  data: string;\n  highlight: string | null;\n  identifier?: string;\n}) => {\n  const decodedFormats: Partial<Record<DecodeMethodEnum, DecodedDisplayType>> =\n    {};\n\n  Object.values(DecodeMethodEnum).forEach((decodeMethod) => {\n    const decodedData = decodeDataField({\n      data,\n      identifier,\n      decodeMethod,\n      highlight\n    });\n\n    decodedFormats[decodeMethod] = decodedData;\n  });\n\n  return decodedFormats;\n};\n"],
  "mappings": "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",
  "names": ["Address", "BigNumber", "getHexValidationWarnings", "str", "warnings", "isHexValidCharacters", "isHexValidLength", "decodeByMethod", "part", "decodeMethod", "transactionTokens", "BigNumber", "bech32Encoded", "Address", "addressIsValid", "decoded", "isUtf8", "token", "bigNumber", "getSmartDecodedParts", "parts", "decodedParts", "identifier", "smartDecodedParts", "base64Buffer", "getDisplayValueAndValidationWarnings", "decodedData", "initialDecodedParts", "index", "hexValidationWarnings", "getDecodedParts", "decodeHighlight", "data", "delimiter", "decodeDataField", "highlight", "hasAt", "hasNewLine", "decodedHighlight", "getAllDecodedFormats", "decodedFormats", "DecodeMethodEnum"]
}
