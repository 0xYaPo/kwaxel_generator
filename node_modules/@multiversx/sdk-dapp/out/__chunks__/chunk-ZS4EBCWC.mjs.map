{
  "version": 3,
  "sources": ["../../src/utils/transactions/getInterpretedTransaction/helpers/getTokenFromData.ts"],
  "sourcesContent": ["import { Address } from '@multiversx/sdk-core';\nimport BigNumber from 'bignumber.js';\nimport { TransactionTypesEnum } from 'types/enums.types';\nimport { decodePart } from 'utils/decoders/decodePart';\nimport { addressIsValid } from 'utils/validation/addressIsValid';\n\nconst noData = {\n  tokenId: '',\n  amount: ''\n};\n\nexport const decodeData = (data: string) => {\n  const nonceIndex = 2;\n  const amountIndex = 3;\n  const parts = data.split('@');\n  const decodedParts = parts.map((part, i) =>\n    [nonceIndex, amountIndex].includes(i) ? part : decodePart(part)\n  );\n  return decodedParts;\n};\n\nexport function getTokenFromData(data?: string): {\n  tokenId: string;\n  amount: string;\n  collection?: string;\n  nonce?: string;\n  receiver?: string;\n} {\n  if (!data) {\n    return noData;\n  }\n\n  const isTokenTransfer = data.startsWith(TransactionTypesEnum.ESDTTransfer);\n  const isNftTransfer =\n    data.startsWith(TransactionTypesEnum.ESDTNFTTransfer) && data.includes('@');\n  const isNftBurn =\n    data.startsWith(TransactionTypesEnum.ESDTNFTBurn) && data.includes('@');\n\n  try {\n    if (isTokenTransfer) {\n      const [, encodedToken, encodedAmount] = data.split('@');\n      const tokenId = Buffer.from(encodedToken, 'hex').toString('ascii');\n\n      if (!tokenId) {\n        return noData;\n      }\n\n      const amount = new BigNumber(\n        '0x' + encodedAmount.replace('0x', '')\n      ).toString(10);\n\n      return {\n        tokenId,\n        amount\n      };\n    }\n\n    const decodedData = decodeData(data);\n\n    if (isNftTransfer) {\n      const [, /*ESDTNFTTransfer*/ collection, nonce, quantity, receiver] =\n        decodedData;\n\n      if (\n        [collection, nonce, quantity, receiver].every((el) => Boolean(el)) &&\n        addressIsValid(new Address(receiver).toBech32())\n      ) {\n        return {\n          tokenId: `${collection}-${nonce}`,\n          amount: new BigNumber(quantity, 16).toString(10),\n          collection,\n          nonce,\n          receiver: new Address(receiver).toBech32()\n        };\n      }\n    }\n\n    if (isNftBurn) {\n      const [, /*ESDTNFTBurn*/ collection, nonce, quantity] = decodedData;\n\n      if ([collection, nonce, quantity].every((el) => Boolean(el))) {\n        return {\n          tokenId: `${collection}-${nonce}`,\n          amount: new BigNumber(quantity, 16).toString(10),\n          collection,\n          nonce\n        };\n      }\n    }\n  } catch {\n    return noData;\n  }\n\n  return noData;\n}\n"],
  "mappings": "kFAAA,OAAS,WAAAA,MAAe,uBACxB,OAAOC,MAAe,eAKtB,IAAMC,EAAS,CACb,QAAS,GACT,OAAQ,EACV,EAEaC,EAAcC,GAGXA,EAAK,MAAM,GAAG,EACD,IAAI,CAACC,EAAMC,IACpC,CAAC,EAAY,CAAW,EAAE,SAASA,CAAC,EAAID,EAAOE,EAAWF,CAAI,CAChE,EAIK,SAASG,EAAiBJ,EAM/B,CACA,GAAI,CAACA,EACH,OAAOF,EAGT,IAAMO,EAAkBL,EAAK,yBAA4C,EACnEM,EACJN,EAAK,4BAA+C,GAAKA,EAAK,SAAS,GAAG,EACtEO,EACJP,EAAK,wBAA2C,GAAKA,EAAK,SAAS,GAAG,EAExE,GAAI,CACF,GAAIK,EAAiB,CACnB,GAAM,CAAC,CAAEG,EAAcC,CAAa,EAAIT,EAAK,MAAM,GAAG,EAChDU,EAAU,OAAO,KAAKF,EAAc,KAAK,EAAE,SAAS,OAAO,EAEjE,GAAI,CAACE,EACH,OAAOZ,EAGT,IAAMa,EAAS,IAAIC,EACjB,KAAOH,EAAc,QAAQ,KAAM,EAAE,CACvC,EAAE,SAAS,EAAE,EAEb,MAAO,CACL,QAAAC,EACA,OAAAC,CACF,CACF,CAEA,IAAME,EAAcd,EAAWC,CAAI,EAEnC,GAAIM,EAAe,CACjB,GAAM,CAAC,CAAsBQ,EAAYC,EAAOC,EAAUC,CAAQ,EAChEJ,EAEF,GACE,CAACC,EAAYC,EAAOC,EAAUC,CAAQ,EAAE,MAAOC,GAAO,EAAQA,CAAG,GACjEC,EAAe,IAAIC,EAAQH,CAAQ,EAAE,SAAS,CAAC,EAE/C,MAAO,CACL,QAAS,GAAGH,CAAU,IAAIC,CAAK,GAC/B,OAAQ,IAAIH,EAAUI,EAAU,EAAE,EAAE,SAAS,EAAE,EAC/C,WAAAF,EACA,MAAAC,EACA,SAAU,IAAIK,EAAQH,CAAQ,EAAE,SAAS,CAC3C,CAEJ,CAEA,GAAIV,EAAW,CACb,GAAM,CAAC,CAAkBO,EAAYC,EAAOC,CAAQ,EAAIH,EAExD,GAAI,CAACC,EAAYC,EAAOC,CAAQ,EAAE,MAAOE,GAAO,EAAQA,CAAG,EACzD,MAAO,CACL,QAAS,GAAGJ,CAAU,IAAIC,CAAK,GAC/B,OAAQ,IAAIH,EAAUI,EAAU,EAAE,EAAE,SAAS,EAAE,EAC/C,WAAAF,EACA,MAAAC,CACF,CAEJ,CACF,MAAQ,CACN,OAAOjB,CACT,CAEA,OAAOA,CACT",
  "names": ["Address", "BigNumber", "noData", "decodeData", "data", "part", "i", "decodePart", "getTokenFromData", "isTokenTransfer", "isNftTransfer", "isNftBurn", "encodedToken", "encodedAmount", "tokenId", "amount", "BigNumber", "decodedData", "collection", "nonce", "quantity", "receiver", "el", "addressIsValid", "Address"]
}
