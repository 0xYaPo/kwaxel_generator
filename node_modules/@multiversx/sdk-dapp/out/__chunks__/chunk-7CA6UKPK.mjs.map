{
  "version": 3,
  "sources": ["../../src/providers/strategies/helpers/signTransactions/helpers/getMultiEsdtTransferData/helpers/parseMultiEsdtTransferData.ts"],
  "sourcesContent": ["import BigNumber from 'bignumber.js';\nimport { TransactionTypesEnum } from 'types/enums.types';\nimport { MultiEsdtTransactionType } from 'types/transactions.types';\nimport { decodePart } from 'utils/decoders/decodePart';\nimport { getAllStringOccurrences } from './getAllStringOccurrences';\n\n// TODO: add tests\nexport function parseMultiEsdtTransferData(data?: string) {\n  const transactions: MultiEsdtTransactionType[] = [];\n  let contractCallDataIndex = 0;\n  try {\n    if (\n      data?.startsWith(TransactionTypesEnum.MultiESDTNFTTransfer) &&\n      data?.includes('@')\n    ) {\n      const [, receiver, encodedTxCount, ...rest] = data.split('@');\n\n      if (receiver) {\n        const txCount = new BigNumber(encodedTxCount, 16).toNumber();\n\n        if (txCount >= Number.MAX_SAFE_INTEGER) {\n          return [];\n        }\n\n        let itemIndex = 0;\n\n        for (let txIndex = 0; txIndex < txCount; txIndex++) {\n          const transaction: MultiEsdtTransactionType = {\n            type: TransactionTypesEnum.nftTransaction,\n            data: '',\n            receiver\n          };\n\n          for (let index = 0; index < 3; index++) {\n            switch (index) {\n              case 0:\n                transaction.token = decodePart(rest[itemIndex]);\n                transaction.data = rest[itemIndex];\n                break;\n              case 1: {\n                const encodedNonce =\n                  rest[itemIndex] && rest[itemIndex].length\n                    ? rest[itemIndex]\n                    : '';\n                if (encodedNonce && encodedNonce !== '00') {\n                  transaction.nonce = encodedNonce;\n                } else {\n                  transaction.type = TransactionTypesEnum.esdtTransaction;\n                }\n                transaction.data = `${transaction.data}@${rest[itemIndex]}`;\n                break;\n              }\n              case 2:\n                transaction.amount = new BigNumber(\n                  rest[itemIndex],\n                  16\n                ).toString(10);\n                transaction.data = `${transaction.data}@${rest[itemIndex]}`;\n                break;\n              default:\n                break;\n            }\n            contractCallDataIndex = itemIndex + 1;\n            itemIndex++;\n          }\n          transactions[txIndex] = transaction;\n        }\n\n        const isDifferentFromTxCount = transactions.length !== txCount;\n        const hasInvalidNoOfAdSigns = transactions.some((tx) => {\n          const adSignOccurences = getAllStringOccurrences(tx.data, '@').length;\n          return adSignOccurences !== 2;\n        });\n\n        const hasAdStart = transactions.some((tx) => tx.data.startsWith('@'));\n        if (isDifferentFromTxCount || hasInvalidNoOfAdSigns || hasAdStart) {\n          return [];\n        }\n\n        if (rest[contractCallDataIndex]) {\n          let scCallData = rest[contractCallDataIndex];\n          for (let i = contractCallDataIndex + 1; i < rest.length; i++) {\n            scCallData += '@' + rest[i];\n          }\n          transactions[txCount] = {\n            type: TransactionTypesEnum.scCall,\n            data: scCallData,\n            receiver\n          };\n        }\n      }\n    }\n  } catch (err) {\n    console.error('failed parsing tx', err);\n    return transactions;\n  }\n  return transactions;\n}\n"],
  "mappings": "kFAAA,OAAOA,MAAe,eAOf,SAASC,EAA2BC,EAAe,CACxD,IAAMC,EAA2C,CAAC,EAC9CC,EAAwB,EAC5B,GAAI,CACF,GACEF,GAAM,iCAAoD,GAC1DA,GAAM,SAAS,GAAG,EAClB,CACA,GAAM,CAAC,CAAEG,EAAUC,EAAgB,GAAGC,CAAI,EAAIL,EAAK,MAAM,GAAG,EAE5D,GAAIG,EAAU,CACZ,IAAMG,EAAU,IAAIC,EAAUH,EAAgB,EAAE,EAAE,SAAS,EAE3D,GAAIE,GAAW,OAAO,iBACpB,MAAO,CAAC,EAGV,IAAIE,EAAY,EAEhB,QAASC,EAAU,EAAGA,EAAUH,EAASG,IAAW,CAClD,IAAMC,EAAwC,CAC5C,sBACA,KAAM,GACN,SAAAP,CACF,EAEA,QAASQ,EAAQ,EAAGA,EAAQ,EAAGA,IAAS,CACtC,OAAQA,EAAO,CACb,IAAK,GACHD,EAAY,MAAQE,EAAWP,EAAKG,CAAS,CAAC,EAC9CE,EAAY,KAAOL,EAAKG,CAAS,EACjC,MACF,IAAK,GAAG,CACN,IAAMK,EACJR,EAAKG,CAAS,GAAKH,EAAKG,CAAS,EAAE,OAC/BH,EAAKG,CAAS,EACd,GACFK,GAAgBA,IAAiB,KACnCH,EAAY,MAAQG,EAEpBH,EAAY,uBAEdA,EAAY,KAAO,GAAGA,EAAY,IAAI,IAAIL,EAAKG,CAAS,CAAC,GACzD,KACF,CACA,IAAK,GACHE,EAAY,OAAS,IAAIH,EACvBF,EAAKG,CAAS,EACd,EACF,EAAE,SAAS,EAAE,EACbE,EAAY,KAAO,GAAGA,EAAY,IAAI,IAAIL,EAAKG,CAAS,CAAC,GACzD,MACF,QACE,KACJ,CACAN,EAAwBM,EAAY,EACpCA,GACF,CACAP,EAAaQ,CAAO,EAAIC,CAC1B,CAEA,IAAMI,EAAyBb,EAAa,SAAWK,EACjDS,EAAwBd,EAAa,KAAMe,GACtBC,EAAwBD,EAAG,KAAM,GAAG,EAAE,SACnC,CAC7B,EAEKE,EAAajB,EAAa,KAAMe,GAAOA,EAAG,KAAK,WAAW,GAAG,CAAC,EACpE,GAAIF,GAA0BC,GAAyBG,EACrD,MAAO,CAAC,EAGV,GAAIb,EAAKH,CAAqB,EAAG,CAC/B,IAAIiB,EAAad,EAAKH,CAAqB,EAC3C,QAASkB,EAAIlB,EAAwB,EAAGkB,EAAIf,EAAK,OAAQe,IACvDD,GAAc,IAAMd,EAAKe,CAAC,EAE5BnB,EAAaK,CAAO,EAAI,CACtB,cACA,KAAMa,EACN,SAAAhB,CACF,CACF,CACF,CACF,CACF,OAASkB,EAAK,CACZ,eAAQ,MAAM,oBAAqBA,CAAG,EAC/BpB,CACT,CACA,OAAOA,CACT",
  "names": ["BigNumber", "parseMultiEsdtTransferData", "data", "transactions", "contractCallDataIndex", "receiver", "encodedTxCount", "rest", "txCount", "BigNumber", "itemIndex", "txIndex", "transaction", "index", "decodePart", "encodedNonce", "isDifferentFromTxCount", "hasInvalidNoOfAdSigns", "tx", "getAllStringOccurrences", "hasAdStart", "scCallData", "i", "err"]
}
