{
  "version": 3,
  "sources": ["../../src/providers/strategies/BaseProviderStrategy/BaseProviderStrategy.ts"],
  "sourcesContent": ["import { IProviderAccount } from '@multiversx/sdk-wallet-connect-provider/out';\nimport { providerLabels } from 'constants/index';\nimport { Transaction, Message } from 'lib/sdkCore';\nimport { IDAppProviderOptions, IDAppProviderAccount } from 'lib/sdkDappUtils';\nimport { PendingTransactionsEventsEnum } from 'managers/internal/PendingTransactionsStateManager';\nimport { getAddress } from 'methods/account/getAddress';\nimport { IProvider, ProviderType } from 'providers/types/providerFactory.types';\nimport { ProviderErrorsEnum } from 'types/provider.types';\nimport { getPendingTransactionsHandlers } from '../helpers';\n\nexport type LoginOptionsTypes = {\n  token?: string;\n};\n\nexport abstract class BaseProviderStrategy<\n  T extends ProviderType = ProviderType\n> implements IProvider<T>\n{\n  protected address?: string = '';\n  protected _login:\n    | ((options?: LoginOptionsTypes) => Promise<IProviderAccount | null>)\n    | null = null;\n  protected loginAbortController: AbortController | null = null;\n\n  /*\n   * Allow setting provider address without store login\n   */\n  constructor(address?: string) {\n    this.address = address ?? '';\n  }\n\n  abstract init(): Promise<boolean>;\n  abstract logout(): Promise<boolean>;\n  abstract getType(): T;\n\n  abstract getAddress(): Promise<string | undefined>;\n  abstract setAccount(account: IDAppProviderAccount): void;\n  abstract isInitialized(): boolean;\n\n  isConnected?(): boolean;\n\n  getAccount(): IDAppProviderAccount | null {\n    throw new Error('Method not implemented.');\n  }\n\n  signTransaction(\n    _transaction: Transaction,\n    _options?: IDAppProviderOptions\n  ): Promise<Transaction | null> {\n    throw new Error('Method not implemented.');\n  }\n\n  abstract signTransactions(\n    transactions: Transaction[],\n    options?: IDAppProviderOptions\n  ): Promise<Transaction[] | null>;\n\n  abstract signMessage(\n    messageToSign: Message,\n    options?: IDAppProviderOptions\n  ): Promise<Message | null>;\n\n  public async login(\n    options?: LoginOptionsTypes\n  ): Promise<{ address: string; signature: string }> {\n    if (!this._login) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    if (this.loginAbortController) {\n      this.loginAbortController.abort();\n    }\n\n    const controller = new AbortController();\n    this.loginAbortController = controller;\n\n    const signal = controller.signal;\n\n    try {\n      const abortPromise = new Promise<never>((_, reject) => {\n        signal.addEventListener('abort', () => {\n          reject(new Error('Login cancelled'));\n        });\n      });\n\n      const loginResult = await Promise.race([\n        this.loginOperation(options),\n        abortPromise\n      ]);\n\n      this.loginAbortController = null;\n\n      return loginResult;\n    } catch (error) {\n      this.loginAbortController = null;\n      throw error;\n    }\n  }\n\n  public cancelLogin = () => {\n    if (this.loginAbortController) {\n      this.loginAbortController.abort();\n    }\n\n    this.cancelAction?.();\n    this.loginAbortController = null;\n  };\n\n  protected loginOperation = async (\n    options?: LoginOptionsTypes\n  ): Promise<{ address: string; signature: string }> => {\n    if (!this._login) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    const result = await this._login(options);\n\n    if (!result?.address) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    return {\n      ...result,\n      address: result.address,\n      signature: result.signature ?? ''\n    };\n  };\n\n  /**\n   * Initializes the provider by setting the address if it is not already set.\n   */\n  protected initializeAddress = () => {\n    if (this.address) {\n      return;\n    }\n\n    const address = getAddress();\n\n    if (!address) {\n      return;\n    }\n\n    this.address = address;\n  };\n\n  cancelAction: (() => Promise<void>) | undefined = undefined;\n\n  /**\n   * This method should be overridden by subclasses to handle cancel login event.\n   */\n  // async cancelAction(): Promise<void> {\n  //   throw new Error('Method not implemented.');\n  // }\n\n  protected async initSignState() {\n    const { onClose, manager } = await getPendingTransactionsHandlers({\n      cancelAction: this.cancelAction?.bind(this)\n    });\n\n    const type = this.getType();\n    manager.subscribeToEventBus(PendingTransactionsEventsEnum.CLOSE, onClose);\n\n    manager.updateData({\n      name: providerLabels[type],\n      type\n    });\n\n    return { onClose, manager };\n  }\n}\n"],
  "mappings": "2HAcO,IAAeA,EAAf,KAGP,CAUE,YAAYC,EAAkB,CAT9B,KAAU,QAAmB,GAC7B,KAAU,OAEC,KACX,KAAU,qBAA+C,KA6EzD,KAAO,YAAc,IAAM,CACrB,KAAK,sBACP,KAAK,qBAAqB,MAAM,EAGlC,KAAK,eAAe,EACpB,KAAK,qBAAuB,IAC9B,EAEA,KAAU,eAAiB,MACzBC,GACoD,CACpD,GAAI,CAAC,KAAK,OACR,MAAM,IAAI,oCAAuC,EAGnD,IAAMC,EAAS,MAAM,KAAK,OAAOD,CAAO,EAExC,GAAI,CAACC,GAAQ,QACX,MAAM,IAAI,oCAAuC,EAGnD,MAAO,CACL,GAAGA,EACH,QAASA,EAAO,QAChB,UAAWA,EAAO,WAAa,EACjC,CACF,EAKA,KAAU,kBAAoB,IAAM,CAClC,GAAI,KAAK,QACP,OAGF,IAAMF,EAAUG,EAAW,EAEtBH,IAIL,KAAK,QAAUA,EACjB,EAEA,kBAAkD,OArHhD,KAAK,QAAUA,GAAW,EAC5B,CAYA,YAA0C,CACxC,MAAM,IAAI,MAAM,yBAAyB,CAC3C,CAEA,gBACEI,EACAC,EAC6B,CAC7B,MAAM,IAAI,MAAM,yBAAyB,CAC3C,CAYA,MAAa,MACXJ,EACiD,CACjD,GAAI,CAAC,KAAK,OACR,MAAM,IAAI,oCAAuC,EAG/C,KAAK,sBACP,KAAK,qBAAqB,MAAM,EAGlC,IAAMK,EAAa,IAAI,gBACvB,KAAK,qBAAuBA,EAE5B,IAAMC,EAASD,EAAW,OAE1B,GAAI,CACF,IAAME,EAAe,IAAI,QAAe,CAACC,EAAGC,IAAW,CACrDH,EAAO,iBAAiB,QAAS,IAAM,CACrCG,EAAO,IAAI,MAAM,iBAAiB,CAAC,CACrC,CAAC,CACH,CAAC,EAEKC,EAAc,MAAM,QAAQ,KAAK,CACrC,KAAK,eAAeV,CAAO,EAC3BO,CACF,CAAC,EAED,YAAK,qBAAuB,KAErBG,CACT,OAASC,EAAO,CACd,WAAK,qBAAuB,KACtBA,CACR,CACF,CAyDA,MAAgB,eAAgB,CAC9B,GAAM,CAAE,QAAAC,EAAS,QAAAC,CAAQ,EAAI,MAAMC,EAA+B,CAChE,aAAc,KAAK,cAAc,KAAK,IAAI,CAC5C,CAAC,EAEKC,EAAO,KAAK,QAAQ,EAC1B,OAAAF,EAAQ,iDAAyDD,CAAO,EAExEC,EAAQ,WAAW,CACjB,KAAMG,EAAeD,CAAI,EACzB,KAAAA,CACF,CAAC,EAEM,CAAE,QAAAH,EAAS,QAAAC,CAAQ,CAC5B,CACF",
  "names": ["BaseProviderStrategy", "address", "options", "result", "getAddress", "_transaction", "_options", "controller", "signal", "abortPromise", "_", "reject", "loginResult", "error", "onClose", "manager", "getPendingTransactionsHandlers", "type", "providerLabels"]
}
