{
  "version": 3,
  "sources": ["../../src/managers/internal/ToastManager/ToastManager.ts", "../../src/managers/NotificationsFeedManager/NotificationsFeedManager.ts", "../../src/managers/LogoutManager/LogoutManager.ts", "../../src/providers/DappProvider/helpers/login/helpers/accountLogin.ts", "../../src/providers/DappProvider/helpers/login/login.ts", "../../src/providers/DappProvider/helpers/signErrors/handleSignError.ts", "../../src/providers/DappProvider/helpers/signTransactions/signTransactionsWithProvider.ts", "../../src/providers/DappProvider/DappProvider.ts", "../../src/providers/helpers/accountProvider.ts", "../../src/utils/account/refreshAccount.ts", "../../src/store/actions/toasts/toastsActions.ts", "../../src/managers/internal/ToastManager/helpers/LifetimeManager.ts"],
  "sourcesContent": ["import isEqual from 'lodash.isequal';\nimport { DEFAULT_TOAST_LIEFTIME } from 'constants/transactions.constants';\nimport { UITagsEnum } from 'constants/UITags.enum';\nimport { MvxToastList } from 'lib/sdkDappUi';\nimport { NotificationsFeedManager } from 'managers/NotificationsFeedManager/NotificationsFeedManager';\nimport {\n  customToastCloseHandlersDictionary,\n  customToastComponentDictionary,\n  removeAllCustomToasts,\n  removeCustomToast,\n  removeTransactionToast,\n  addTransactionToast,\n  createCustomToast\n} from 'store/actions/toasts/toastsActions';\nimport {\n  getIsTransactionFailed,\n  getIsTransactionSuccessful,\n  getIsTransactionTimedOut\n} from 'store/actions/transactions/transactionStateByStatus';\n\nimport { CustomToastType } from 'store/slices/toast/toastSlice.types';\nimport { getStore } from 'store/store';\nimport { IEventBus } from 'types/manager.types';\nimport { ProviderErrorsEnum } from 'types/provider.types';\nimport { ComponentFactory } from 'utils/ComponentFactory';\nimport { createToastsFromTransactions } from './helpers/createToastsFromTransactions';\nimport { LifetimeManager } from './helpers/LifetimeManager';\nimport { ITransactionToast, ToastEventsEnum } from './types';\n\ninterface IToastManager {\n  successfulToastLifetime?: number;\n}\n\nexport class ToastManager {\n  private readonly lifetimeManager: LifetimeManager;\n  private isCreatingElement = false;\n  private static instance: ToastManager;\n  private toastsElement: MvxToastList | null = null;\n  private transactionToasts: ITransactionToast[] = [];\n  private customToasts: CustomToastType[] = [];\n  private successfulToastLifetime?: number;\n  private storeToastsSubscription: () => void = () => null;\n  private readonly notificationsFeedManager: NotificationsFeedManager;\n  private eventBusUnsubscribeFunctions: (() => void)[] = [];\n  private eventBus: IEventBus<\n    ITransactionToast[] | CustomToastType[] | null\n  > | null = null;\n\n  store = getStore();\n\n  constructor() {\n    this.destroy();\n    this.lifetimeManager = new LifetimeManager();\n\n    this.notificationsFeedManager = NotificationsFeedManager.getInstance();\n  }\n\n  public async init({\n    successfulToastLifetime = DEFAULT_TOAST_LIEFTIME\n  }: IToastManager = {}) {\n    this.successfulToastLifetime = successfulToastLifetime;\n\n    this.lifetimeManager.init({ successfulToastLifetime });\n\n    await this.updateTransactionToastsList();\n    await this.updateCustomToastList();\n\n    await this.subscribeToEventBusNotifications();\n\n    this.storeToastsSubscription = this.store.subscribe(\n      async (\n        { toasts, transactions },\n        { toasts: prevToasts, transactions: prevTransactions }\n      ) => {\n        if (\n          !isEqual(prevToasts.transactionToasts, toasts.transactionToasts) ||\n          !isEqual(prevTransactions, transactions)\n        ) {\n          await this.updateTransactionToastsList();\n        }\n\n        if (!isEqual(prevToasts.customToasts, toasts.customToasts)) {\n          await this.updateCustomToastList();\n        }\n      }\n    );\n  }\n\n  public static getInstance(): ToastManager {\n    if (!ToastManager.instance) {\n      ToastManager.instance = new ToastManager();\n    }\n    return ToastManager.instance;\n  }\n\n  private handleCompletedTransaction(toastId: string): boolean {\n    const { transactions } = this.store.getState();\n    const transaction = transactions[toastId];\n\n    if (!transaction) {\n      return false;\n    }\n\n    const { status } = transaction;\n    const isTimedOut = getIsTransactionTimedOut(status);\n    const isFailed = getIsTransactionFailed(status);\n    const isSuccessful = getIsTransactionSuccessful(status);\n    const isCompleted = isFailed || isSuccessful || isTimedOut;\n\n    if (isCompleted) {\n      if (this.successfulToastLifetime) {\n        this.lifetimeManager.start(toastId);\n      }\n      return isCompleted;\n    }\n\n    this.lifetimeManager.stop(toastId);\n    return isCompleted;\n  }\n\n  public async createTransactionToast(\n    toastId: string,\n    totalDuration: number\n  ): Promise<string> {\n    const newToastId = addTransactionToast({\n      toastId,\n      totalDuration\n    });\n\n    this.handleCompletedTransaction(toastId);\n    await this.updateTransactionToastsList();\n    return newToastId;\n  }\n\n  public createCustomToast(toast: CustomToastType): string {\n    const toastId = createCustomToast(toast);\n    this.updateCustomToastList();\n    return toastId;\n  }\n\n  private async updateTransactionToastsList() {\n    const {\n      toasts: toastList,\n      transactions: transactionsSessions,\n      account\n    } = this.store.getState();\n\n    const { pendingTransactionToasts, completedTransactionToasts } =\n      await createToastsFromTransactions({\n        toastList,\n        transactionsSessions,\n        account\n      });\n\n    this.transactionToasts = [\n      ...pendingTransactionToasts,\n      ...completedTransactionToasts\n    ];\n\n    for (const toast of toastList.transactionToasts) {\n      this.handleCompletedTransaction(toast.toastId);\n    }\n\n    await this.publishTransactionToasts();\n  }\n\n  private async updateCustomToastList() {\n    const { toasts: toastList } = this.store.getState();\n    this.customToasts = [];\n\n    for (const toast of toastList.customToasts) {\n      const isSimpleToast = 'message' in toast;\n\n      const newToast: CustomToastType = isSimpleToast\n        ? { ...toast }\n        : {\n            ...toast,\n            instantiateToastElement:\n              customToastComponentDictionary[toast.toastId]\n          };\n      this.customToasts.push(newToast);\n\n      if (toast.duration) {\n        this.lifetimeManager.startWithCustomDuration(\n          toast.toastId,\n          toast.duration\n        );\n      }\n    }\n    this.eventBus?.publish(\n      ToastEventsEnum.CUSTOM_TOAST_DATA_UPDATE,\n      this.customToasts\n    );\n  }\n\n  private async createToastListElement(): Promise<MvxToastList | null> {\n    if (this.toastsElement) {\n      return this.toastsElement;\n    }\n\n    if (!this.isCreatingElement) {\n      this.isCreatingElement = true;\n\n      this.toastsElement = await ComponentFactory.create<MvxToastList>({\n        name: UITagsEnum.TOAST_LIST\n      });\n\n      this.isCreatingElement = false;\n    }\n\n    return this.toastsElement;\n  }\n\n  private handleTransactionToastClose(toastId: string) {\n    const isCompleted = this.handleCompletedTransaction(toastId);\n\n    if (isCompleted) {\n      removeTransactionToast(toastId);\n    }\n  }\n\n  private async subscribeToEventBusNotifications() {\n    const toastsElement = await this.createToastListElement();\n\n    if (!toastsElement) {\n      return;\n    }\n\n    this.eventBus = await toastsElement.getEventBus();\n    if (!this.eventBus) {\n      throw new Error(ProviderErrorsEnum.eventBusError);\n    }\n\n    this.eventBus.subscribe(\n      ToastEventsEnum.CLOSE,\n      this.handleCloseToast.bind(this)\n    );\n\n    this.eventBusUnsubscribeFunctions.push(() => {\n      this.eventBus?.unsubscribe(\n        ToastEventsEnum.CLOSE,\n        this.handleCloseToast.bind(this)\n      );\n    });\n\n    this.eventBus.subscribe(\n      ToastEventsEnum.OPEN_NOTIFICATIONS_FEED,\n      this.handleOpenNotificationsFeed.bind(this)\n    );\n\n    this.eventBusUnsubscribeFunctions.push(() => {\n      this.eventBus?.unsubscribe(\n        ToastEventsEnum.OPEN_NOTIFICATIONS_FEED,\n        this.handleOpenNotificationsFeed.bind(this)\n      );\n    });\n  }\n\n  public async showToasts() {\n    this.eventBus?.publish(ToastEventsEnum.SHOW, null);\n\n    await this.updateCustomToastList();\n    await this.updateTransactionToastsList();\n  }\n\n  public hideToasts() {\n    this.eventBus?.publish(ToastEventsEnum.HIDE, null);\n  }\n\n  private async handleOpenNotificationsFeed() {\n    this.notificationsFeedManager.openNotificationsFeed();\n  }\n\n  private handleCloseToast(toastId: string) {\n    const customToast = this.customToasts.find(\n      (toast) => toast.toastId === toastId\n    );\n\n    if (customToast) {\n      this.lifetimeManager.stop(toastId);\n      const handleClose = customToastCloseHandlersDictionary[toastId];\n      handleClose?.();\n      removeCustomToast(toastId);\n      return;\n    }\n\n    this.handleTransactionToastClose(toastId);\n  }\n\n  private async publishTransactionToasts() {\n    if (\n      this.notificationsFeedManager.isNotificationsFeedOpen() &&\n      this.eventBus\n    ) {\n      this.eventBus.publish(\n        ToastEventsEnum.TRANSACTION_TOAST_DATA_UPDATE,\n        this.transactionToasts\n      );\n\n      this.hideToasts();\n      return;\n    }\n\n    if (!this.eventBus) {\n      const toastsElement = await this.createToastListElement();\n\n      if (!toastsElement) {\n        return;\n      }\n\n      this.eventBus = await toastsElement.getEventBus();\n    }\n\n    this.eventBus.publish(\n      ToastEventsEnum.TRANSACTION_TOAST_DATA_UPDATE,\n      this.transactionToasts\n    );\n  }\n\n  public destroy() {\n    this.storeToastsSubscription();\n    this.lifetimeManager?.destroy();\n    this.notificationsFeedManager?.destroy();\n    removeAllCustomToasts();\n    this.eventBusUnsubscribeFunctions.forEach((unsubscribe) => unsubscribe());\n    this.eventBusUnsubscribeFunctions = [];\n  }\n}\n", "import isEqual from 'lodash.isequal';\nimport { UITagsEnum } from 'constants/UITags.enum';\nimport { TransactionsHistoryController } from 'controllers/TransactionsHistoryController';\nimport { ITransactionListItem, MvxNotificationsFeed } from 'lib/sdkDappUi';\nimport { clearCompletedTransactions } from 'store/actions/transactions/transactionsActions';\nimport { getStore } from 'store/store';\nimport { NotificationsFeedEventsEnum } from './types';\nimport { ToastManager } from '../internal';\nimport { SidePanelBaseManager } from '../internal/SidePanelBaseManager/SidePanelBaseManager';\nimport { createToastsFromTransactions } from '../internal/ToastManager/helpers/createToastsFromTransactions';\nimport { ITransactionToast } from '../internal/ToastManager/types';\n\ninterface INotificationsFeedManagerData {\n  pendingTransactions: ITransactionToast[];\n  historicTransactions: ITransactionListItem[];\n}\n\nconst NOTIFICATIONS_FEED_STORE_SUBSCRIBE = 'NOTIFICATIONS_FEED_STORE_SUBSCRIBE';\n\nexport class NotificationsFeedManager extends SidePanelBaseManager<\n  MvxNotificationsFeed,\n  INotificationsFeedManagerData,\n  NotificationsFeedEventsEnum | typeof NOTIFICATIONS_FEED_STORE_SUBSCRIBE\n> {\n  private static instance: NotificationsFeedManager;\n  private readonly store = getStore();\n\n  protected initialData: INotificationsFeedManagerData = {\n    pendingTransactions: [],\n    historicTransactions: []\n  };\n\n  public static getInstance(): NotificationsFeedManager {\n    if (!NotificationsFeedManager.instance) {\n      NotificationsFeedManager.instance = new NotificationsFeedManager();\n    }\n    return NotificationsFeedManager.instance;\n  }\n\n  constructor() {\n    super({\n      uiDataUpdateEvent: NotificationsFeedEventsEnum.OPEN,\n      uiTag: UITagsEnum.NOTIFICATIONS_FEED\n    });\n    this.data = { ...this.initialData };\n  }\n\n  public isNotificationsFeedOpen(): boolean {\n    return this.isOpen;\n  }\n\n  /**\n   * Open the notifications feed and toggle off the toast manager.\n   */\n  public async openNotificationsFeed(): Promise<void> {\n    const toastManager = ToastManager.getInstance();\n    toastManager.hideToasts();\n    await this.openUI();\n    await this.updateDataAndNotifications();\n\n    const storeToastsUnsubscribe = this.store.subscribe(\n      async (\n        { toasts, transactions },\n        { toasts: prevToasts, transactions: prevTransactions }\n      ) => {\n        if (\n          !isEqual(prevToasts.transactionToasts, toasts.transactionToasts) ||\n          !isEqual(prevTransactions, transactions)\n        ) {\n          await this.updateDataAndNotifications();\n        }\n      }\n    );\n    this.unsubscribeFunctions.set(NOTIFICATIONS_FEED_STORE_SUBSCRIBE, [\n      storeToastsUnsubscribe\n    ]);\n\n    this.eventBus?.publish(NotificationsFeedEventsEnum.OPEN);\n    await this.updateDataAndNotifications();\n  }\n\n  /**\n   * Close the notifications feed and toggle on the toast manager.\n   */\n  protected async handleCloseUI() {\n    const toastManager = ToastManager.getInstance();\n    this.closeUI();\n    await toastManager.showToasts();\n  }\n\n  protected async setupEventListeners() {\n    if (!this.eventBus) {\n      return;\n    }\n\n    this.subscribeToEventBus(\n      NotificationsFeedEventsEnum.CLOSE,\n      this.handleCloseUI.bind(this)\n    );\n\n    this.subscribeToEventBus(\n      NotificationsFeedEventsEnum.CLEAR,\n      this.handleClearNotificationsFeedHistory.bind(this)\n    );\n  }\n\n  protected async updateDataAndNotifications() {\n    const { transactions, account, toasts, network } = this.store.getState();\n\n    const { pendingTransactionToasts } = await createToastsFromTransactions({\n      toastList: toasts,\n      transactionsSessions: transactions,\n      account\n    });\n\n    this.data.pendingTransactions = pendingTransactionToasts;\n\n    this.data.historicTransactions =\n      await TransactionsHistoryController.getTransactionsHistory({\n        transactionsSessions: transactions,\n        address: account.address,\n        explorerAddress: network.network.explorerAddress,\n        egldLabel: network.network.egldLabel\n      });\n\n    await this.updateNotificationsFeed();\n  }\n\n  private handleClearNotificationsFeedHistory() {\n    clearCompletedTransactions();\n    this.resetData();\n    this.updateNotificationsFeed();\n  }\n\n  private async updateNotificationsFeed() {\n    if (!this.eventBus) {\n      return;\n    }\n\n    this.eventBus.publish(\n      NotificationsFeedEventsEnum.PENDING_TRANSACTIONS_UPDATE,\n      this.data.pendingTransactions\n    );\n\n    this.eventBus.publish(\n      NotificationsFeedEventsEnum.TRANSACTIONS_HISTORY_UPDATE,\n      this.data.historicTransactions\n    );\n  }\n}\n", "import BigNumber from 'bignumber.js';\nimport { ToastIconsEnum } from 'managers/internal/ToastManager/helpers/getToastDataStateByStatus';\nimport { ToastManager } from 'managers/internal/ToastManager/ToastManager';\nimport { getAccountProvider } from 'providers/helpers/accountProvider';\nimport { ProviderTypeEnum } from 'providers/types/providerFactory.types';\nimport { getTokenExpiration } from 'services/nativeAuth/methods/getTokenExpiration';\nimport {\n  addressSelector,\n  isLoggedInSelector\n} from 'store/selectors/accountSelectors';\nimport { nativeAuthConfigSelector } from 'store/selectors/configSelectors';\nimport { tokenLoginSelector } from 'store/selectors/loginInfoSelectors';\nimport { getStore } from 'store/store';\nimport { getHumanReadableTokenExpirationTime } from './helpers/getHumanReadableTokenExpirationTime';\n\nexport class LogoutManager {\n  private static instance: LogoutManager;\n  private store = getStore();\n  private warningLogoutTimeoutRef: ReturnType<typeof setInterval> | null = null;\n  private actualLogoutTimeoutRef: ReturnType<typeof setInterval> | null = null;\n  private plannedLogoutTimeoutRef: ReturnType<typeof setInterval> | null = null;\n  private plannedLogoutKey: string | null = null;\n\n  public static getInstance(): LogoutManager {\n    if (!LogoutManager.instance) {\n      LogoutManager.instance = new LogoutManager();\n    }\n    return LogoutManager.instance;\n  }\n\n  private constructor() {}\n\n  public init = async () => {\n    if (!this.shouldStart()) {\n      return;\n    }\n\n    const state = this.store.getState();\n    const tokenLogin = tokenLoginSelector(state);\n\n    const { isExpired: isNativeAuthTokenExpired } = getTokenExpiration(\n      tokenLogin?.nativeAuthToken\n    );\n\n    if (isNativeAuthTokenExpired) {\n      const provider = getAccountProvider();\n      provider.logout();\n    } else {\n      this.addPlannedLogout();\n    }\n  };\n\n  public stop = () => {\n    clearTimeout(this.warningLogoutTimeoutRef ?? 0);\n    clearTimeout(this.plannedLogoutTimeoutRef ?? 0);\n    clearTimeout(this.actualLogoutTimeoutRef ?? 0);\n\n    this.warningLogoutTimeoutRef = null;\n    this.plannedLogoutTimeoutRef = null;\n    this.actualLogoutTimeoutRef = null;\n    this.plannedLogoutKey = null;\n  };\n\n  private readonly shouldStart = (): boolean => {\n    const state = this.store.getState();\n    const tokenLogin = tokenLoginSelector(state);\n    const isLoggedIn = isLoggedInSelector(state);\n    return Boolean(tokenLogin?.nativeAuthToken && isLoggedIn);\n  };\n\n  private addPlannedLogout = () => {\n    const provider = getAccountProvider();\n    const address = addressSelector(this.store.getState());\n    const isWebviewLogin = provider.getType() === ProviderTypeEnum.webview;\n\n    // prevent unexpected logout if webview login\n    if (!address || isWebviewLogin) {\n      return;\n    }\n\n    this.addLogoutWarning();\n\n    const tokenLogin = tokenLoginSelector(this.store.getState());\n\n    const { secondsUntilExpires, expiresAt } = getTokenExpiration(\n      tokenLogin?.nativeAuthToken\n    );\n\n    // Handle the actual logout functionality.\n    const secondsUntilExpiresBN = new BigNumber(String(secondsUntilExpires));\n    const plannedLogoutKey = `${address}_${expiresAt}`;\n    const plannedLogoutSet = this.plannedLogoutKey === plannedLogoutKey;\n\n    const isValidInterval =\n      secondsUntilExpires && secondsUntilExpiresBN.isGreaterThan(0);\n\n    if (!isValidInterval || plannedLogoutSet) {\n      return;\n    }\n\n    this.plannedLogoutKey = plannedLogoutKey;\n\n    clearTimeout(this.plannedLogoutTimeoutRef ?? 0);\n    const millisecondsUntilLogout = secondsUntilExpiresBN.times(1000);\n\n    this.actualLogoutTimeoutRef = setTimeout(() => {\n      ToastManager.getInstance().createCustomToast({\n        toastId: 'native-auth-logout',\n        iconClassName: 'warning',\n        title: 'Logging out',\n        icon: ToastIconsEnum.times,\n        message: 'Your session has expired!'\n      });\n      this.actualLogoutTimeoutRef = null;\n    }, millisecondsUntilLogout.toNumber() - 3000);\n\n    this.plannedLogoutTimeoutRef = setTimeout(() => {\n      provider.logout();\n      this.plannedLogoutTimeoutRef = null;\n      this.plannedLogoutKey = null;\n    }, millisecondsUntilLogout.toNumber());\n  };\n\n  private readonly addLogoutWarning = () => {\n    if (this.warningLogoutTimeoutRef) {\n      return;\n    }\n\n    const nativeAuthConfig = nativeAuthConfigSelector(this.store.getState());\n    const tokenLogin = tokenLoginSelector(this.store.getState());\n\n    const { secondsUntilExpires } = getTokenExpiration(\n      tokenLogin?.nativeAuthToken\n    );\n\n    const secondsUntilExpiresBN = new BigNumber(String(secondsUntilExpires));\n    const millisecondsUntilLogout = secondsUntilExpiresBN.times(1000);\n\n    if (\n      !secondsUntilExpires ||\n      secondsUntilExpiresBN.isLessThanOrEqualTo(0) ||\n      !nativeAuthConfig?.tokenExpirationToastWarningSeconds\n    ) {\n      return;\n    }\n\n    const logoutWarningOffsetSeconds = new BigNumber(\n      nativeAuthConfig?.tokenExpirationToastWarningSeconds ?? 0\n    );\n\n    const logoutWarningOffsetMilliseconds =\n      logoutWarningOffsetSeconds.times(1000);\n\n    const millisecondsUntilLogoutWarning = secondsUntilExpiresBN\n      .times(1000)\n      .minus(logoutWarningOffsetMilliseconds);\n\n    const readableMinutesUntilLogout = getHumanReadableTokenExpirationTime(\n      millisecondsUntilLogout.toNumber()\n    );\n\n    const timeoutUntilLogoutWarning =\n      millisecondsUntilLogoutWarning.isLessThanOrEqualTo(0)\n        ? 0\n        : millisecondsUntilLogoutWarning.toNumber();\n\n    clearTimeout(this.warningLogoutTimeoutRef ?? 0);\n\n    this.warningLogoutTimeoutRef = setTimeout(() => {\n      ToastManager.getInstance().createCustomToast({\n        toastId: 'native-auth-expired',\n        iconClassName: 'warning',\n        title: 'Session Expiration Warning',\n        icon: ToastIconsEnum.hourglass,\n        message: `Your session will expire in ${readableMinutesUntilLogout}!`\n      });\n      this.warningLogoutTimeoutRef = null;\n    }, timeoutUntilLogoutWarning);\n  };\n}\n", "import { getLatestNonce } from 'methods/account/getLatestNonce';\nimport { setGasStationMetadata } from 'methods/initApp/gastStationMetadata/setGasStationMetadata';\nimport { registerWebsocketListener } from 'methods/initApp/websocket/registerWebsocket';\nimport { trackTransactions } from 'methods/trackTransactions/trackTransactions';\nimport { IProvider } from 'providers/types/providerFactory.types';\nimport { loginAction } from 'store/actions';\nimport { setAccount } from 'store/actions/account';\nimport { AccountType } from 'types/account.types';\nimport { fetchAccount } from 'utils/account/fetchAccount';\nimport { trimUsernameDomain } from 'utils/account/trimUsernameDomain';\n\ninterface IAccountLoginProps {\n  address: string;\n  provider: IProvider;\n  apiAddress: string;\n}\n\nexport async function accountLogin({\n  address,\n  provider,\n  apiAddress\n}: IAccountLoginProps) {\n  const account = await fetchAccount({\n    address,\n    baseURL: apiAddress\n  });\n\n  if (!account) {\n    throw new Error('Account not found');\n  }\n\n  loginAction({\n    address,\n    providerType: provider.getType()\n  });\n\n  const newAccount: AccountType = {\n    ...account,\n    username: trimUsernameDomain(account.username),\n    nonce: getLatestNonce(account)\n  };\n\n  setAccount(newAccount);\n\n  await registerWebsocketListener(address);\n  trackTransactions();\n\n  if (account.shard != null) {\n    await setGasStationMetadata({\n      shard: Number(account.shard),\n      apiAddress\n    });\n  }\n}\n", "import { registerWebsocketListener } from 'methods/initApp/websocket/registerWebsocket';\nimport { getNetworkConfig } from 'methods/network/getNetworkConfig';\nimport { trackTransactions } from 'methods/trackTransactions/trackTransactions';\nimport { IProvider } from 'providers/types/providerFactory.types';\nimport { nativeAuth } from 'services/nativeAuth';\nimport { decodeNativeAuthToken } from 'services/nativeAuth/helpers/decodeNativeAuthToken';\nimport { NativeAuthConfigType } from 'services/nativeAuth/nativeAuth.types';\nimport { setTokenLogin } from 'store/actions/loginInfo/loginInfoActions';\nimport { nativeAuthConfigSelector } from 'store/selectors';\nimport { getState } from 'store/store';\nimport { accountLogin } from './helpers/accountLogin';\nimport { extractAddressFromToken } from './helpers/extractAddressFromToken';\n\nasync function loginWithoutNativeToken(provider: IProvider) {\n  const {\n    network: { apiAddress }\n  } = getNetworkConfig();\n\n  await provider.login();\n\n  const address = await provider.getAddress();\n\n  if (!address) {\n    throw new Error('Address not found');\n  }\n\n  await accountLogin({ address, provider, apiAddress });\n\n  return {\n    address\n  };\n}\n\nasync function loginWithNativeToken({\n  provider,\n  nativeAuthConfig,\n  token\n}: {\n  provider: IProvider;\n  nativeAuthConfig: NativeAuthConfigType;\n  token?: string;\n}) {\n  const {\n    network: { apiAddress }\n  } = getNetworkConfig();\n\n  const nativeAuthClient = nativeAuth(nativeAuthConfig);\n  let loginToken = token;\n\n  if (!loginToken) {\n    loginToken = await nativeAuthClient.initialize({\n      noCache: true\n    });\n  }\n\n  const { address, signature, ...loginResult } = await provider.login({\n    token: loginToken\n  });\n\n  if (!address) {\n    console.warn('Login cancelled.');\n    return null;\n  }\n\n  if (!signature) {\n    console.error('Failed to sign login token');\n    return null;\n  }\n\n  // nativeAuthToken received from hub login\n  const decodedToken = decodeNativeAuthToken(loginResult?.accessToken);\n\n  const nativeAuthToken = decodedToken\n    ? loginResult.accessToken\n    : nativeAuthClient.getToken({\n        address,\n        token: loginToken,\n        signature\n      });\n\n  setTokenLogin({\n    loginToken,\n    signature,\n    nativeAuthToken\n  });\n\n  const extractedAddress = await extractAddressFromToken({\n    loginToken,\n    extraInfoData: {\n      multisig: loginResult?.multisig,\n      impersonate: loginResult?.impersonate\n    },\n    address\n  });\n\n  await accountLogin({\n    address: extractedAddress,\n    provider,\n    apiAddress\n  });\n\n  return {\n    address: extractedAddress,\n    signature\n  };\n}\n\nexport async function login(provider: IProvider, options?: { token?: string }) {\n  const nativeAuthConfig = nativeAuthConfigSelector(getState());\n\n  if (nativeAuthConfig) {\n    const data = await loginWithNativeToken({\n      provider,\n      nativeAuthConfig,\n      token: options?.token\n    });\n    return data;\n  }\n\n  const { address } = await loginWithoutNativeToken(provider);\n\n  await registerWebsocketListener(address);\n  trackTransactions();\n\n  return { address };\n}\n", "import {\n  CANCEL_TRANSACTION_TOAST_DEFAULT_DURATION,\n  CANCEL_TRANSACTION_TOAST_ID,\n  ERROR_SIGNING_TOAST_ID\n} from 'constants/transactions.constants';\nimport { ToastIconsEnum } from 'managers/internal/ToastManager/helpers/getToastDataStateByStatus';\nimport { createCustomToast } from 'store/actions';\nimport { SigningErrorsEnum, SigningWarningsEnum } from 'types/enums.types';\n\nconst states = {\n  error: {\n    title: SigningErrorsEnum.errorSigning.toString(),\n    iconClassName: 'danger',\n    toastId: `${ERROR_SIGNING_TOAST_ID}-${Date.now()}`\n  },\n  warning: {\n    title: SigningWarningsEnum.cancelled.toString(),\n    iconClassName: 'warning',\n    toastId: `${CANCEL_TRANSACTION_TOAST_ID}-${Date.now()}`\n  }\n};\n\nconst errorsMap = {\n  extensionResponse: 'Unable to sign transactions', // extension\n  'Transaction canceled': 'Transaction canceled', // web wallet\n  'cancelled by user': 'Transaction signing cancelled by user', // custom\n  'denied by the user': 'Transaction signing denied by the user' // ledger\n};\n\nconst getUserError = (error: string) => {\n  for (const [key, value] of Object.entries(errorsMap)) {\n    if (error.includes(key)) {\n      return value;\n    }\n  }\n  return SigningErrorsEnum.errorSigning;\n};\n\nexport function handleSignError(\n  error: unknown,\n  type: 'error' | 'warning' = 'error'\n) {\n  const originalError = (error as Error)?.message;\n  const errorMessage = getUserError(originalError);\n\n  const isKnownError = errorMessage !== SigningErrorsEnum.errorSigning;\n\n  const errorType = isKnownError ? 'warning' : type;\n\n  const state = Object.keys(states).includes(errorType)\n    ? states[errorType]\n    : states.error;\n\n  const { toastId, iconClassName, title } = state;\n\n  createCustomToast({\n    toastId,\n    duration: CANCEL_TRANSACTION_TOAST_DEFAULT_DURATION,\n    icon: ToastIconsEnum.times,\n    iconClassName,\n    message: errorMessage,\n    title\n  });\n\n  return errorMessage;\n}\n", "import {\n  Address,\n  Transaction,\n  TransactionOptions,\n  TransactionVersion\n} from 'lib/sdkCore';\nimport { getAccount } from 'methods/account/getAccount';\nimport {\n  IProvider,\n  ProviderTypeEnum\n} from 'providers/types/providerFactory.types';\nimport { setAccountNonce } from 'store/actions';\nimport { refreshAccount } from 'utils';\nimport { computeNonces } from '../computeNonces/computeNonces';\n\nexport type SignTransactionsOptionsType = {\n  skipGuardian?: boolean;\n};\n\ntype SignTransactionsType = {\n  provider: IProvider;\n  transactions: Transaction[];\n  options?: SignTransactionsOptionsType;\n};\n\nexport async function signTransactionsWithProvider({\n  provider,\n  transactions,\n  options = {}\n}: SignTransactionsType): Promise<Transaction[]> {\n  await refreshAccount();\n  const { isGuarded, activeGuardianAddress, nonce } = getAccount();\n  const isLedger = provider.getType() === ProviderTypeEnum.ledger;\n\n  const transactionsWithComputedNonce = computeNonces({\n    latestNonce: nonce,\n    transactions\n  });\n\n  const transactionsToSign =\n    activeGuardianAddress && isGuarded && !options.skipGuardian\n      ? transactionsWithComputedNonce?.map((transaction) => {\n          transaction.version = TransactionVersion.withTxOptions().valueOf();\n          transaction.options = TransactionOptions.withOptions({\n            guarded: true,\n            ...(isLedger ? { hashSign: true } : {})\n          }).valueOf();\n\n          transaction.guardian = Address.newFromBech32(activeGuardianAddress);\n\n          return transaction;\n        })\n      : transactionsWithComputedNonce;\n\n  const signedTransactions: Transaction[] =\n    (await provider.signTransactions(transactionsToSign)) ?? [];\n\n  setAccountNonce(nonce + signedTransactions.length);\n\n  return signedTransactions;\n}\n", "import { Message, Transaction } from 'lib/sdkCore';\nimport { LogoutManager } from 'managers/LogoutManager/LogoutManager';\nimport { setAccountProvider } from 'providers/helpers/accountProvider';\nimport { setProviderType } from 'store/actions/loginInfo/loginInfoActions';\nimport { IProvider } from '../types/providerFactory.types';\nimport { login } from './helpers/login/login';\nimport { logout } from './helpers/logout/logout';\nimport { handleSignError } from './helpers/signErrors/handleSignError';\nimport { signMessageWithProvider } from './helpers/signMessage/signMessageWithProvider';\nimport {\n  verifyMessage,\n  VerifyMessageReturnType\n} from './helpers/signMessage/verifyMessage';\nimport {\n  signTransactionsWithProvider,\n  SignTransactionsOptionsType\n} from './helpers/signTransactions/signTransactionsWithProvider';\n\nexport class DappProvider {\n  private provider: IProvider;\n  private _isLoggingOut = false;\n\n  constructor(provider: IProvider) {\n    this.provider = provider;\n  }\n\n  init(): Promise<boolean> {\n    return this.provider.init();\n  }\n\n  async login(options?: { token?: string }) {\n    const data = await login(this.provider, options);\n    setProviderType(this.provider.getType());\n    setAccountProvider(this);\n    LogoutManager.getInstance().init();\n    return data;\n  }\n\n  isInitialized(): boolean {\n    return this.provider.isInitialized();\n  }\n\n  async logout(\n    options = {\n      shouldBroadcastLogoutAcrossTabs: true\n    }\n  ): Promise<boolean> {\n    if (this._isLoggingOut) {\n      console.warn('Logout already in progress');\n      return false;\n    }\n\n    this._isLoggingOut = true;\n\n    const isLoggedOut = await logout({ provider: this.provider, options });\n\n    this._isLoggingOut = false;\n\n    return isLoggedOut;\n  }\n\n  getType() {\n    return this.provider.getType();\n  }\n\n  /**\n   * @returns The original provider instance.\n   */\n  getProvider() {\n    return this.provider;\n  }\n\n  async signTransactions(\n    transactions: Transaction[],\n    options?: SignTransactionsOptionsType\n  ): Promise<Transaction[]> {\n    try {\n      const signedTransactions = await signTransactionsWithProvider({\n        provider: this.provider,\n        transactions,\n        options\n      });\n      return signedTransactions;\n    } catch (error) {\n      const errorMessage = handleSignError(error);\n      throw new Error(errorMessage);\n    }\n  }\n\n  async signMessage(\n    message: Message,\n    options?: {\n      hasConsentPopup?: boolean;\n    }\n  ): Promise<Message | null> {\n    try {\n      const signedMessage = await signMessageWithProvider({\n        provider: this.provider,\n        message,\n        options\n      });\n      return signedMessage;\n    } catch (error) {\n      const errorMessage = handleSignError(error, 'warning');\n      throw new Error(errorMessage);\n    }\n  }\n\n  /**\n   * @param signedMessage - The signed message to verify in form of a JSON string with `address`, `message` and `signature` properties.\n   * @returns The verification result with `isVerified`, `message` and `address` properties.\n   */\n  async verifyMessage(signedMessage: string): Promise<VerifyMessageReturnType> {\n    return await verifyMessage(signedMessage);\n  }\n\n  cancelLogin(): void {\n    this.provider.cancelLogin?.();\n  }\n}\n", "import { IProvider } from 'providers/types/providerFactory.types';\nimport { DappProvider } from '../DappProvider';\nimport { emptyProvider } from './emptyProvider';\n\nexport type ProvidersType = IProvider;\n\nlet accountProvider: DappProvider | null = null;\n\nexport function setAccountProvider<TProvider extends DappProvider | null>(\n  provider: TProvider\n) {\n  accountProvider = provider;\n}\n\nexport function getAccountProvider(): DappProvider {\n  return accountProvider || new DappProvider(emptyProvider);\n}\n", "import { getAddress } from 'methods/account/getAddress';\nimport { getLatestNonce } from 'methods/account/getLatestNonce';\nimport { getNetworkConfig } from 'methods/network/getNetworkConfig';\nimport { getAccountProvider } from 'providers/helpers/accountProvider';\nimport { setAccount } from 'store/actions';\nimport { fetchAccount } from './fetchAccount';\nimport { trimUsernameDomain } from './trimUsernameDomain';\n\nconst setNewAccount = async () => {\n  try {\n    const address = getAddress();\n    const { network } = getNetworkConfig();\n\n    try {\n      const account = await fetchAccount({\n        address,\n        baseURL: network.apiAddress\n      });\n\n      if (account != null) {\n        const accountData = {\n          ...account,\n          username: trimUsernameDomain(account.username),\n          nonce: getLatestNonce(account)\n        };\n\n        setAccount(accountData);\n\n        return accountData;\n      }\n    } catch (e) {\n      console.error('Failed getting account ', e);\n    }\n  } catch (e) {\n    console.error('Failed getting address ', e);\n  }\n\n  return null;\n};\n\nexport async function refreshAccount() {\n  const provider = getAccountProvider();\n\n  if (provider == null) {\n    throw 'Provider not initialized';\n  }\n\n  try {\n    if (!provider.init) {\n      throw 'Current provider does not have init() function';\n    }\n\n    const initialized = await provider.init();\n\n    if (!initialized) {\n      return;\n    }\n\n    return setNewAccount();\n  } catch (e) {\n    console.error('Failed initializing provider ', e);\n  }\n\n  return undefined;\n}\n", "import {\n  CustomToastType,\n  IComponentToast\n} from 'store/slices/toast/toastSlice.types';\nimport { getStore } from 'store/store';\nimport { getUnixTimestamp, getUnixTimestampWithAddedMilliseconds } from 'utils';\n\nexport const customToastComponentDictionary: Record<\n  string,\n  IComponentToast['instantiateToastElement']\n> = {};\nexport const customToastCloseHandlersDictionary: Record<string, () => void> =\n  {};\n\nexport const addCustomToast = (\n  customToast: CustomToastType,\n  currentToastId?: string\n) => {\n  getStore().setState(\n    ({ toasts: state }) => {\n      const lastToastIndex =\n        state.customToasts.length > 0\n          ? Math.max(\n              ...state.customToasts.map((toast) =>\n                parseInt(toast.toastId.split('-').pop() ?? '0')\n              )\n            )\n          : 0;\n      const toastId = currentToastId ?? `custom-toast-${lastToastIndex + 1}`;\n\n      const existingToastIndex = state.customToasts.findIndex(\n        (toast) => toast.toastId === toastId\n      );\n\n      const newToast: CustomToastType = {\n        ...customToast,\n        toastId\n      };\n\n      const isToastFound = existingToastIndex !== -1;\n\n      if (isToastFound) {\n        state.customToasts[existingToastIndex] = newToast;\n        return;\n      }\n\n      state.customToasts.push({\n        ...newToast,\n        toastId\n      });\n    },\n    false,\n    'addCustomToast'\n  );\n};\n\nexport const removeCustomToast = (toastId: string) => {\n  getStore().setState(\n    ({ toasts: state }) => {\n      state.customToasts = state.customToasts.filter(\n        (toast) => toast.toastId !== toastId\n      );\n    },\n    false,\n    'removeCustomToast'\n  );\n};\n\nexport const removeAllCustomToasts = () => {\n  getStore().setState(\n    ({ toasts: state }) => {\n      state.customToasts = [];\n    },\n    false,\n    'removeAllCustomToasts'\n  );\n};\n\nexport const removeAllTransactionToasts = () => {\n  getStore().setState(({ toasts: state }) => {\n    state.transactionToasts = [];\n  });\n};\n\nexport const addTransactionToast = ({\n  toastId,\n  totalDuration\n}: {\n  toastId: string;\n  totalDuration: number;\n}): string => {\n  let newToastId: string = '';\n  getStore().setState(\n    ({ toasts: state }) => {\n      const lastToastIndex =\n        state.transactionToasts.length > 0\n          ? Math.max(\n              ...state.transactionToasts.map((toast) =>\n                parseInt(toast.toastId.split('-').pop() ?? '0')\n              )\n            )\n          : 0;\n      newToastId = toastId ?? `transaction-toast-${lastToastIndex + 1}`;\n\n      state.transactionToasts.push({\n        startTime: getUnixTimestamp(),\n        endTime: getUnixTimestampWithAddedMilliseconds(totalDuration),\n        toastId: newToastId\n      });\n    },\n    false,\n    'addTransactionToast'\n  );\n\n  return newToastId;\n};\n\nexport const removeTransactionToast = (toastId: string) => {\n  getStore().setState(\n    ({ toasts: state }) => {\n      state.transactionToasts = state.transactionToasts.filter((toast) => {\n        return toast.toastId !== toastId;\n      });\n    },\n    false,\n    'removeTransactionToast'\n  );\n\n  delete customToastCloseHandlersDictionary[toastId];\n  delete customToastComponentDictionary[toastId];\n};\n\nexport const createCustomToast = (props: CustomToastType) => {\n  const { toasts } = getStore().getState();\n\n  const lastToastIndex =\n    toasts.customToasts.length > 0\n      ? Math.max(\n          ...toasts.customToasts.map((toast) =>\n            parseInt(toast.toastId.split('-').pop() ?? '0')\n          )\n        )\n      : 0;\n\n  const toastId = props.toastId || `custom-toast-${lastToastIndex + 1}`;\n\n  if (props.onClose) {\n    customToastCloseHandlersDictionary[toastId] = props.onClose;\n  }\n\n  if (props.instantiateToastElement) {\n    customToastComponentDictionary[toastId] = props.instantiateToastElement;\n\n    getStore().setState(\n      ({ toasts: state }) => {\n        const existingToastIndex = state.customToasts.findIndex(\n          (toast) => toast.toastId === toastId\n        );\n\n        const toast: CustomToastType = {\n          ...props,\n          instantiateToastElement: null,\n          toastId\n        };\n\n        const isToastFound = existingToastIndex !== -1;\n\n        if (isToastFound) {\n          state.customToasts[existingToastIndex] = toast;\n        } else {\n          state.customToasts.push(toast);\n        }\n      },\n      false,\n      'createCustomToast'\n    );\n\n    return toastId;\n  }\n\n  addCustomToast(props, toastId);\n  return toastId;\n};\n", "import {\n  customToastCloseHandlersDictionary,\n  removeCustomToast,\n  removeTransactionToast\n} from 'store/actions/toasts/toastsActions';\n\ninterface IToastProgressManagerParams {\n  successfulToastLifetime?: number;\n}\n\nconst DEFAULT_SUCCESSFUL_TOAST_LIFETIME = 10_000;\n\nexport class LifetimeManager {\n  private timeoutIntervals: Map<string, ReturnType<typeof setTimeout>> =\n    new Map();\n  private successfulToastLifetime: number = DEFAULT_SUCCESSFUL_TOAST_LIFETIME;\n\n  constructor() {}\n\n  public init({ successfulToastLifetime }: IToastProgressManagerParams) {\n    this.successfulToastLifetime =\n      successfulToastLifetime || DEFAULT_SUCCESSFUL_TOAST_LIFETIME;\n  }\n\n  public start = (toastId: string) => {\n    this.stop(toastId);\n\n    if (this.successfulToastLifetime <= 0) {\n      return;\n    }\n\n    const timeout = setTimeout(() => {\n      removeTransactionToast(toastId);\n    }, this.successfulToastLifetime);\n\n    this.timeoutIntervals.set(toastId, timeout);\n  };\n\n  public startWithCustomDuration = (toastId: string, duration: number) => {\n    this.stop(toastId);\n\n    if (duration <= 0) {\n      return;\n    }\n\n    const timeout = setTimeout(() => {\n      removeCustomToast(toastId);\n      const handleClose = customToastCloseHandlersDictionary[toastId];\n      handleClose?.();\n    }, duration);\n\n    this.timeoutIntervals.set(toastId, timeout);\n  };\n\n  public stop = (toastId: string) => {\n    const timeout = this.timeoutIntervals.get(toastId);\n    if (timeout) {\n      clearTimeout(timeout);\n      this.timeoutIntervals.delete(toastId);\n    }\n  };\n\n  public destroy() {\n    this.timeoutIntervals.forEach((interval) => clearTimeout(interval));\n    this.timeoutIntervals.clear();\n  }\n}\n"],
  "mappings": "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",
  "names": ["isEqual", "isEqual", "NOTIFICATIONS_FEED_STORE_SUBSCRIBE", "NotificationsFeedManager", "_NotificationsFeedManager", "SidePanelBaseManager", "getStore", "ToastManager", "storeToastsUnsubscribe", "toasts", "transactions", "prevToasts", "prevTransactions", "isEqual", "toastManager", "account", "network", "pendingTransactionToasts", "createToastsFromTransactions", "TransactionsHistoryController", "clearCompletedTransactions", "BigNumber", "LogoutManager", "_LogoutManager", "getStore", "state", "tokenLogin", "tokenLoginSelector", "isNativeAuthTokenExpired", "getTokenExpiration", "getAccountProvider", "isLoggedIn", "isLoggedInSelector", "provider", "address", "addressSelector", "isWebviewLogin", "ProviderTypeEnum", "secondsUntilExpires", "expiresAt", "secondsUntilExpiresBN", "BigNumber", "plannedLogoutKey", "plannedLogoutSet", "millisecondsUntilLogout", "ToastManager", "nativeAuthConfig", "nativeAuthConfigSelector", "logoutWarningOffsetMilliseconds", "millisecondsUntilLogoutWarning", "readableMinutesUntilLogout", "getHumanReadableTokenExpirationTime", "timeoutUntilLogoutWarning", "accountLogin", "address", "provider", "apiAddress", "account", "fetchAccount", "loginAction", "newAccount", "trimUsernameDomain", "getLatestNonce", "setAccount", "registerWebsocketListener", "trackTransactions", "setGasStationMetadata", "loginWithoutNativeToken", "provider", "apiAddress", "getNetworkConfig", "address", "accountLogin", "loginWithNativeToken", "nativeAuthConfig", "token", "nativeAuthClient", "nativeAuth", "loginToken", "signature", "loginResult", "nativeAuthToken", "decodeNativeAuthToken", "setTokenLogin", "extractedAddress", "extractAddressFromToken", "login", "options", "nativeAuthConfigSelector", "getState", "registerWebsocketListener", "trackTransactions", "states", "ERROR_SIGNING_TOAST_ID", "CANCEL_TRANSACTION_TOAST_ID", "errorsMap", "getUserError", "error", "key", "value", "handleSignError", "type", "originalError", "errorMessage", "errorType", "state", "toastId", "iconClassName", "title", "createCustomToast", "signTransactionsWithProvider", "provider", "transactions", "options", "refreshAccount", "isGuarded", "activeGuardianAddress", "nonce", "getAccount", "isLedger", "ProviderTypeEnum", "transactionsWithComputedNonce", "computeNonces", "transactionsToSign", "transaction", "TransactionVersion", "TransactionOptions", "Address", "signedTransactions", "setAccountNonce", "DappProvider", "provider", "options", "data", "login", "setProviderType", "setAccountProvider", "LogoutManager", "isLoggedOut", "logout", "transactions", "signTransactionsWithProvider", "error", "errorMessage", "handleSignError", "message", "signMessageWithProvider", "signedMessage", "verifyMessage", "accountProvider", "setAccountProvider", "provider", "getAccountProvider", "DappProvider", "emptyProvider", "setNewAccount", "address", "getAddress", "network", "getNetworkConfig", "account", "fetchAccount", "accountData", "trimUsernameDomain", "getLatestNonce", "setAccount", "e", "refreshAccount", "provider", "getAccountProvider", "customToastComponentDictionary", "customToastCloseHandlersDictionary", "addCustomToast", "customToast", "currentToastId", "getStore", "state", "lastToastIndex", "toast", "toastId", "existingToastIndex", "newToast", "removeCustomToast", "removeAllCustomToasts", "removeAllTransactionToasts", "addTransactionToast", "totalDuration", "newToastId", "getUnixTimestamp", "getUnixTimestampWithAddedMilliseconds", "removeTransactionToast", "createCustomToast", "props", "toasts", "DEFAULT_SUCCESSFUL_TOAST_LIFETIME", "LifetimeManager", "toastId", "timeout", "removeTransactionToast", "duration", "removeCustomToast", "handleClose", "customToastCloseHandlersDictionary", "successfulToastLifetime", "interval", "ToastManager", "_ToastManager", "getStore", "LifetimeManager", "NotificationsFeedManager", "successfulToastLifetime", "toasts", "transactions", "prevToasts", "prevTransactions", "isEqual", "toastId", "transaction", "status", "isTimedOut", "getIsTransactionTimedOut", "isFailed", "getIsTransactionFailed", "isSuccessful", "getIsTransactionSuccessful", "isCompleted", "totalDuration", "newToastId", "addTransactionToast", "toast", "createCustomToast", "toastList", "transactionsSessions", "account", "pendingTransactionToasts", "completedTransactionToasts", "createToastsFromTransactions", "newToast", "customToastComponentDictionary", "ComponentFactory", "removeTransactionToast", "toastsElement", "handleClose", "customToastCloseHandlersDictionary", "removeCustomToast", "removeAllCustomToasts", "unsubscribe"]
}
