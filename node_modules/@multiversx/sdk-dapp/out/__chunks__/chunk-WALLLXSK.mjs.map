{
  "version": 3,
  "sources": ["../../src/providers/strategies/WebviewProviderStrategy/WebviewClient/WebviewClient.ts"],
  "sourcesContent": ["import { safeWindow } from 'constants/index';\nimport { Address, Message, Transaction } from 'lib/sdkCore';\nimport {\n  WindowProviderRequestEnums,\n  WindowProviderResponseEnums,\n  RequestMessageType,\n  RequestPayloadType\n} from 'lib/sdkWebWalletCrossWindowProvider';\nimport { getAccountProvider } from 'providers/helpers/accountProvider';\nimport { accountSelector } from 'store/selectors';\nimport { getStore } from 'store/store';\n\ntype MessageHandler = (event: MessageEvent) => void;\n\ntype MessageEventType = {\n  event: MessageEvent<MessageType>;\n};\n\ntype MessageType =\n  | RequestMessageType\n  | { type: 'cancelAction'; payload: null }\n  | {\n      type: WindowProviderResponseEnums.cancelResponse;\n      payload: null;\n    };\n\nexport class WebviewClient {\n  private readonly handlers: Map<string, MessageHandler> = new Map();\n  private readonly store = getStore();\n  private isLoginInitiated = false;\n  private readonly handleLoginCancelled: () => Promise<void>;\n\n  constructor({ onLoginCancelled }: { onLoginCancelled: () => Promise<void> }) {\n    this.handleMessage = this.handleMessage.bind(this);\n    this.handleLoginCancelled = onLoginCancelled;\n  }\n\n  public startListening() {\n    safeWindow.addEventListener('message', this.handleMessage);\n  }\n\n  public stopListening() {\n    safeWindow.removeEventListener('message', this.handleMessage);\n  }\n\n  public registerEvent(type: string, handler: MessageHandler) {\n    this.handlers.set(type, handler);\n  }\n\n  public unregisterEvent(type: string) {\n    this.handlers.delete(type);\n  }\n\n  private async handleMessage(event: MessageEvent<MessageType>) {\n    const type = event.data?.type;\n\n    if (typeof type === 'string' && this.handlers.has(type)) {\n      const handler = this.handlers.get(type);\n      return handler?.(event);\n    }\n\n    switch (type) {\n      case WindowProviderRequestEnums.finalizeHandshakeRequest:\n        this.handshake({ event });\n        break;\n      case WindowProviderRequestEnums.signMessageRequest:\n        this.signMessage({ event, payload: event.data.payload });\n        break;\n      case WindowProviderRequestEnums.loginRequest:\n        this.isLoginInitiated = true;\n        this.login({ event, payload: event.data.payload });\n        break;\n      case WindowProviderRequestEnums.signTransactionsRequest:\n        this.signTransactions({ event });\n        break;\n      case WindowProviderResponseEnums.cancelResponse: // sent by web-wallet CrossWindow provider\n      case 'cancelAction': // sent by Extension provider\n        if (this.isLoginInitiated) {\n          await this.handleLoginCancelled();\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  private async login({\n    event,\n    payload\n  }: MessageEventType & { payload: RequestPayloadType['LOGIN_REQUEST'] }) {\n    const loginToken = payload?.token;\n\n    if (!loginToken) {\n      return;\n    }\n\n    try {\n      const { address } = accountSelector(this.store.getState());\n      const provider = getAccountProvider();\n\n      const messageToSign = new Message({\n        address: new Address(address),\n        data: new Uint8Array(Buffer.from(loginToken))\n      });\n\n      const signedMessage = await provider.signMessage(messageToSign);\n      const signature = signedMessage?.signature ?? '';\n\n      event.source?.postMessage(\n        {\n          type: WindowProviderResponseEnums.loginResponse,\n          payload: {\n            data: {\n              address,\n              signature: Buffer.from(signature).toString('hex')\n            }\n          }\n        },\n        { targetOrigin: event.origin }\n      );\n    } catch {\n      if (this.isLoginInitiated) {\n        this.handleLoginCancelled();\n      }\n    } finally {\n      this.isLoginInitiated = false;\n    }\n  }\n\n  private handshake({ event }: MessageEventType) {\n    const handshakeSession = Date.now().toString();\n\n    event.source?.postMessage(\n      {\n        type: WindowProviderResponseEnums.finalizeHandshakeResponse,\n        payload: { data: handshakeSession }\n      },\n      { targetOrigin: event.origin }\n    );\n  }\n\n  private async signMessage({\n    event,\n    payload\n  }: MessageEventType & {\n    payload: RequestPayloadType['SIGN_MESSAGE_REQUEST'];\n  }) {\n    const { address } = accountSelector(this.store.getState());\n    const { message } = payload;\n\n    try {\n      const messageToSign = new Message({\n        address: new Address(address),\n        data: new Uint8Array(Buffer.from(message))\n      });\n\n      const provider = getAccountProvider();\n      const signedMessage = await provider.signMessage(messageToSign);\n      const signature = signedMessage?.signature ?? '';\n\n      event.source?.postMessage(\n        {\n          type: WindowProviderResponseEnums.signMessageResponse,\n          payload: {\n            data: {\n              signature: Buffer.from(signature).toString('hex'),\n              status: 'signed'\n            }\n          }\n        },\n        { targetOrigin: event.origin }\n      );\n    } catch {\n      throw new Error('Could not sign message');\n    }\n  }\n\n  private async signTransactions({ event }: MessageEventType) {\n    const provider = getAccountProvider();\n    const { payload } = event.data;\n\n    if (!Array.isArray(payload)) {\n      return;\n    }\n\n    try {\n      const transactions = payload.map((plainTransactionObject) =>\n        Transaction.newFromPlainObject(plainTransactionObject)\n      );\n\n      const signedTx = await provider.signTransactions(transactions);\n      event.source?.postMessage(\n        {\n          type: WindowProviderResponseEnums.signTransactionsResponse,\n          payload: {\n            data: signedTx.map((tx) => tx.toPlainObject())\n          }\n        },\n        { targetOrigin: event.origin }\n      );\n    } catch {\n      throw new Error('Could not sign transactions');\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["WebviewClient", "onLoginCancelled", "getStore", "safeWindow", "type", "handler", "event", "WindowProviderRequestEnums", "WindowProviderResponseEnums", "payload", "loginToken", "address", "accountSelector", "provider", "getAccountProvider", "messageToSign", "Message", "Address", "signature", "handshakeSession", "message", "transactions", "plainTransactionObject", "Transaction", "signedTx", "tx"]
}
