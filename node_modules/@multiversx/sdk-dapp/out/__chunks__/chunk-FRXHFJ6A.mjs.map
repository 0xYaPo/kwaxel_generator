{
  "version": 3,
  "sources": ["../../src/methods/initApp/websocket/initializeWebsocketConnection.ts"],
  "sourcesContent": ["import { io } from 'socket.io-client';\nimport { getWebsocketUrl } from 'apiCalls/websocket';\nimport {\n  WebsocketConnectionStatusEnum,\n  websocketConnection\n} from 'constants/websocket.constants';\nimport {\n  setWebsocketBatchEvent,\n  setWebsocketEvent\n} from 'store/actions/account/accountActions';\nimport { setWebsocketStatus } from 'store/actions/config/configActions';\nimport { networkSelector } from 'store/selectors';\nimport { getStore } from 'store/store';\nimport { BatchTransactionsWSResponseType } from 'types/websocket.types';\nimport { retryMultipleTimes } from 'utils/retryMultipleTimes';\n\nconst TIMEOUT = 3000;\nconst RECONNECTION_ATTEMPTS = 3;\nconst RETRY_INTERVAL = 500;\nconst MESSAGE_DELAY = 1000;\nconst SOCKET_CONNECTION_DELAY = 1000;\nconst BATCH_UPDATED_EVENT = 'batchUpdated';\nconst CONNECT = 'connect';\nconst CONNECT_ERROR = 'connect_error';\nconst DISCONNECT = 'disconnect';\n\ntype TimeoutType = ReturnType<typeof setTimeout> | null;\n\nexport async function initializeWebsocketConnection(address: string) {\n  const { apiAddress, websocketUrl: customWebsocketUrl } = networkSelector(\n    getStore().getState()\n  );\n\n  if (!address) {\n    throw new Error('Websocket could not be initialized: address missing');\n  }\n\n  let messageTimeout: TimeoutType = null;\n  let batchTimeout: TimeoutType = null;\n\n  // Update socket status in store for status subscription\n  const updateSocketStatus = (status: WebsocketConnectionStatusEnum) => {\n    websocketConnection.status = status;\n    setWebsocketStatus(status);\n  };\n\n  const handleMessageReceived = (message: string) => {\n    if (messageTimeout) {\n      clearTimeout(messageTimeout);\n    }\n    messageTimeout = setTimeout(() => {\n      setWebsocketEvent(message);\n    }, MESSAGE_DELAY);\n  };\n\n  const handleBatchUpdate = (data: BatchTransactionsWSResponseType) => {\n    if (batchTimeout) {\n      clearTimeout(batchTimeout);\n    }\n    batchTimeout = setTimeout(() => {\n      setWebsocketBatchEvent(data);\n    }, MESSAGE_DELAY);\n  };\n\n  const closeConnection = () => {\n    const instance = websocketConnection.instance;\n    if (instance) {\n      instance.off(CONNECT_ERROR);\n      instance.off(CONNECT);\n      instance.off(BATCH_UPDATED_EVENT);\n      instance.off(DISCONNECT);\n      instance.close();\n      console.log('Websocket disconnected.');\n    }\n\n    updateSocketStatus(WebsocketConnectionStatusEnum.NOT_INITIALIZED);\n    websocketConnection.instance = null;\n\n    if (messageTimeout) {\n      clearTimeout(messageTimeout);\n    }\n\n    if (batchTimeout) {\n      clearTimeout(batchTimeout);\n    }\n  };\n\n  const initializeConnection = retryMultipleTimes(\n    async () => {\n      const retryWebsocketConnect = async (\n        retries = RECONNECTION_ATTEMPTS,\n        delay = RETRY_INTERVAL\n      ) => {\n        let attempt = 0;\n        let connectionCheckTimeout: TimeoutType = null;\n        let retryTimeout: TimeoutType = null;\n\n        const tryReconnect = async () => {\n          if (attempt >= retries) {\n            console.warn('WebSocket reconnection failed after max attempts.');\n            updateSocketStatus(WebsocketConnectionStatusEnum.NOT_INITIALIZED);\n            return;\n          }\n\n          attempt++;\n\n          // Clean up previous socket\n          websocketConnection.instance?.off();\n          websocketConnection.instance?.close();\n          websocketConnection.instance = null;\n\n          try {\n            // Attempt to reconnect\n            await initializeConnection(); // attempt to reconnect\n\n            // Wait briefly and check if socket is actually connected\n            connectionCheckTimeout = setTimeout(() => {\n              const isConnected = websocketConnection.instance?.connected;\n\n              if (!isConnected) {\n                // If not connected, retry the connection\n                retryTimeout = setTimeout(tryReconnect, delay);\n              }\n            }, SOCKET_CONNECTION_DELAY);\n          } catch {\n            // If reconnect fails, retry after delay\n            retryTimeout = setTimeout(tryReconnect, delay);\n          }\n        };\n\n        // Start the reconnection process\n        tryReconnect();\n\n        // Clear any timeouts\n        const clearTimeouts = () => {\n          if (connectionCheckTimeout) {\n            clearTimeout(connectionCheckTimeout);\n            connectionCheckTimeout = null;\n          }\n\n          if (retryTimeout) {\n            clearTimeout(retryTimeout);\n            retryTimeout = null;\n          }\n        };\n\n        return clearTimeouts;\n      };\n\n      updateSocketStatus(WebsocketConnectionStatusEnum.PENDING);\n\n      const websocketUrl =\n        customWebsocketUrl ?? (await getWebsocketUrl(apiAddress));\n\n      if (!websocketUrl) {\n        updateSocketStatus(WebsocketConnectionStatusEnum.NOT_INITIALIZED);\n        return;\n      }\n\n      websocketConnection.instance = io(websocketUrl, {\n        forceNew: true,\n        reconnection: true,\n        reconnectionAttempts: RECONNECTION_ATTEMPTS,\n        timeout: TIMEOUT,\n        query: { address }\n      });\n\n      websocketConnection.instance.onAny(handleMessageReceived);\n\n      websocketConnection.instance.on(BATCH_UPDATED_EVENT, handleBatchUpdate);\n\n      websocketConnection.instance.on(CONNECT, () => {\n        console.log('Websocket connected.');\n        updateSocketStatus(WebsocketConnectionStatusEnum.COMPLETED);\n      });\n\n      websocketConnection.instance.on(CONNECT_ERROR, async (error) => {\n        console.warn('Websocket connect error: ', error.message);\n        const clearTimeouts = await retryWebsocketConnect();\n        clearTimeouts();\n      });\n\n      websocketConnection.instance.on(DISCONNECT, async () => {\n        console.warn('Websocket disconnected. Trying to reconnect...');\n        const clearTimeouts = await retryWebsocketConnect();\n        clearTimeouts();\n      });\n    },\n    { retries: 2, delay: RETRY_INTERVAL }\n  );\n\n  if (\n    websocketConnection.status ===\n      WebsocketConnectionStatusEnum.NOT_INITIALIZED &&\n    !websocketConnection.instance?.active\n  ) {\n    await initializeConnection();\n  }\n\n  return {\n    closeConnection\n  };\n}\n"],
  "mappings": "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",
  "names": ["io", "TIMEOUT", "RECONNECTION_ATTEMPTS", "RETRY_INTERVAL", "MESSAGE_DELAY", "SOCKET_CONNECTION_DELAY", "BATCH_UPDATED_EVENT", "CONNECT", "CONNECT_ERROR", "DISCONNECT", "initializeWebsocketConnection", "address", "apiAddress", "customWebsocketUrl", "networkSelector", "getStore", "messageTimeout", "batchTimeout", "updateSocketStatus", "status", "websocketConnection", "setWebsocketStatus", "handleMessageReceived", "message", "setWebsocketEvent", "handleBatchUpdate", "data", "setWebsocketBatchEvent", "closeConnection", "instance", "initializeConnection", "retryMultipleTimes", "retryWebsocketConnect", "retries", "delay", "attempt", "connectionCheckTimeout", "retryTimeout", "tryReconnect", "websocketUrl", "getWebsocketUrl", "io", "error"]
}
