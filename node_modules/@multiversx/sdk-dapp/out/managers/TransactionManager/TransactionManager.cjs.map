{
  "version": 3,
  "sources": ["../../../src/managers/TransactionManager/TransactionManager.ts"],
  "sourcesContent": ["import axios, { AxiosError } from 'axios';\nimport { BATCH_TRANSACTIONS_ID_SEPARATOR } from 'constants/transactions.constants';\nimport { Transaction } from 'lib/sdkCore';\nimport { getAccount } from 'methods/account/getAccount';\nimport { TransactionTrackingConfigType } from 'methods/initApp/initApp.types';\nimport { addTransactionToast } from 'store/actions/toasts/toastsActions';\nimport { createTransactionsSession } from 'store/actions/transactions/transactionsActions';\nimport { networkSelector } from 'store/selectors';\nimport { getState } from 'store/store';\nimport {\n  TransactionBatchStatusesEnum,\n  TransactionServerStatusesEnum\n} from 'types/enums.types';\nimport { BatchTransactionsResponseType } from 'types/serverTransactions.types';\nimport { SignedTransactionType } from 'types/transactions.types';\nimport { isGuardianTx } from 'utils/transactions/isGuardianTx';\nimport { getToastDuration } from './helpers/getToastDuration';\nimport { getTransactionsSessionStatus } from './helpers/getTransactionsStatus';\nimport { isBatchTransaction } from './helpers/isBatchTransaction';\nimport { registerSessionCallbacks } from './helpers/sessionCallbacks';\nimport { TransactionManagerTrackOptionsType } from './TransactionManager.types';\n\nexport class TransactionManager {\n  private static instance: TransactionManager | null = null;\n\n  public static getInstance(): TransactionManager {\n    if (!TransactionManager.instance) {\n      TransactionManager.instance = new TransactionManager();\n    }\n    return TransactionManager.instance;\n  }\n\n  /**\n   * Set callbacks to be executed when the transaction session is successful or fails.\n   * @param onSuccess - The callback to run when the transaction session is successful.\n   * @param onFail - The callback to run when the transaction session fails.\n   * @example\n   * ```ts\n   * TransactionManager.setCallbacks({\n   *   onSuccess: (sessionId) => {\n   *     console.log('Transaction session successful', sessionId);\n   *   },\n   * });\n   */\n  public setCallbacks = ({\n    onSuccess,\n    onFail\n  }: TransactionTrackingConfigType) => {\n    registerSessionCallbacks({ onSuccess, onFail });\n  };\n\n  public send = async (\n    signedTransactions: Transaction[] | Transaction[][]\n  ): Promise<SignedTransactionType[] | SignedTransactionType[][]> => {\n    if (signedTransactions.length === 0) {\n      throw new Error('No transactions to send');\n    }\n\n    try {\n      if (!isBatchTransaction(signedTransactions)) {\n        const flatTransactions =\n          await this.sendSignedTransactions(signedTransactions);\n\n        return flatTransactions;\n      }\n\n      const sentTransactions =\n        await this.sendSignedBatchTransactions(signedTransactions);\n\n      if (!sentTransactions.data || sentTransactions.data.error) {\n        throw new Error(\n          sentTransactions.data?.error ?? 'Failed to send transactions'\n        );\n      }\n\n      const groupedTransactions = sentTransactions.data.transactions;\n\n      return groupedTransactions;\n    } catch (error) {\n      const responseData = <{ message: string }>(\n        (error as AxiosError).response?.data\n      );\n      throw responseData?.message ?? (error as Error).message;\n    }\n  };\n\n  public track = async (\n    sentTransactions: SignedTransactionType[] | SignedTransactionType[][],\n    options: TransactionManagerTrackOptionsType = { disableToasts: false }\n  ): Promise<string> => {\n    const flatTransactions = this.sequentialToFlatArray(sentTransactions).map(\n      (transaction) => ({\n        ...transaction,\n        status: transaction.status ?? TransactionServerStatusesEnum.pending\n      })\n    );\n\n    const status = getTransactionsSessionStatus(flatTransactions);\n\n    const sessionId = createTransactionsSession({\n      transactions: flatTransactions,\n      transactionsDisplayInfo: options.transactionsDisplayInfo,\n      status: status ?? TransactionBatchStatusesEnum.sent,\n      sessionInformation: options.sessionInformation\n    });\n\n    if (options.disableToasts === true) {\n      return sessionId;\n    }\n\n    const totalDuration = getToastDuration(sentTransactions);\n    addTransactionToast({\n      toastId: sessionId,\n      totalDuration\n    });\n\n    return sessionId;\n  };\n\n  private readonly sendSignedTransactions = async (\n    signedTransactions: Transaction[]\n  ): Promise<SignedTransactionType[]> => {\n    const { apiAddress, apiTimeout } = networkSelector(getState());\n\n    const mergedTransactions = await Promise.all(\n      signedTransactions.map(async (transaction) => {\n        const response = await axios.post(\n          `${apiAddress}/transactions`,\n          transaction.toPlainObject(),\n          { timeout: Number(apiTimeout) }\n        );\n\n        const txHash = response.data.txHash;\n\n        return {\n          ...transaction.toPlainObject(),\n          ...response.data,\n          status: TransactionServerStatusesEnum.pending,\n          hash: txHash\n        };\n      })\n    );\n\n    return mergedTransactions;\n  };\n\n  private readonly sendSignedBatchTransactions = async (\n    signedTransactions: Transaction[][]\n  ) => {\n    const { address } = getAccount();\n    const { apiAddress, apiTimeout } = networkSelector(getState());\n\n    if (!address) {\n      return {\n        error:\n          'Invalid address provided. You need to be logged in to send transactions'\n      };\n    }\n\n    const batchId = this.buildBatchId(address);\n\n    const plainTransactions = signedTransactions.map((group) =>\n      group.map((tx) => tx.toPlainObject())\n    );\n\n    const payload = {\n      transactions: plainTransactions,\n      id: batchId\n    };\n\n    const { data } = await axios.post<BatchTransactionsResponseType>(\n      `${apiAddress}/batch`,\n      payload,\n      {\n        timeout: Number(apiTimeout)\n      }\n    );\n\n    const parsedTransactions = data.transactions.map((group) =>\n      group.map((tx) => {\n        const parsedTx: SignedTransactionType = {\n          ...tx,\n          status: TransactionServerStatusesEnum.pending,\n          hash: tx.hash\n        };\n\n        // Remove when the protocol supports usernames for guardian transactions\n        if (isGuardianTx({ data: parsedTx.data })) {\n          delete parsedTx.senderUsername;\n          delete parsedTx.receiverUsername;\n        }\n\n        return parsedTx;\n      })\n    );\n\n    return {\n      data: {\n        ...data,\n        transactions: parsedTransactions\n      }\n    };\n  };\n\n  private readonly buildBatchId = (address: string) => {\n    const sessionId = Date.now().toString();\n    return `${sessionId}${BATCH_TRANSACTIONS_ID_SEPARATOR}${address}`;\n  };\n  private readonly sequentialToFlatArray = (\n    transactions: SignedTransactionType[] | SignedTransactionType[][] = []\n  ) =>\n    this.getIsSequential(transactions)\n      ? transactions.flat()\n      : (transactions as SignedTransactionType[]);\n\n  private readonly getIsSequential = (\n    transactions?: SignedTransactionType[] | SignedTransactionType[][]\n  ) => transactions?.every((transaction) => Array.isArray(transaction));\n}\n"],
  "mappings": "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",
  "names": ["axios"]
}
