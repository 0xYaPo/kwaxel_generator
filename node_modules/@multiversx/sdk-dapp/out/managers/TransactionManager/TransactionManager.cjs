"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var TransactionManager_exports = {};
__export(TransactionManager_exports, {
  TransactionManager: () => TransactionManager
});
module.exports = __toCommonJS(TransactionManager_exports);
var import_axios = __toESM(require("axios"));
var import_transactions = require("../../constants/transactions.constants");
var import_getAccount = require("../../methods/account/getAccount");
var import_toastsActions = require("../../store/actions/toasts/toastsActions");
var import_transactionsActions = require("../../store/actions/transactions/transactionsActions");
var import_selectors = require("../../store/selectors");
var import_store = require("../../store/store");
var import_enums = require("../../types/enums.types");
var import_isGuardianTx = require("../../utils/transactions/isGuardianTx");
var import_getToastDuration = require("./helpers/getToastDuration");
var import_getTransactionsStatus = require("./helpers/getTransactionsStatus");
var import_isBatchTransaction = require("./helpers/isBatchTransaction");
var import_sessionCallbacks = require("./helpers/sessionCallbacks");
const _TransactionManager = class _TransactionManager {
  constructor() {
    /**
     * Set callbacks to be executed when the transaction session is successful or fails.
     * @param onSuccess - The callback to run when the transaction session is successful.
     * @param onFail - The callback to run when the transaction session fails.
     * @example
     * ```ts
     * TransactionManager.setCallbacks({
     *   onSuccess: (sessionId) => {
     *     console.log('Transaction session successful', sessionId);
     *   },
     * });
     */
    this.setCallbacks = ({
      onSuccess,
      onFail
    }) => {
      (0, import_sessionCallbacks.registerSessionCallbacks)({ onSuccess, onFail });
    };
    this.send = async (signedTransactions) => {
      if (signedTransactions.length === 0) {
        throw new Error("No transactions to send");
      }
      try {
        if (!(0, import_isBatchTransaction.isBatchTransaction)(signedTransactions)) {
          const flatTransactions = await this.sendSignedTransactions(signedTransactions);
          return flatTransactions;
        }
        const sentTransactions = await this.sendSignedBatchTransactions(signedTransactions);
        if (!sentTransactions.data || sentTransactions.data.error) {
          throw new Error(
            sentTransactions.data?.error ?? "Failed to send transactions"
          );
        }
        const groupedTransactions = sentTransactions.data.transactions;
        return groupedTransactions;
      } catch (error) {
        const responseData = error.response?.data;
        throw responseData?.message ?? error.message;
      }
    };
    this.track = async (sentTransactions, options = { disableToasts: false }) => {
      const flatTransactions = this.sequentialToFlatArray(sentTransactions).map(
        (transaction) => ({
          ...transaction,
          status: transaction.status ?? import_enums.TransactionServerStatusesEnum.pending
        })
      );
      const status = (0, import_getTransactionsStatus.getTransactionsSessionStatus)(flatTransactions);
      const sessionId = (0, import_transactionsActions.createTransactionsSession)({
        transactions: flatTransactions,
        transactionsDisplayInfo: options.transactionsDisplayInfo,
        status: status ?? import_enums.TransactionBatchStatusesEnum.sent,
        sessionInformation: options.sessionInformation
      });
      if (options.disableToasts === true) {
        return sessionId;
      }
      const totalDuration = (0, import_getToastDuration.getToastDuration)(sentTransactions);
      (0, import_toastsActions.addTransactionToast)({
        toastId: sessionId,
        totalDuration
      });
      return sessionId;
    };
    this.sendSignedTransactions = async (signedTransactions) => {
      const { apiAddress, apiTimeout } = (0, import_selectors.networkSelector)((0, import_store.getState)());
      const mergedTransactions = await Promise.all(
        signedTransactions.map(async (transaction) => {
          const response = await import_axios.default.post(
            `${apiAddress}/transactions`,
            transaction.toPlainObject(),
            { timeout: Number(apiTimeout) }
          );
          const txHash = response.data.txHash;
          return {
            ...transaction.toPlainObject(),
            ...response.data,
            status: import_enums.TransactionServerStatusesEnum.pending,
            hash: txHash
          };
        })
      );
      return mergedTransactions;
    };
    this.sendSignedBatchTransactions = async (signedTransactions) => {
      const { address } = (0, import_getAccount.getAccount)();
      const { apiAddress, apiTimeout } = (0, import_selectors.networkSelector)((0, import_store.getState)());
      if (!address) {
        return {
          error: "Invalid address provided. You need to be logged in to send transactions"
        };
      }
      const batchId = this.buildBatchId(address);
      const plainTransactions = signedTransactions.map(
        (group) => group.map((tx) => tx.toPlainObject())
      );
      const payload = {
        transactions: plainTransactions,
        id: batchId
      };
      const { data } = await import_axios.default.post(
        `${apiAddress}/batch`,
        payload,
        {
          timeout: Number(apiTimeout)
        }
      );
      const parsedTransactions = data.transactions.map(
        (group) => group.map((tx) => {
          const parsedTx = {
            ...tx,
            status: import_enums.TransactionServerStatusesEnum.pending,
            hash: tx.hash
          };
          if ((0, import_isGuardianTx.isGuardianTx)({ data: parsedTx.data })) {
            delete parsedTx.senderUsername;
            delete parsedTx.receiverUsername;
          }
          return parsedTx;
        })
      );
      return {
        data: {
          ...data,
          transactions: parsedTransactions
        }
      };
    };
    this.buildBatchId = (address) => {
      const sessionId = Date.now().toString();
      return `${sessionId}${import_transactions.BATCH_TRANSACTIONS_ID_SEPARATOR}${address}`;
    };
    this.sequentialToFlatArray = (transactions = []) => this.getIsSequential(transactions) ? transactions.flat() : transactions;
    this.getIsSequential = (transactions) => transactions?.every((transaction) => Array.isArray(transaction));
  }
  static getInstance() {
    if (!_TransactionManager.instance) {
      _TransactionManager.instance = new _TransactionManager();
    }
    return _TransactionManager.instance;
  }
};
_TransactionManager.instance = null;
let TransactionManager = _TransactionManager;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TransactionManager
});
//# sourceMappingURL=TransactionManager.cjs.map
