"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var LifetimeManager_exports = {};
__export(LifetimeManager_exports, {
  LifetimeManager: () => LifetimeManager
});
module.exports = __toCommonJS(LifetimeManager_exports);
var import_toastsActions = require("../../../../store/actions/toasts/toastsActions");
const DEFAULT_SUCCESSFUL_TOAST_LIFETIME = 1e4;
class LifetimeManager {
  constructor() {
    this.timeoutIntervals = /* @__PURE__ */ new Map();
    this.successfulToastLifetime = DEFAULT_SUCCESSFUL_TOAST_LIFETIME;
    this.start = (toastId) => {
      this.stop(toastId);
      if (this.successfulToastLifetime <= 0) {
        return;
      }
      const timeout = setTimeout(() => {
        (0, import_toastsActions.removeTransactionToast)(toastId);
      }, this.successfulToastLifetime);
      this.timeoutIntervals.set(toastId, timeout);
    };
    this.startWithCustomDuration = (toastId, duration) => {
      this.stop(toastId);
      if (duration <= 0) {
        return;
      }
      const timeout = setTimeout(() => {
        (0, import_toastsActions.removeCustomToast)(toastId);
        const handleClose = import_toastsActions.customToastCloseHandlersDictionary[toastId];
        handleClose?.();
      }, duration);
      this.timeoutIntervals.set(toastId, timeout);
    };
    this.stop = (toastId) => {
      const timeout = this.timeoutIntervals.get(toastId);
      if (timeout) {
        clearTimeout(timeout);
        this.timeoutIntervals.delete(toastId);
      }
    };
  }
  init({ successfulToastLifetime }) {
    this.successfulToastLifetime = successfulToastLifetime || DEFAULT_SUCCESSFUL_TOAST_LIFETIME;
  }
  destroy() {
    this.timeoutIntervals.forEach((interval) => clearTimeout(interval));
    this.timeoutIntervals.clear();
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  LifetimeManager
});
//# sourceMappingURL=LifetimeManager.cjs.map
