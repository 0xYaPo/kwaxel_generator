"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ToastManager_exports = {};
__export(ToastManager_exports, {
  ToastManager: () => ToastManager
});
module.exports = __toCommonJS(ToastManager_exports);
var import_lodash = __toESM(require("lodash.isequal"));
var import_transactions = require("../../../constants/transactions.constants");
var import_UITags = require("../../../constants/UITags.enum");
var import_NotificationsFeedManager = require("../../../managers/NotificationsFeedManager/NotificationsFeedManager");
var import_toastsActions = require("../../../store/actions/toasts/toastsActions");
var import_transactionStateByStatus = require("../../../store/actions/transactions/transactionStateByStatus");
var import_store = require("../../../store/store");
var import_provider = require("../../../types/provider.types");
var import_ComponentFactory = require("../../../utils/ComponentFactory");
var import_createToastsFromTransactions = require("./helpers/createToastsFromTransactions");
var import_LifetimeManager = require("./helpers/LifetimeManager");
var import_types = require("./types");
class ToastManager {
  constructor() {
    this.isCreatingElement = false;
    this.toastsElement = null;
    this.transactionToasts = [];
    this.customToasts = [];
    this.storeToastsSubscription = () => null;
    this.eventBusUnsubscribeFunctions = [];
    this.eventBus = null;
    this.store = (0, import_store.getStore)();
    this.destroy();
    this.lifetimeManager = new import_LifetimeManager.LifetimeManager();
    this.notificationsFeedManager = import_NotificationsFeedManager.NotificationsFeedManager.getInstance();
  }
  async init({
    successfulToastLifetime = import_transactions.DEFAULT_TOAST_LIEFTIME
  } = {}) {
    this.successfulToastLifetime = successfulToastLifetime;
    this.lifetimeManager.init({ successfulToastLifetime });
    await this.updateTransactionToastsList();
    await this.updateCustomToastList();
    await this.subscribeToEventBusNotifications();
    this.storeToastsSubscription = this.store.subscribe(
      async ({ toasts, transactions }, { toasts: prevToasts, transactions: prevTransactions }) => {
        if (!(0, import_lodash.default)(prevToasts.transactionToasts, toasts.transactionToasts) || !(0, import_lodash.default)(prevTransactions, transactions)) {
          await this.updateTransactionToastsList();
        }
        if (!(0, import_lodash.default)(prevToasts.customToasts, toasts.customToasts)) {
          await this.updateCustomToastList();
        }
      }
    );
  }
  static getInstance() {
    if (!ToastManager.instance) {
      ToastManager.instance = new ToastManager();
    }
    return ToastManager.instance;
  }
  handleCompletedTransaction(toastId) {
    const { transactions } = this.store.getState();
    const transaction = transactions[toastId];
    if (!transaction) {
      return false;
    }
    const { status } = transaction;
    const isTimedOut = (0, import_transactionStateByStatus.getIsTransactionTimedOut)(status);
    const isFailed = (0, import_transactionStateByStatus.getIsTransactionFailed)(status);
    const isSuccessful = (0, import_transactionStateByStatus.getIsTransactionSuccessful)(status);
    const isCompleted = isFailed || isSuccessful || isTimedOut;
    if (isCompleted) {
      if (this.successfulToastLifetime) {
        this.lifetimeManager.start(toastId);
      }
      return isCompleted;
    }
    this.lifetimeManager.stop(toastId);
    return isCompleted;
  }
  async createTransactionToast(toastId, totalDuration) {
    const newToastId = (0, import_toastsActions.addTransactionToast)({
      toastId,
      totalDuration
    });
    this.handleCompletedTransaction(toastId);
    await this.updateTransactionToastsList();
    return newToastId;
  }
  createCustomToast(toast) {
    const toastId = (0, import_toastsActions.createCustomToast)(toast);
    this.updateCustomToastList();
    return toastId;
  }
  async updateTransactionToastsList() {
    const {
      toasts: toastList,
      transactions: transactionsSessions,
      account
    } = this.store.getState();
    const { pendingTransactionToasts, completedTransactionToasts } = await (0, import_createToastsFromTransactions.createToastsFromTransactions)({
      toastList,
      transactionsSessions,
      account
    });
    this.transactionToasts = [
      ...pendingTransactionToasts,
      ...completedTransactionToasts
    ];
    for (const toast of toastList.transactionToasts) {
      this.handleCompletedTransaction(toast.toastId);
    }
    await this.publishTransactionToasts();
  }
  async updateCustomToastList() {
    const { toasts: toastList } = this.store.getState();
    this.customToasts = [];
    for (const toast of toastList.customToasts) {
      const isSimpleToast = "message" in toast;
      const newToast = isSimpleToast ? { ...toast } : {
        ...toast,
        instantiateToastElement: import_toastsActions.customToastComponentDictionary[toast.toastId]
      };
      this.customToasts.push(newToast);
      if (toast.duration) {
        this.lifetimeManager.startWithCustomDuration(
          toast.toastId,
          toast.duration
        );
      }
    }
    this.eventBus?.publish(
      import_types.ToastEventsEnum.CUSTOM_TOAST_DATA_UPDATE,
      this.customToasts
    );
  }
  async createToastListElement() {
    if (this.toastsElement) {
      return this.toastsElement;
    }
    if (!this.isCreatingElement) {
      this.isCreatingElement = true;
      this.toastsElement = await import_ComponentFactory.ComponentFactory.create({
        name: import_UITags.UITagsEnum.TOAST_LIST
      });
      this.isCreatingElement = false;
    }
    return this.toastsElement;
  }
  handleTransactionToastClose(toastId) {
    const isCompleted = this.handleCompletedTransaction(toastId);
    if (isCompleted) {
      (0, import_toastsActions.removeTransactionToast)(toastId);
    }
  }
  async subscribeToEventBusNotifications() {
    const toastsElement = await this.createToastListElement();
    if (!toastsElement) {
      return;
    }
    this.eventBus = await toastsElement.getEventBus();
    if (!this.eventBus) {
      throw new Error(import_provider.ProviderErrorsEnum.eventBusError);
    }
    this.eventBus.subscribe(
      import_types.ToastEventsEnum.CLOSE,
      this.handleCloseToast.bind(this)
    );
    this.eventBusUnsubscribeFunctions.push(() => {
      this.eventBus?.unsubscribe(
        import_types.ToastEventsEnum.CLOSE,
        this.handleCloseToast.bind(this)
      );
    });
    this.eventBus.subscribe(
      import_types.ToastEventsEnum.OPEN_NOTIFICATIONS_FEED,
      this.handleOpenNotificationsFeed.bind(this)
    );
    this.eventBusUnsubscribeFunctions.push(() => {
      this.eventBus?.unsubscribe(
        import_types.ToastEventsEnum.OPEN_NOTIFICATIONS_FEED,
        this.handleOpenNotificationsFeed.bind(this)
      );
    });
  }
  async showToasts() {
    this.eventBus?.publish(import_types.ToastEventsEnum.SHOW, null);
    await this.updateCustomToastList();
    await this.updateTransactionToastsList();
  }
  hideToasts() {
    this.eventBus?.publish(import_types.ToastEventsEnum.HIDE, null);
  }
  async handleOpenNotificationsFeed() {
    this.notificationsFeedManager.openNotificationsFeed();
  }
  handleCloseToast(toastId) {
    const customToast = this.customToasts.find(
      (toast) => toast.toastId === toastId
    );
    if (customToast) {
      this.lifetimeManager.stop(toastId);
      const handleClose = import_toastsActions.customToastCloseHandlersDictionary[toastId];
      handleClose?.();
      (0, import_toastsActions.removeCustomToast)(toastId);
      return;
    }
    this.handleTransactionToastClose(toastId);
  }
  async publishTransactionToasts() {
    if (this.notificationsFeedManager.isNotificationsFeedOpen() && this.eventBus) {
      this.eventBus.publish(
        import_types.ToastEventsEnum.TRANSACTION_TOAST_DATA_UPDATE,
        this.transactionToasts
      );
      this.hideToasts();
      return;
    }
    if (!this.eventBus) {
      const toastsElement = await this.createToastListElement();
      if (!toastsElement) {
        return;
      }
      this.eventBus = await toastsElement.getEventBus();
    }
    this.eventBus.publish(
      import_types.ToastEventsEnum.TRANSACTION_TOAST_DATA_UPDATE,
      this.transactionToasts
    );
  }
  destroy() {
    this.storeToastsSubscription();
    this.lifetimeManager?.destroy();
    this.notificationsFeedManager?.destroy();
    (0, import_toastsActions.removeAllCustomToasts)();
    this.eventBusUnsubscribeFunctions.forEach((unsubscribe) => unsubscribe());
    this.eventBusUnsubscribeFunctions = [];
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ToastManager
});
//# sourceMappingURL=ToastManager.cjs.map
