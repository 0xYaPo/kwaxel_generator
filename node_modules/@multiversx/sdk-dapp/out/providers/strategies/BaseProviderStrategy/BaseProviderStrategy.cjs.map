{
  "version": 3,
  "sources": ["../../../../src/providers/strategies/BaseProviderStrategy/BaseProviderStrategy.ts"],
  "sourcesContent": ["import { IProviderAccount } from '@multiversx/sdk-wallet-connect-provider/out';\nimport { providerLabels } from 'constants/index';\nimport { Transaction, Message } from 'lib/sdkCore';\nimport { IDAppProviderOptions, IDAppProviderAccount } from 'lib/sdkDappUtils';\nimport { PendingTransactionsEventsEnum } from 'managers/internal/PendingTransactionsStateManager';\nimport { getAddress } from 'methods/account/getAddress';\nimport { IProvider, ProviderType } from 'providers/types/providerFactory.types';\nimport { ProviderErrorsEnum } from 'types/provider.types';\nimport { getPendingTransactionsHandlers } from '../helpers';\n\nexport type LoginOptionsTypes = {\n  token?: string;\n};\n\nexport abstract class BaseProviderStrategy<\n  T extends ProviderType = ProviderType\n> implements IProvider<T>\n{\n  protected address?: string = '';\n  protected _login:\n    | ((options?: LoginOptionsTypes) => Promise<IProviderAccount | null>)\n    | null = null;\n  protected loginAbortController: AbortController | null = null;\n\n  /*\n   * Allow setting provider address without store login\n   */\n  constructor(address?: string) {\n    this.address = address ?? '';\n  }\n\n  abstract init(): Promise<boolean>;\n  abstract logout(): Promise<boolean>;\n  abstract getType(): T;\n\n  abstract getAddress(): Promise<string | undefined>;\n  abstract setAccount(account: IDAppProviderAccount): void;\n  abstract isInitialized(): boolean;\n\n  isConnected?(): boolean;\n\n  getAccount(): IDAppProviderAccount | null {\n    throw new Error('Method not implemented.');\n  }\n\n  signTransaction(\n    _transaction: Transaction,\n    _options?: IDAppProviderOptions\n  ): Promise<Transaction | null> {\n    throw new Error('Method not implemented.');\n  }\n\n  abstract signTransactions(\n    transactions: Transaction[],\n    options?: IDAppProviderOptions\n  ): Promise<Transaction[] | null>;\n\n  abstract signMessage(\n    messageToSign: Message,\n    options?: IDAppProviderOptions\n  ): Promise<Message | null>;\n\n  public async login(\n    options?: LoginOptionsTypes\n  ): Promise<{ address: string; signature: string }> {\n    if (!this._login) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    if (this.loginAbortController) {\n      this.loginAbortController.abort();\n    }\n\n    const controller = new AbortController();\n    this.loginAbortController = controller;\n\n    const signal = controller.signal;\n\n    try {\n      const abortPromise = new Promise<never>((_, reject) => {\n        signal.addEventListener('abort', () => {\n          reject(new Error('Login cancelled'));\n        });\n      });\n\n      const loginResult = await Promise.race([\n        this.loginOperation(options),\n        abortPromise\n      ]);\n\n      this.loginAbortController = null;\n\n      return loginResult;\n    } catch (error) {\n      this.loginAbortController = null;\n      throw error;\n    }\n  }\n\n  public cancelLogin = () => {\n    if (this.loginAbortController) {\n      this.loginAbortController.abort();\n    }\n\n    this.cancelAction?.();\n    this.loginAbortController = null;\n  };\n\n  protected loginOperation = async (\n    options?: LoginOptionsTypes\n  ): Promise<{ address: string; signature: string }> => {\n    if (!this._login) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    const result = await this._login(options);\n\n    if (!result?.address) {\n      throw new Error(ProviderErrorsEnum.notInitialized);\n    }\n\n    return {\n      ...result,\n      address: result.address,\n      signature: result.signature ?? ''\n    };\n  };\n\n  /**\n   * Initializes the provider by setting the address if it is not already set.\n   */\n  protected initializeAddress = () => {\n    if (this.address) {\n      return;\n    }\n\n    const address = getAddress();\n\n    if (!address) {\n      return;\n    }\n\n    this.address = address;\n  };\n\n  cancelAction: (() => Promise<void>) | undefined = undefined;\n\n  /**\n   * This method should be overridden by subclasses to handle cancel login event.\n   */\n  // async cancelAction(): Promise<void> {\n  //   throw new Error('Method not implemented.');\n  // }\n\n  protected async initSignState() {\n    const { onClose, manager } = await getPendingTransactionsHandlers({\n      cancelAction: this.cancelAction?.bind(this)\n    });\n\n    const type = this.getType();\n    manager.subscribeToEventBus(PendingTransactionsEventsEnum.CLOSE, onClose);\n\n    manager.updateData({\n      name: providerLabels[type],\n      type\n    });\n\n    return { onClose, manager };\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,uBAA+B;AAG/B,6CAA8C;AAC9C,wBAA2B;AAE3B,sBAAmC;AACnC,qBAA+C;AAMxC,MAAe,qBAGtB;AAAA;AAAA;AAAA;AAAA,EAUE,YAAY,SAAkB;AAT9B,SAAU,UAAmB;AAC7B,SAAU,SAEC;AACX,SAAU,uBAA+C;AA6EzD,SAAO,cAAc,MAAM;AACzB,UAAI,KAAK,sBAAsB;AAC7B,aAAK,qBAAqB,MAAM;AAAA,MAClC;AAEA,WAAK,eAAe;AACpB,WAAK,uBAAuB;AAAA,IAC9B;AAEA,SAAU,iBAAiB,OACzB,YACoD;AACpD,UAAI,CAAC,KAAK,QAAQ;AAChB,cAAM,IAAI,MAAM,mCAAmB,cAAc;AAAA,MACnD;AAEA,YAAM,SAAS,MAAM,KAAK,OAAO,OAAO;AAExC,UAAI,CAAC,QAAQ,SAAS;AACpB,cAAM,IAAI,MAAM,mCAAmB,cAAc;AAAA,MACnD;AAEA,aAAO;AAAA,QACL,GAAG;AAAA,QACH,SAAS,OAAO;AAAA,QAChB,WAAW,OAAO,aAAa;AAAA,MACjC;AAAA,IACF;AAKA;AAAA;AAAA;AAAA,SAAU,oBAAoB,MAAM;AAClC,UAAI,KAAK,SAAS;AAChB;AAAA,MACF;AAEA,YAAM,cAAU,8BAAW;AAE3B,UAAI,CAAC,SAAS;AACZ;AAAA,MACF;AAEA,WAAK,UAAU;AAAA,IACjB;AAEA,wBAAkD;AArHhD,SAAK,UAAU,WAAW;AAAA,EAC5B;AAAA,EAYA,aAA0C;AACxC,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,gBACE,cACA,UAC6B;AAC7B,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAYA,MAAa,MACX,SACiD;AACjD,QAAI,CAAC,KAAK,QAAQ;AAChB,YAAM,IAAI,MAAM,mCAAmB,cAAc;AAAA,IACnD;AAEA,QAAI,KAAK,sBAAsB;AAC7B,WAAK,qBAAqB,MAAM;AAAA,IAClC;AAEA,UAAM,aAAa,IAAI,gBAAgB;AACvC,SAAK,uBAAuB;AAE5B,UAAM,SAAS,WAAW;AAE1B,QAAI;AACF,YAAM,eAAe,IAAI,QAAe,CAAC,GAAG,WAAW;AACrD,eAAO,iBAAiB,SAAS,MAAM;AACrC,iBAAO,IAAI,MAAM,iBAAiB,CAAC;AAAA,QACrC,CAAC;AAAA,MACH,CAAC;AAED,YAAM,cAAc,MAAM,QAAQ,KAAK;AAAA,QACrC,KAAK,eAAe,OAAO;AAAA,QAC3B;AAAA,MACF,CAAC;AAED,WAAK,uBAAuB;AAE5B,aAAO;AAAA,IACT,SAAS,OAAO;AACd,WAAK,uBAAuB;AAC5B,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyDA,MAAgB,gBAAgB;AAC9B,UAAM,EAAE,SAAS,QAAQ,IAAI,UAAM,+CAA+B;AAAA,MAChE,cAAc,KAAK,cAAc,KAAK,IAAI;AAAA,IAC5C,CAAC;AAED,UAAM,OAAO,KAAK,QAAQ;AAC1B,YAAQ,oBAAoB,qEAA8B,OAAO,OAAO;AAExE,YAAQ,WAAW;AAAA,MACjB,MAAM,gCAAe,IAAI;AAAA,MACzB;AAAA,IACF,CAAC;AAED,WAAO,EAAE,SAAS,QAAQ;AAAA,EAC5B;AACF;",
  "names": []
}
