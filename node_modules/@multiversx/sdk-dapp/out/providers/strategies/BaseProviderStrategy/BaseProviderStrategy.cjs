"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var BaseProviderStrategy_exports = {};
__export(BaseProviderStrategy_exports, {
  BaseProviderStrategy: () => BaseProviderStrategy
});
module.exports = __toCommonJS(BaseProviderStrategy_exports);
var import_constants = require("../../../constants/index");
var import_PendingTransactionsStateManager = require("../../../managers/internal/PendingTransactionsStateManager");
var import_getAddress = require("../../../methods/account/getAddress");
var import_provider = require("../../../types/provider.types");
var import_helpers = require("../helpers");
class BaseProviderStrategy {
  /*
   * Allow setting provider address without store login
   */
  constructor(address) {
    this.address = "";
    this._login = null;
    this.loginAbortController = null;
    this.cancelLogin = () => {
      if (this.loginAbortController) {
        this.loginAbortController.abort();
      }
      this.cancelAction?.();
      this.loginAbortController = null;
    };
    this.loginOperation = async (options) => {
      if (!this._login) {
        throw new Error(import_provider.ProviderErrorsEnum.notInitialized);
      }
      const result = await this._login(options);
      if (!result?.address) {
        throw new Error(import_provider.ProviderErrorsEnum.notInitialized);
      }
      return {
        ...result,
        address: result.address,
        signature: result.signature ?? ""
      };
    };
    /**
     * Initializes the provider by setting the address if it is not already set.
     */
    this.initializeAddress = () => {
      if (this.address) {
        return;
      }
      const address = (0, import_getAddress.getAddress)();
      if (!address) {
        return;
      }
      this.address = address;
    };
    this.cancelAction = void 0;
    this.address = address ?? "";
  }
  getAccount() {
    throw new Error("Method not implemented.");
  }
  signTransaction(_transaction, _options) {
    throw new Error("Method not implemented.");
  }
  async login(options) {
    if (!this._login) {
      throw new Error(import_provider.ProviderErrorsEnum.notInitialized);
    }
    if (this.loginAbortController) {
      this.loginAbortController.abort();
    }
    const controller = new AbortController();
    this.loginAbortController = controller;
    const signal = controller.signal;
    try {
      const abortPromise = new Promise((_, reject) => {
        signal.addEventListener("abort", () => {
          reject(new Error("Login cancelled"));
        });
      });
      const loginResult = await Promise.race([
        this.loginOperation(options),
        abortPromise
      ]);
      this.loginAbortController = null;
      return loginResult;
    } catch (error) {
      this.loginAbortController = null;
      throw error;
    }
  }
  /**
   * This method should be overridden by subclasses to handle cancel login event.
   */
  // async cancelAction(): Promise<void> {
  //   throw new Error('Method not implemented.');
  // }
  async initSignState() {
    const { onClose, manager } = await (0, import_helpers.getPendingTransactionsHandlers)({
      cancelAction: this.cancelAction?.bind(this)
    });
    const type = this.getType();
    manager.subscribeToEventBus(import_PendingTransactionsStateManager.PendingTransactionsEventsEnum.CLOSE, onClose);
    manager.updateData({
      name: import_constants.providerLabels[type],
      type
    });
    return { onClose, manager };
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BaseProviderStrategy
});
//# sourceMappingURL=BaseProviderStrategy.cjs.map
