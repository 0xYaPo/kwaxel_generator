"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var WebviewClient_exports = {};
__export(WebviewClient_exports, {
  WebviewClient: () => WebviewClient
});
module.exports = __toCommonJS(WebviewClient_exports);
var import_constants = require("../../../../constants/index");
var import_sdkCore = require("../../../../lib/sdkCore");
var import_sdkWebWalletCrossWindowProvider = require("../../../../lib/sdkWebWalletCrossWindowProvider");
var import_accountProvider = require("../../../../providers/helpers/accountProvider");
var import_selectors = require("../../../../store/selectors");
var import_store = require("../../../../store/store");
class WebviewClient {
  constructor({ onLoginCancelled }) {
    this.handlers = /* @__PURE__ */ new Map();
    this.store = (0, import_store.getStore)();
    this.isLoginInitiated = false;
    this.handleMessage = this.handleMessage.bind(this);
    this.handleLoginCancelled = onLoginCancelled;
  }
  startListening() {
    import_constants.safeWindow.addEventListener("message", this.handleMessage);
  }
  stopListening() {
    import_constants.safeWindow.removeEventListener("message", this.handleMessage);
  }
  registerEvent(type, handler) {
    this.handlers.set(type, handler);
  }
  unregisterEvent(type) {
    this.handlers.delete(type);
  }
  async handleMessage(event) {
    const type = event.data?.type;
    if (typeof type === "string" && this.handlers.has(type)) {
      const handler = this.handlers.get(type);
      return handler?.(event);
    }
    switch (type) {
      case import_sdkWebWalletCrossWindowProvider.WindowProviderRequestEnums.finalizeHandshakeRequest:
        this.handshake({ event });
        break;
      case import_sdkWebWalletCrossWindowProvider.WindowProviderRequestEnums.signMessageRequest:
        this.signMessage({ event, payload: event.data.payload });
        break;
      case import_sdkWebWalletCrossWindowProvider.WindowProviderRequestEnums.loginRequest:
        this.isLoginInitiated = true;
        this.login({ event, payload: event.data.payload });
        break;
      case import_sdkWebWalletCrossWindowProvider.WindowProviderRequestEnums.signTransactionsRequest:
        this.signTransactions({ event });
        break;
      case import_sdkWebWalletCrossWindowProvider.WindowProviderResponseEnums.cancelResponse:
      case "cancelAction":
        if (this.isLoginInitiated) {
          await this.handleLoginCancelled();
        }
        break;
      default:
        break;
    }
  }
  async login({
    event,
    payload
  }) {
    const loginToken = payload?.token;
    if (!loginToken) {
      return;
    }
    try {
      const { address } = (0, import_selectors.accountSelector)(this.store.getState());
      const provider = (0, import_accountProvider.getAccountProvider)();
      const messageToSign = new import_sdkCore.Message({
        address: new import_sdkCore.Address(address),
        data: new Uint8Array(Buffer.from(loginToken))
      });
      const signedMessage = await provider.signMessage(messageToSign);
      const signature = signedMessage?.signature ?? "";
      event.source?.postMessage(
        {
          type: import_sdkWebWalletCrossWindowProvider.WindowProviderResponseEnums.loginResponse,
          payload: {
            data: {
              address,
              signature: Buffer.from(signature).toString("hex")
            }
          }
        },
        { targetOrigin: event.origin }
      );
    } catch {
      if (this.isLoginInitiated) {
        this.handleLoginCancelled();
      }
    } finally {
      this.isLoginInitiated = false;
    }
  }
  handshake({ event }) {
    const handshakeSession = Date.now().toString();
    event.source?.postMessage(
      {
        type: import_sdkWebWalletCrossWindowProvider.WindowProviderResponseEnums.finalizeHandshakeResponse,
        payload: { data: handshakeSession }
      },
      { targetOrigin: event.origin }
    );
  }
  async signMessage({
    event,
    payload
  }) {
    const { address } = (0, import_selectors.accountSelector)(this.store.getState());
    const { message } = payload;
    try {
      const messageToSign = new import_sdkCore.Message({
        address: new import_sdkCore.Address(address),
        data: new Uint8Array(Buffer.from(message))
      });
      const provider = (0, import_accountProvider.getAccountProvider)();
      const signedMessage = await provider.signMessage(messageToSign);
      const signature = signedMessage?.signature ?? "";
      event.source?.postMessage(
        {
          type: import_sdkWebWalletCrossWindowProvider.WindowProviderResponseEnums.signMessageResponse,
          payload: {
            data: {
              signature: Buffer.from(signature).toString("hex"),
              status: "signed"
            }
          }
        },
        { targetOrigin: event.origin }
      );
    } catch {
      throw new Error("Could not sign message");
    }
  }
  async signTransactions({ event }) {
    const provider = (0, import_accountProvider.getAccountProvider)();
    const { payload } = event.data;
    if (!Array.isArray(payload)) {
      return;
    }
    try {
      const transactions = payload.map(
        (plainTransactionObject) => import_sdkCore.Transaction.newFromPlainObject(plainTransactionObject)
      );
      const signedTx = await provider.signTransactions(transactions);
      event.source?.postMessage(
        {
          type: import_sdkWebWalletCrossWindowProvider.WindowProviderResponseEnums.signTransactionsResponse,
          payload: {
            data: signedTx.map((tx) => tx.toPlainObject())
          }
        },
        { targetOrigin: event.origin }
      );
    } catch {
      throw new Error("Could not sign transactions");
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  WebviewClient
});
//# sourceMappingURL=WebviewClient.cjs.map
