"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var WalletConnectProviderStrategy_exports = {};
__export(WalletConnectProviderStrategy_exports, {
  WalletConnectProviderStrategy: () => WalletConnectProviderStrategy
});
module.exports = __toCommonJS(WalletConnectProviderStrategy_exports);
var import_out = require("@multiversx/sdk-wallet-connect-provider/out");
var import_providerFactory = require("../../../constants/providerFactory.constants");
var import_walletConnect = require("../../../constants/walletConnect.constants");
var import_WalletConnectStateManager = require("../../../managers/internal/WalletConnectStateManager/WalletConnectStateManager");
var import_getIsLoggedIn = require("../../../methods/account/getIsLoggedIn");
var import_providerFactory2 = require("../../../providers/types/providerFactory.types");
var import_actions = require("../../../store/actions");
var import_selectors = require("../../../store/selectors");
var import_store = require("../../../store/store");
var import_provider = require("../../../types/provider.types");
var import_sdkWalletconnectProvider = require("../../../utils/walletconnect/__sdkWalletconnectProvider");
var import_types = require("./types");
var import_BaseProviderStrategy = require("../BaseProviderStrategy/BaseProviderStrategy");
var import_signMessage = require("../helpers/signMessage/signMessage");
const dappMethods = [
  import_sdkWalletconnectProvider.WalletConnectOptionalMethodsEnum.CANCEL_ACTION,
  import_sdkWalletconnectProvider.WalletConnectOptionalMethodsEnum.SIGN_LOGIN_TOKEN
];
class WalletConnectProviderStrategy extends import_BaseProviderStrategy.BaseProviderStrategy {
  constructor(config) {
    super();
    this.provider = null;
    this.methods = [];
    this._approval = null;
    this.cancelActionAbortController = null;
    this.signTransactions = async (transactions) => {
      if (!this.provider) {
        throw new Error(import_provider.ProviderErrorsEnum.notInitialized);
      }
      const { manager, onClose } = await this.initSignState();
      this.cancelActionAbortController = new AbortController();
      const signal = this.cancelActionAbortController.signal;
      try {
        const abortPromise = new Promise((_, reject) => {
          signal.addEventListener("abort", () => {
            reject(new Error("cancelled by user"));
          });
        });
        const signedTransactions = await Promise.race([
          this.provider.signTransactions(transactions),
          abortPromise
        ]);
        return signedTransactions;
      } catch (error) {
        await onClose({ shouldCancelAction: true });
        throw error;
      } finally {
        manager.closeUI();
      }
    };
    this.cancelAction = async () => {
      this.sendCustomRequest({
        method: import_sdkWalletconnectProvider.WalletConnectOptionalMethodsEnum.CANCEL_ACTION,
        action: import_out.OptionalOperation.CANCEL_ACTION
      });
      this.cancelActionAbortController?.abort();
    };
    this.signMessage = async (message) => {
      if (!this.provider) {
        throw new Error(import_provider.ProviderErrorsEnum.notInitialized);
      }
      this.cancelActionAbortController = new AbortController();
      const signal = this.cancelActionAbortController.signal;
      const abortPromise = new Promise((_, reject) => {
        signal.addEventListener("abort", () => {
          reject(new Error("cancelled by user"));
        });
      });
      const signedMessage = await Promise.race([
        (0, import_signMessage.signMessage)({
          message,
          handleSignMessage: this.provider.signMessage.bind(this.provider),
          cancelAction: this.cancelAction,
          providerType: import_providerFactory.providerLabels.extension
        }),
        abortPromise
      ]);
      return signedMessage;
    };
    this.config = config;
  }
  async init() {
    try {
      await this.initializeProvider();
    } catch {
      return false;
    }
    return true;
  }
  logout() {
    if (!this.provider) {
      throw new Error(import_provider.ProviderErrorsEnum.notInitialized);
    }
    return this.provider.logout();
  }
  getType() {
    return import_providerFactory2.ProviderTypeEnum.walletConnect;
  }
  getAddress() {
    if (!this.provider) {
      throw new Error(import_provider.ProviderErrorsEnum.notInitialized);
    }
    return Promise.resolve(this.provider.getAddress());
  }
  setAccount(account) {
    return this.provider?.setAccount(account);
  }
  isInitialized() {
    if (!this.provider) {
      throw new Error(import_provider.ProviderErrorsEnum.notInitialized);
    }
    return this.provider.isInitialized();
  }
  async initializeProvider() {
    await this.initWalletConnectManager();
    if (!this.config) {
      throw new Error(import_types.WalletConnectV2Error.invalidConfig);
    }
    const { walletConnectProvider, dappMethods: dAppMethods } = await this.createWalletConnectProvider(this.config);
    this.provider = walletConnectProvider;
    this.methods = dAppMethods;
    const { uri = "", approval } = await this.provider.connect({
      methods: this.methods
    });
    const walletConnectDeepLink = this.config.walletConnectDeepLink ?? import_walletConnect.fallbackWalletConnectConfigurations.walletConnectDeepLink;
    this._approval = approval;
    const walletConnectManager = import_WalletConnectStateManager.WalletConnectStateManager.getInstance();
    walletConnectManager.updateData({
      wcURI: uri,
      walletConnectDeepLink: `${walletConnectDeepLink}?wallet-connect=${encodeURIComponent(uri)}`
    });
  }
  async initWalletConnectManager() {
    const shouldInitiateLogin = !(0, import_getIsLoggedIn.getIsLoggedIn)();
    if (!shouldInitiateLogin) {
      return;
    }
    const walletConnectManager = import_WalletConnectStateManager.WalletConnectStateManager.getInstance();
    await walletConnectManager.init(this.config?.anchor);
  }
  async createWalletConnectProvider(config) {
    const isLoggedIn = (0, import_getIsLoggedIn.getIsLoggedIn)();
    const chainId = (0, import_selectors.chainIdSelector)((0, import_store.getState)());
    const nativeAuthConfig = (0, import_selectors.nativeAuthConfigSelector)((0, import_store.getState)());
    if (nativeAuthConfig) {
      dappMethods.push(import_sdkWalletconnectProvider.WalletConnectOptionalMethodsEnum.SIGN_NATIVE_AUTH_TOKEN);
    }
    if (!config?.walletConnectV2ProjectId) {
      throw new Error(import_types.WalletConnectV2Error.invalidConfig);
    }
    const handleOnLogin = () => {
    };
    const handleOnLogout = () => {
      (0, import_actions.logoutAction)();
    };
    const handleOnEvent = (_event) => {
    };
    const providerHandlers = {
      onClientLogin: handleOnLogin,
      onClientLogout: handleOnLogout,
      onClientEvent: handleOnEvent
    };
    try {
      const {
        walletConnectV2ProjectId,
        walletConnectV2Options = {},
        walletConnectV2RelayAddress = ""
      } = config;
      const walletConnectProvider = new import_sdkWalletconnectProvider.WalletConnectV2Provider(
        providerHandlers,
        chainId,
        walletConnectV2RelayAddress,
        walletConnectV2ProjectId,
        walletConnectV2Options
      );
      await walletConnectProvider.init();
      return { walletConnectProvider, dappMethods };
    } catch (err) {
      console.error(import_types.WalletConnectV2Error.connectError, err);
      if (isLoggedIn) {
        await this.logout();
      }
      throw err;
    }
  }
  async login(options) {
    if (!this.provider) {
      throw new Error(
        "Provider is not initialized. Call createProvider first."
      );
    }
    const reconnect = async () => {
      if (!this.provider) {
        throw new Error(import_provider.ProviderErrorsEnum.notInitialized);
      }
      try {
        await this.provider.init();
        const walletConnectManager = import_WalletConnectStateManager.WalletConnectStateManager.getInstance();
        const { uri = "", approval: wcApproval } = await this.provider.connect({
          methods: this.methods
        });
        const walletConnectDeepLink = this.config.walletConnectDeepLink ?? import_walletConnect.fallbackWalletConnectConfigurations.walletConnectDeepLink;
        walletConnectManager.updateData({
          wcURI: uri,
          walletConnectDeepLink: `${walletConnectDeepLink}?wallet-connect=${encodeURIComponent(uri)}`
        });
        const providerInfo = await this.provider.login({
          approval: wcApproval,
          token: options?.token
        });
        const { address = "", signature = "" } = providerInfo ?? {};
        walletConnectManager.handleClose({ isLoginFinished: Boolean(address) });
        return { address, signature };
      } catch {
        return await reconnect();
      }
    };
    if (!this._approval) {
      throw new Error("Approval or login is not initialized");
    }
    try {
      const providerData = await this.provider.login({
        approval: this._approval.bind(this),
        token: options?.token
      });
      const { address = "", signature = "" } = providerData ?? {};
      const walletConnectManager = import_WalletConnectStateManager.WalletConnectStateManager.getInstance();
      walletConnectManager.handleClose({ isLoginFinished: Boolean(address) });
      return { address, signature };
    } catch (error) {
      console.error(import_types.WalletConnectV2Error.userRejected, error);
      return await reconnect();
    }
  }
  async sendCustomRequest({
    action,
    method
  }) {
    if (!this.provider) {
      throw new Error(import_provider.ProviderErrorsEnum.notInitialized);
    }
    try {
      await this.provider.sendCustomRequest?.({
        request: {
          method,
          params: { action }
        }
      });
    } catch (error) {
      console.error(import_types.WalletConnectV2Error.actionError, error);
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  WalletConnectProviderStrategy
});
//# sourceMappingURL=WalletConnectProviderStrategy.cjs.map
