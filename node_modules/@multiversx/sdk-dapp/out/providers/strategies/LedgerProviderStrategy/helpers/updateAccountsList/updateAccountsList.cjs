"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var updateAccountsList_exports = {};
__export(updateAccountsList_exports, {
  updateAccountsList: () => updateAccountsList
});
module.exports = __toCommonJS(updateAccountsList_exports);
var import_bignumber = __toESM(require("bignumber.js"));
var import_getEconomics = require("../../../../../apiCalls/economics/getEconomics");
var import_sdkDappUtils = require("../../../../../lib/sdkDappUtils");
var import_getNetworkConfig = require("../../../../../methods/network/getNetworkConfig");
var import_types = require("../../../../../types");
var import_fetchAccount = require("../../../../../utils/account/fetchAccount");
var import_getUsdValue = require("../../../../../utils/operations/getUsdValue");
const updateAccountsList = async ({
  manager,
  provider
}) => {
  if (!manager || !provider) {
    throw new Error(import_types.ProviderErrorsEnum.notInitialized);
  }
  const { network } = (0, import_getNetworkConfig.getNetworkConfig)();
  const startIndex = manager.getAccountScreenData()?.startIndex || 0;
  const allAccounts = manager.getAllAccounts();
  const economics = await (0, import_getEconomics.getEconomics)({ baseURL: network.apiAddress });
  const filterByStartIndexRange = (account) => account.index >= startIndex && account.index < startIndex + manager.addressesPerPage;
  const allAccountsObject = allAccounts.reduce(
    (accountsObject, account) => Object.assign(accountsObject, { [account.index]: account }),
    {}
  );
  const currentAccounts = allAccounts.filter(filterByStartIndexRange);
  const isStartIndexInAccounts = Boolean(allAccountsObject[startIndex]);
  manager.updateAccountScreen({
    isLoading: !isStartIndexInAccounts
  });
  if (currentAccounts.length > 0) {
    manager.updateAccountScreen({ accounts: currentAccounts });
    return;
  }
  try {
    const page = Math.floor(startIndex / manager.addressesPerPage);
    const accountsArray = await provider.getAccounts(
      page,
      manager.addressesPerPage
    );
    const accountsWithBalance = accountsArray.map(
      (address, accountIindex) => ({
        address,
        balance: "...",
        index: accountIindex + startIndex
      })
    );
    const newAllAccounts = [...allAccounts, ...accountsWithBalance];
    const balancePromises = accountsArray.map(
      (address) => (0, import_fetchAccount.fetchAccount)({ address, baseURL: network.apiAddress })
    );
    const balances = await Promise.all(balancePromises);
    const newAllAccountsObject = newAllAccounts.reduce(
      (accountsObject, account) => Object.assign(accountsObject, { [account.address]: account }),
      {}
    );
    balances.forEach((account) => {
      if (!account || !economics || !economics.price) {
        return;
      }
      const balanceBigNumber = new import_bignumber.default(account.balance);
      const formattedBalance = balanceBigNumber.dividedBy((0, import_bignumber.default)(10).pow(18)).toFormat(4).toString();
      if (balanceBigNumber.isNaN()) {
        return;
      }
      const usdValue = (0, import_getUsdValue.getUsdValue)({
        amount: (0, import_sdkDappUtils.formatAmount)({ input: account.balance }),
        usd: economics?.price
      });
      newAllAccountsObject[account.address].balance = formattedBalance;
      newAllAccountsObject[account.address].usdValue = usdValue;
    });
    const newAllAccountsArray = Object.values(newAllAccountsObject).sort(
      (alpha, beta) => alpha.index - beta.index
    );
    const accountsScreenArray = newAllAccountsArray.filter(
      filterByStartIndexRange
    );
    manager.updateAllAccounts(newAllAccountsArray);
    manager.updateAccountScreen({
      accounts: accountsScreenArray,
      isLoading: false
    });
  } catch (error) {
    console.error("Failed to fetch accounts:", error);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  updateAccountsList
});
//# sourceMappingURL=updateAccountsList.cjs.map
