{
  "version": 3,
  "sources": ["../../../../../../../../src/providers/strategies/helpers/signTransactions/helpers/getCommonData/helpers/decodeDataField.ts"],
  "sourcesContent": ["import { Address } from '@multiversx/sdk-core';\nimport BigNumber from 'bignumber.js';\nimport { TransactionTypesEnum } from 'types/enums.types';\nimport {\n  DecodeMethodEnum,\n  TransactionTokensType,\n  DecodedDisplayType\n} from 'types/serverTransactions.types';\nimport { isUtf8 } from 'utils/decoders';\nimport { addressIsValid } from 'utils/validation/addressIsValid';\nimport { isHexValidCharacters, isHexValidLength } from 'utils/validation/hex';\n\ninterface IGetDecodedParts {\n  parts: string[];\n  decodeMethod: DecodeMethodEnum;\n  identifier?: string;\n  decodedData: DecodedDisplayType;\n}\n\ninterface ISmartDecodedParts {\n  parts: string[];\n  decodedParts: string[];\n  identifier?: string;\n}\n\nconst getHexValidationWarnings = (str: string) => {\n  const warnings = [];\n\n  if (str && !isHexValidCharacters(str)) {\n    warnings.push(`Invalid Hex characters on argument @${str}`);\n  }\n\n  if (str && !isHexValidLength(str)) {\n    warnings.push(`Odd number of Hex characters on argument @${str}`);\n  }\n\n  return warnings;\n};\n\nconst decodeByMethod = (\n  part: string,\n  decodeMethod: DecodeMethodEnum | string,\n  transactionTokens?: TransactionTokensType\n) => {\n  switch (decodeMethod) {\n    case DecodeMethodEnum.text:\n      try {\n        return Buffer.from(part, 'hex').toString('utf8');\n      } catch {\n        return part;\n      }\n\n    case DecodeMethodEnum.decimal:\n      return part !== '' ? new BigNumber(part, 16).toString(10) : '';\n    case DecodeMethodEnum.smart:\n      try {\n        const bech32Encoded = Address.newFromHex(part).toString();\n\n        if (addressIsValid(bech32Encoded)) {\n          return bech32Encoded;\n        }\n      } catch {\n        // skip\n      }\n\n      try {\n        const decoded = Buffer.from(part, 'hex').toString('utf8');\n\n        if (!isUtf8(decoded)) {\n          if (transactionTokens) {\n            const tokens = [\n              ...transactionTokens.esdts,\n              ...transactionTokens.nfts\n            ];\n\n            if (tokens.some((token) => decoded.includes(token))) {\n              return decoded;\n            }\n          }\n\n          const bigNumber = new BigNumber(part, 16);\n\n          return bigNumber.isFinite() ? bigNumber.toString(10) : part;\n        } else {\n          return decoded;\n        }\n      } catch {\n        return part;\n      }\n\n    case DecodeMethodEnum.raw:\n    default:\n      return part;\n  }\n};\n\nconst getSmartDecodedParts = ({\n  parts,\n  decodedParts,\n  identifier\n}: ISmartDecodedParts) => {\n  const smartDecodedParts = [...decodedParts];\n\n  if (parts[0] === TransactionTypesEnum.ESDTNFTTransfer && parts[2]) {\n    smartDecodedParts[2] = decodeByMethod(parts[2], DecodeMethodEnum.decimal);\n  }\n\n  if (identifier === TransactionTypesEnum.ESDTNFTTransfer && parts[1]) {\n    const base64Buffer = Buffer.from(String(parts[1]), 'base64');\n    smartDecodedParts[1] = decodeByMethod(\n      base64Buffer.toString('hex'),\n      DecodeMethodEnum.decimal\n    );\n  }\n\n  return smartDecodedParts;\n};\n\nconst getDisplayValueAndValidationWarnings = ({\n  parts,\n  decodeMethod,\n  identifier,\n  decodedData\n}: IGetDecodedParts) => {\n  const initialDecodedParts = parts.map((part, index) => {\n    if (\n      parts.length >= 2 &&\n      ((index === 0 && part.length < 64) || (index === 1 && !parts[0]))\n    ) {\n      const encodedDisplayValue = /[^a-z0-9]/gi.test(part);\n\n      if (encodedDisplayValue) {\n        return decodeByMethod(part, decodeMethod);\n      }\n\n      return part;\n    }\n\n    const hexValidationWarnings = getHexValidationWarnings(part);\n\n    if (hexValidationWarnings?.length) {\n      decodedData.validationWarnings = Array.from(\n        new Set([...decodedData.validationWarnings, ...hexValidationWarnings])\n      );\n    }\n\n    return decodeByMethod(part, decodeMethod);\n  });\n\n  const decodedParts =\n    decodeMethod === DecodeMethodEnum.smart\n      ? getSmartDecodedParts({\n          parts,\n          decodedParts: initialDecodedParts,\n          identifier\n        })\n      : initialDecodedParts;\n\n  return decodedParts;\n};\n\nconst getDecodedParts = ({\n  parts,\n  decodeMethod,\n  identifier,\n  initialDecodedParts\n}: {\n  parts: string[];\n  decodeMethod: DecodeMethodEnum;\n  identifier?: string;\n  initialDecodedParts: string[];\n}) => {\n  if (decodeMethod === DecodeMethodEnum.smart) {\n    return getSmartDecodedParts({\n      parts,\n      decodedParts: initialDecodedParts,\n      identifier\n    });\n  }\n\n  return initialDecodedParts;\n};\n\nconst decodeHighlight = ({\n  data,\n  identifier,\n  decodeMethod,\n  delimiter\n}: {\n  data: string;\n  identifier?: string;\n  decodeMethod: DecodeMethodEnum;\n  delimiter: string;\n}) => {\n  const parts = data.split('@');\n\n  const initialDecodedParts = parts.map((part) => {\n    return decodeByMethod(part, decodeMethod);\n  });\n\n  const decodedHighlight = getDecodedParts({\n    parts,\n    initialDecodedParts,\n    identifier,\n    decodeMethod\n  });\n\n  return decodedHighlight.join(delimiter);\n};\n\nconst decodeDataField = ({\n  data,\n  identifier,\n  decodeMethod,\n  highlight\n}: {\n  data: string;\n  identifier?: string;\n  decodeMethod: DecodeMethodEnum;\n  highlight: string | null;\n}): DecodedDisplayType => {\n  const decodedData: DecodedDisplayType = {\n    displayValue: '',\n    validationWarnings: [],\n    highlight\n  };\n\n  const hasAt = data.includes('@');\n  const hasNewLine = data.includes('\\n');\n\n  if (!hasAt && !hasNewLine) {\n    return {\n      ...decodedData,\n      displayValue: decodeByMethod(data, decodeMethod),\n      highlight: highlight ? decodeByMethod(highlight, decodeMethod) : highlight\n    };\n  }\n\n  if (hasAt) {\n    const parts = data.split('@');\n    const decodedParts = getDisplayValueAndValidationWarnings({\n      parts,\n      decodeMethod,\n      identifier,\n      decodedData\n    });\n\n    const decodedHighlight = highlight\n      ? decodeHighlight({\n          data: highlight,\n          identifier,\n          decodeMethod,\n          delimiter: '@'\n        })\n      : null;\n\n    return {\n      ...decodedData,\n      displayValue: decodedParts.join('@'),\n      highlight: decodedHighlight\n    };\n  }\n\n  if (hasNewLine) {\n    const parts = data.split('\\n');\n\n    const initialDecodedParts = parts.map((part) => {\n      if (decodeMethod === DecodeMethodEnum.raw) {\n        return part;\n      }\n\n      return decodeByMethod(\n        Buffer.from(part, 'base64').toString('hex'),\n        decodeMethod\n      );\n    });\n\n    const decodedParts = getDecodedParts({\n      parts,\n      initialDecodedParts,\n      identifier,\n      decodeMethod\n    });\n\n    const decodedHighlight = highlight\n      ? decodeHighlight({\n          data: highlight,\n          identifier,\n          decodeMethod,\n          delimiter: '\\n'\n        })\n      : null;\n\n    return {\n      ...decodedData,\n      displayValue: decodedParts.join('\\n'),\n      highlight: decodedHighlight\n    };\n  }\n\n  return decodedData;\n};\n\nexport const getAllDecodedFormats = ({\n  data,\n  highlight,\n  identifier\n}: {\n  data: string;\n  highlight: string | null;\n  identifier?: string;\n}) => {\n  const decodedFormats: Partial<Record<DecodeMethodEnum, DecodedDisplayType>> =\n    {};\n\n  Object.values(DecodeMethodEnum).forEach((decodeMethod) => {\n    const decodedData = decodeDataField({\n      data,\n      identifier,\n      decodeMethod,\n      highlight\n    });\n\n    decodedFormats[decodeMethod] = decodedData;\n  });\n\n  return decodedFormats;\n};\n"],
  "mappings": "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",
  "names": ["BigNumber"]
}
