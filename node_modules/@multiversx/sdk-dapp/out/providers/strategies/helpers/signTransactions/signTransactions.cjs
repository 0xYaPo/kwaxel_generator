"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var signTransactions_exports = {};
__export(signTransactions_exports, {
  signTransactions: () => signTransactions
});
module.exports = __toCommonJS(signTransactions_exports);
var import_getEconomics = require("../../../../apiCalls/economics/getEconomics");
var import_placeholders = require("../../../../constants/placeholders.constants");
var import_sdkCore = require("../../../../lib/sdkCore");
var import_sdkDappUtils = require("../../../../lib/sdkDappUtils");
var import_SignTransactionsStateManager = require("../../../../managers/internal/SignTransactionsStateManager/SignTransactionsStateManager");
var import_types = require("../../../../managers/internal/SignTransactionsStateManager/types");
var import_getAccountInfo = require("../../../../methods/account/getAccountInfo");
var import_getEgldLabel = require("../../../../methods/network/getEgldLabel");
var import_cancelCrossWindowAction = require("../../../../providers/helpers/cancelCrossWindowAction");
var import_networkSelectors = require("../../../../store/selectors/networkSelectors");
var import_store = require("../../../../store/store");
var import_getCommonData = require("./helpers/getCommonData/getCommonData");
var import_getRecommendedGasPrice = require("./helpers/getCommonData/helpers/getRecommendedGasPrice");
var import_getFeeData = require("./helpers/getFeeData");
var import_getMultiEsdtTransferData = require("./helpers/getMultiEsdtTransferData/getMultiEsdtTransferData");
var import_guardTransactions = require("./helpers/guardTransactions/guardTransactions");
async function signTransactions({
  transactions = [],
  handleSign,
  guardTransactions = import_guardTransactions.guardTransactions
}) {
  const {
    account: { address, shard, username }
  } = (0, import_getAccountInfo.getAccountInfo)();
  const network = (0, import_networkSelectors.networkSelector)((0, import_store.getState)());
  const egldLabel = (0, import_getEgldLabel.getEgldLabel)();
  const { allTransactions, parsedTransactionsByDataField } = (0, import_getMultiEsdtTransferData.getMultiEsdtTransferData)(transactions);
  let signedIndexes = [];
  const manager = import_SignTransactionsStateManager.SignTransactionsStateManager.getInstance();
  await manager.openUI();
  if (!manager) {
    throw new Error("Unable to establish connection with sign screens");
  }
  const handleCancel = async () => {
    await (0, import_cancelCrossWindowAction.cancelCrossWindowAction)();
    manager.closeUI();
  };
  manager.subscribeToEventBus(import_types.SignEventsEnum.CLOSE, handleCancel);
  return new Promise(async (resolve, reject) => {
    const signedTransactions = [];
    const economics = await (0, import_getEconomics.getEconomics)({ baseURL: network.apiAddress });
    manager.notifyDataUpdate();
    manager.initializeGasPriceMap(allTransactions.map((tx) => tx.transaction));
    const price = economics?.price;
    let currentScreenIndex = 0;
    const updateScreen = async () => {
      const currentTransaction = allTransactions[currentScreenIndex];
      const transaction = currentTransaction?.transaction;
      const currentNonce = Number(transaction.nonce);
      try {
        manager.updateIsLoading(true);
        const { commonData, tokenTransaction, fungibleTransaction } = await (0, import_getCommonData.getCommonData)({
          allTransactions,
          currentScreenIndex,
          egldLabel,
          network,
          gasPriceData: manager.ppuMap[currentNonce],
          price,
          address,
          username,
          shard,
          signedIndexes,
          parsedTransactionsByDataField
        });
        if (tokenTransaction) {
          manager.updateTokenTransaction(tokenTransaction);
        }
        if (fungibleTransaction) {
          manager.updateNonFungibleTransaction(
            fungibleTransaction.type,
            fungibleTransaction
          );
        }
        manager.updateCommonData(commonData);
      } catch (error) {
        console.error(
          `Error fetching common data for transaction at index ${currentScreenIndex}:`,
          error
        );
        throw error;
      } finally {
        manager.updateIsLoading(false);
      }
    };
    const onBack = () => {
      if (currentScreenIndex > 0) {
        currentScreenIndex--;
        updateScreen();
      }
    };
    const onSetPpu = (ppu = import_placeholders.EMPTY_PPU) => {
      const currentTransaction = allTransactions[currentScreenIndex];
      const transaction = currentTransaction.transaction;
      const currentNonce = Number(transaction.nonce);
      manager.updateGasPriceMap({
        nonce: currentNonce,
        ppu
      });
      manager.updateCommonData({ ppu });
      const plainTransaction = transaction.toPlainObject();
      const newGasPrice = (0, import_getRecommendedGasPrice.getRecommendedGasPrice)({
        transaction: plainTransaction,
        gasPriceData: manager.ppuMap[currentNonce]
      });
      const newTransaction = import_sdkCore.Transaction.newFromPlainObject({
        ...plainTransaction,
        gasPrice: newGasPrice
      });
      const feeData = (0, import_getFeeData.getFeeData)({
        transaction: newTransaction,
        price
      });
      const formattedGasPrice = (0, import_sdkDappUtils.formatAmount)({
        input: newGasPrice.toString(),
        decimals: import_sdkDappUtils.DECIMALS,
        addCommas: true,
        digits: import_sdkDappUtils.DIGITS
      });
      manager.updateCommonData({
        feeLimit: feeData.feeLimitFormatted,
        feeInFiatLimit: feeData.feeInFiatLimit,
        gasPrice: formattedGasPrice,
        ppu
      });
    };
    const onCancel = async () => {
      reject(new Error("Transaction signing cancelled by user"));
      await (0, import_cancelCrossWindowAction.cancelCrossWindowAction)();
      manager.closeUI();
    };
    const onNext = () => {
      if (currentScreenIndex < manager.transactionsCount - 1) {
        currentScreenIndex++;
        updateScreen();
      }
    };
    const onSign = async () => {
      const currentTransaction = allTransactions[currentScreenIndex];
      const transaction = currentTransaction.transaction;
      const currentNonce = Number(transaction.nonce);
      const { commonData } = await (0, import_getCommonData.getCommonData)({
        allTransactions,
        currentScreenIndex,
        egldLabel,
        network,
        gasPriceData: manager.ppuMap[currentNonce],
        price,
        address,
        username,
        shard,
        signedIndexes,
        parsedTransactionsByDataField
      });
      if (!commonData.needsSigning) {
        signedIndexes.push(currentScreenIndex);
        return onNext();
      }
      const plainTransaction = transaction.toPlainObject();
      const txNonce = plainTransaction.nonce;
      const newGasPrice = (0, import_getRecommendedGasPrice.getRecommendedGasPrice)({
        transaction: plainTransaction,
        gasPriceData: manager.ppuMap[txNonce]
      });
      const transactionToSign = import_sdkCore.Transaction.newFromPlainObject({
        ...plainTransaction,
        gasPrice: newGasPrice
      });
      try {
        const signedTxs = await handleSign([transactionToSign]);
        if (signedTxs) {
          signedIndexes.push(currentScreenIndex);
          signedTransactions.push(signedTxs[0]);
        }
        const isLastScreen = currentScreenIndex === allTransactions.length - 1;
        const allSignableTransactions = allTransactions.filter(
          (tx) => tx.needsSigning
        );
        const areAllTransactionsSigned = signedTransactions.length === allSignableTransactions.length;
        if (isLastScreen && areAllTransactionsSigned) {
          const optionallyGuardedTransactions = await guardTransactions(signedTransactions);
          manager.closeUI();
          return resolve(optionallyGuardedTransactions);
        }
        onNext();
      } catch (error) {
        manager.closeUI();
        reject(error);
      }
    };
    const eventHandlersMap = /* @__PURE__ */ new Map([
      [import_types.SignEventsEnum.NEXT, onNext],
      [import_types.SignEventsEnum.CONFIRM, onSign],
      [import_types.SignEventsEnum.CLOSE, onCancel],
      [import_types.SignEventsEnum.BACK, onBack],
      [import_types.SignEventsEnum.SET_PPU, onSetPpu]
    ]);
    function setupEventListeners() {
      for (const [event, handler] of eventHandlersMap) {
        manager.subscribeToEventBus(event, handler);
      }
    }
    setupEventListeners();
    await updateScreen();
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  signTransactions
});
//# sourceMappingURL=signTransactions.cjs.map
