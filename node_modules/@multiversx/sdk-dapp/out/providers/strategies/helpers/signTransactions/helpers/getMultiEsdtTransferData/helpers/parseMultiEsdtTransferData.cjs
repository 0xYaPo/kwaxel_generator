"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var parseMultiEsdtTransferData_exports = {};
__export(parseMultiEsdtTransferData_exports, {
  parseMultiEsdtTransferData: () => parseMultiEsdtTransferData
});
module.exports = __toCommonJS(parseMultiEsdtTransferData_exports);
var import_bignumber = __toESM(require("bignumber.js"));
var import_enums = require("../../../../../../../types/enums.types");
var import_decodePart = require("../../../../../../../utils/decoders/decodePart");
var import_getAllStringOccurrences = require("./getAllStringOccurrences");
function parseMultiEsdtTransferData(data) {
  const transactions = [];
  let contractCallDataIndex = 0;
  try {
    if (data?.startsWith(import_enums.TransactionTypesEnum.MultiESDTNFTTransfer) && data?.includes("@")) {
      const [, receiver, encodedTxCount, ...rest] = data.split("@");
      if (receiver) {
        const txCount = new import_bignumber.default(encodedTxCount, 16).toNumber();
        if (txCount >= Number.MAX_SAFE_INTEGER) {
          return [];
        }
        let itemIndex = 0;
        for (let txIndex = 0; txIndex < txCount; txIndex++) {
          const transaction = {
            type: import_enums.TransactionTypesEnum.nftTransaction,
            data: "",
            receiver
          };
          for (let index = 0; index < 3; index++) {
            switch (index) {
              case 0:
                transaction.token = (0, import_decodePart.decodePart)(rest[itemIndex]);
                transaction.data = rest[itemIndex];
                break;
              case 1: {
                const encodedNonce = rest[itemIndex] && rest[itemIndex].length ? rest[itemIndex] : "";
                if (encodedNonce && encodedNonce !== "00") {
                  transaction.nonce = encodedNonce;
                } else {
                  transaction.type = import_enums.TransactionTypesEnum.esdtTransaction;
                }
                transaction.data = `${transaction.data}@${rest[itemIndex]}`;
                break;
              }
              case 2:
                transaction.amount = new import_bignumber.default(
                  rest[itemIndex],
                  16
                ).toString(10);
                transaction.data = `${transaction.data}@${rest[itemIndex]}`;
                break;
              default:
                break;
            }
            contractCallDataIndex = itemIndex + 1;
            itemIndex++;
          }
          transactions[txIndex] = transaction;
        }
        const isDifferentFromTxCount = transactions.length !== txCount;
        const hasInvalidNoOfAdSigns = transactions.some((tx) => {
          const adSignOccurences = (0, import_getAllStringOccurrences.getAllStringOccurrences)(tx.data, "@").length;
          return adSignOccurences !== 2;
        });
        const hasAdStart = transactions.some((tx) => tx.data.startsWith("@"));
        if (isDifferentFromTxCount || hasInvalidNoOfAdSigns || hasAdStart) {
          return [];
        }
        if (rest[contractCallDataIndex]) {
          let scCallData = rest[contractCallDataIndex];
          for (let i = contractCallDataIndex + 1; i < rest.length; i++) {
            scCallData += "@" + rest[i];
          }
          transactions[txCount] = {
            type: import_enums.TransactionTypesEnum.scCall,
            data: scCallData,
            receiver
          };
        }
      }
    }
  } catch (err) {
    console.error("failed parsing tx", err);
    return transactions;
  }
  return transactions;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  parseMultiEsdtTransferData
});
//# sourceMappingURL=parseMultiEsdtTransferData.cjs.map
