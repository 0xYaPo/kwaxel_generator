"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var decodeDataField_exports = {};
__export(decodeDataField_exports, {
  getAllDecodedFormats: () => getAllDecodedFormats
});
module.exports = __toCommonJS(decodeDataField_exports);
var import_sdk_core = require("@multiversx/sdk-core");
var import_bignumber = __toESM(require("bignumber.js"));
var import_enums = require("../../../../../../../types/enums.types");
var import_serverTransactions = require("../../../../../../../types/serverTransactions.types");
var import_decoders = require("../../../../../../../utils/decoders");
var import_addressIsValid = require("../../../../../../../utils/validation/addressIsValid");
var import_hex = require("../../../../../../../utils/validation/hex");
const getHexValidationWarnings = (str) => {
  const warnings = [];
  if (str && !(0, import_hex.isHexValidCharacters)(str)) {
    warnings.push(`Invalid Hex characters on argument @${str}`);
  }
  if (str && !(0, import_hex.isHexValidLength)(str)) {
    warnings.push(`Odd number of Hex characters on argument @${str}`);
  }
  return warnings;
};
const decodeByMethod = (part, decodeMethod, transactionTokens) => {
  switch (decodeMethod) {
    case import_serverTransactions.DecodeMethodEnum.text:
      try {
        return Buffer.from(part, "hex").toString("utf8");
      } catch {
        return part;
      }
    case import_serverTransactions.DecodeMethodEnum.decimal:
      return part !== "" ? new import_bignumber.default(part, 16).toString(10) : "";
    case import_serverTransactions.DecodeMethodEnum.smart:
      try {
        const bech32Encoded = import_sdk_core.Address.newFromHex(part).toString();
        if ((0, import_addressIsValid.addressIsValid)(bech32Encoded)) {
          return bech32Encoded;
        }
      } catch {
      }
      try {
        const decoded = Buffer.from(part, "hex").toString("utf8");
        if (!(0, import_decoders.isUtf8)(decoded)) {
          if (transactionTokens) {
            const tokens = [
              ...transactionTokens.esdts,
              ...transactionTokens.nfts
            ];
            if (tokens.some((token) => decoded.includes(token))) {
              return decoded;
            }
          }
          const bigNumber = new import_bignumber.default(part, 16);
          return bigNumber.isFinite() ? bigNumber.toString(10) : part;
        } else {
          return decoded;
        }
      } catch {
        return part;
      }
    case import_serverTransactions.DecodeMethodEnum.raw:
    default:
      return part;
  }
};
const getSmartDecodedParts = ({
  parts,
  decodedParts,
  identifier
}) => {
  const smartDecodedParts = [...decodedParts];
  if (parts[0] === import_enums.TransactionTypesEnum.ESDTNFTTransfer && parts[2]) {
    smartDecodedParts[2] = decodeByMethod(parts[2], import_serverTransactions.DecodeMethodEnum.decimal);
  }
  if (identifier === import_enums.TransactionTypesEnum.ESDTNFTTransfer && parts[1]) {
    const base64Buffer = Buffer.from(String(parts[1]), "base64");
    smartDecodedParts[1] = decodeByMethod(
      base64Buffer.toString("hex"),
      import_serverTransactions.DecodeMethodEnum.decimal
    );
  }
  return smartDecodedParts;
};
const getDisplayValueAndValidationWarnings = ({
  parts,
  decodeMethod,
  identifier,
  decodedData
}) => {
  const initialDecodedParts = parts.map((part, index) => {
    if (parts.length >= 2 && (index === 0 && part.length < 64 || index === 1 && !parts[0])) {
      const encodedDisplayValue = /[^a-z0-9]/gi.test(part);
      if (encodedDisplayValue) {
        return decodeByMethod(part, decodeMethod);
      }
      return part;
    }
    const hexValidationWarnings = getHexValidationWarnings(part);
    if (hexValidationWarnings?.length) {
      decodedData.validationWarnings = Array.from(
        /* @__PURE__ */ new Set([...decodedData.validationWarnings, ...hexValidationWarnings])
      );
    }
    return decodeByMethod(part, decodeMethod);
  });
  const decodedParts = decodeMethod === import_serverTransactions.DecodeMethodEnum.smart ? getSmartDecodedParts({
    parts,
    decodedParts: initialDecodedParts,
    identifier
  }) : initialDecodedParts;
  return decodedParts;
};
const getDecodedParts = ({
  parts,
  decodeMethod,
  identifier,
  initialDecodedParts
}) => {
  if (decodeMethod === import_serverTransactions.DecodeMethodEnum.smart) {
    return getSmartDecodedParts({
      parts,
      decodedParts: initialDecodedParts,
      identifier
    });
  }
  return initialDecodedParts;
};
const decodeHighlight = ({
  data,
  identifier,
  decodeMethod,
  delimiter
}) => {
  const parts = data.split("@");
  const initialDecodedParts = parts.map((part) => {
    return decodeByMethod(part, decodeMethod);
  });
  const decodedHighlight = getDecodedParts({
    parts,
    initialDecodedParts,
    identifier,
    decodeMethod
  });
  return decodedHighlight.join(delimiter);
};
const decodeDataField = ({
  data,
  identifier,
  decodeMethod,
  highlight
}) => {
  const decodedData = {
    displayValue: "",
    validationWarnings: [],
    highlight
  };
  const hasAt = data.includes("@");
  const hasNewLine = data.includes("\n");
  if (!hasAt && !hasNewLine) {
    return {
      ...decodedData,
      displayValue: decodeByMethod(data, decodeMethod),
      highlight: highlight ? decodeByMethod(highlight, decodeMethod) : highlight
    };
  }
  if (hasAt) {
    const parts = data.split("@");
    const decodedParts = getDisplayValueAndValidationWarnings({
      parts,
      decodeMethod,
      identifier,
      decodedData
    });
    const decodedHighlight = highlight ? decodeHighlight({
      data: highlight,
      identifier,
      decodeMethod,
      delimiter: "@"
    }) : null;
    return {
      ...decodedData,
      displayValue: decodedParts.join("@"),
      highlight: decodedHighlight
    };
  }
  if (hasNewLine) {
    const parts = data.split("\n");
    const initialDecodedParts = parts.map((part) => {
      if (decodeMethod === import_serverTransactions.DecodeMethodEnum.raw) {
        return part;
      }
      return decodeByMethod(
        Buffer.from(part, "base64").toString("hex"),
        decodeMethod
      );
    });
    const decodedParts = getDecodedParts({
      parts,
      initialDecodedParts,
      identifier,
      decodeMethod
    });
    const decodedHighlight = highlight ? decodeHighlight({
      data: highlight,
      identifier,
      decodeMethod,
      delimiter: "\n"
    }) : null;
    return {
      ...decodedData,
      displayValue: decodedParts.join("\n"),
      highlight: decodedHighlight
    };
  }
  return decodedData;
};
const getAllDecodedFormats = ({
  data,
  highlight,
  identifier
}) => {
  const decodedFormats = {};
  Object.values(import_serverTransactions.DecodeMethodEnum).forEach((decodeMethod) => {
    const decodedData = decodeDataField({
      data,
      identifier,
      decodeMethod,
      highlight
    });
    decodedFormats[decodeMethod] = decodedData;
  });
  return decodedFormats;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getAllDecodedFormats
});
//# sourceMappingURL=decodeDataField.cjs.map
